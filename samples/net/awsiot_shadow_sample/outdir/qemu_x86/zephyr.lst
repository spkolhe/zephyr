
zephyr.elf:     file format elf32-i386


Disassembly of section text:

00001000 <__start>:
        mov  %eax, %esi			/* low  value */
        mov  %edx, %edi			/* high value */
#endif

	/* Enable write-back caching by clearing the NW and CD bits */
	movl	%cr0, %eax
    1000:	0f 20 c0             	mov    %cr0,%eax
	andl	$0x9fffffff, %eax
    1003:	25 ff ff ff 9f       	and    $0x9fffffff,%eax
	movl	%eax, %cr0
    1008:	0f 22 c0             	mov    %eax,%cr0
	/*
	 * Ensure interrupts are disabled.  Interrupts are enabled when
	 * the first context switch occurs.
	 */

	cli
    100b:	fa                   	cli    
	 * Although the bootloader sets up an Interrupt Descriptor Table (IDT)
	 * and a Global Descriptor Table (GDT), the specification encourages
	 * booted operating systems to setup their own IDT and GDT.
	 */
#if CONFIG_SET_GDT
	lgdt	_gdt_rom		/* load 32-bit operand size GDT */
    100c:	0f 01 15 b0 10 00 00 	lgdtl  0x10b0
#endif
	lidt	_Idt		/* load 32-bit operand size IDT */
    1013:	0f 01 1d 9e 10 00 00 	lidtl  0x109e


#ifdef CONFIG_SET_GDT
	/* If we set our own GDT, update the segment registers as well.
	 */
	movw	$DATA_SEG, %ax	/* data segment selector (entry = 3) */
    101a:	66 b8 10 00          	mov    $0x10,%ax
	movw	%ax, %ds	/* set DS */
    101e:	8e d8                	mov    %eax,%ds
	movw	%ax, %es	/* set ES */
    1020:	8e c0                	mov    %eax,%es
	movw	%ax, %fs	/* set FS */
    1022:	8e e0                	mov    %eax,%fs
	movw	%ax, %gs	/* set GS */
    1024:	8e e8                	mov    %eax,%gs
	movw	%ax, %ss	/* set SS */
    1026:	8e d0                	mov    %eax,%ss

	ljmp	$CODE_SEG, $__csSet	/* set CS = 0x08 */
    1028:	ea 2f 10 00 00 08 00 	ljmp   $0x8,$0x102f

0000102f <__csSet>:
	/*
	 * Force an #NM exception for floating point instructions
	 * since FP support hasn't been configured
	 */

	movl	%cr0, %eax		/* move CR0 to EAX */
    102f:	0f 20 c0             	mov    %cr0,%eax
	orl	$0x2e, %eax		/* CR0[NE+TS+EM+MP]=1 */
    1032:	83 c8 2e             	or     $0x2e,%eax
	movl	%eax, %cr0		/* move EAX to CR0 */
    1035:	0f 22 c0             	mov    %eax,%cr0
	stack_size_dwords = (CONFIG_ISR_STACK_SIZE / 4)
	movl $stack_size_dwords, %ecx
	rep  stosl
#endif

	movl	$_interrupt_stack, %esp
    1038:	bc 00 20 41 00       	mov    $0x412000,%esp
#ifdef CONFIG_X86_STACK_PROTECTION
	/* In this configuration, all stacks, including IRQ stack, are declared
	 * with a 4K non-present guard page preceding the stack buffer
	 */
	addl	$(CONFIG_ISR_STACK_SIZE + 4096), %esp
    103d:	81 c4 00 18 00 00    	add    $0x1800,%esp
	/*
	 * copy DATA section from ROM to RAM region
	 *	 DATA is followed by BSS section.
	 */

	movl	$__data_ram_start, %edi /* DATA in RAM (dest) */
    1043:	bf 00 00 40 00       	mov    $0x400000,%edi
	movl	$__data_rom_start, %esi /* DATA in ROM (src) */
    1048:	be 90 83 00 00       	mov    $0x8390,%esi
	movl	$__data_num_words, %ecx /* Size of DATA in quad bytes */
    104d:	b9 7e 14 00 00       	mov    $0x147e,%ecx

	call	_x86_data_copy
    1052:	e8 44 00 00 00       	call   109b <_x86_data_copy>
	 * Clear BSS: bzero (__bss_start, __bss_num_words*4)
	 *
	 * It's assumed that BSS size will be a multiple of a long (4 bytes),
	 * and aligned on a double word (32-bit) boundary
	 */
	movl	$__bss_start, %edi	/* load BSS start address */
    1057:	bf 00 52 40 00       	mov    $0x405200,%edi
	movl	$__bss_num_words, %ecx	/* number of quad bytes in .bss */
    105c:	b9 fe 00 00 00       	mov    $0xfe,%ecx
	call	_x86_bss_zero
    1061:	e8 2f 00 00 00       	call   1095 <_x86_bss_zero>
	call	_x86_bss_zero
#endif

#ifdef CONFIG_GDT_DYNAMIC
	/* activate RAM-based Global Descriptor Table (GDT) */
	lgdt	%ds:_gdt
    1066:	0f 01 15 08 02 40 00 	lgdtl  0x400208
#endif

#ifdef CONFIG_X86_MMU

	/* load the page directory address into the registers*/
	movl $__mmu_tables_start, %eax
    106d:	b8 00 10 40 00       	mov    $0x401000,%eax
	movl %eax, %cr3
    1072:	0f 22 d8             	mov    %eax,%cr3

	/*Set CR4.PAE = 0 (5th bit in CR4*/
	movl %cr4, %eax
    1075:	0f 20 e0             	mov    %cr4,%eax
	andl $CR4_PAE_DISABLE, %eax
    1078:	83 e0 ef             	and    $0xffffffef,%eax
	movl %eax, %cr4
    107b:	0f 22 e0             	mov    %eax,%cr4

	/* set CR0.PG bit (31st bit in CR0)*/
	movl %cr0, %eax
    107e:	0f 20 c0             	mov    %cr0,%eax
	orl $CR0_PAGING_ENABLE, %eax
    1081:	0d 00 00 01 80       	or     $0x80010000,%eax
	movl %eax, %cr0
    1086:	0f 22 c0             	mov    %eax,%cr0

#endif /* CONFIG_X86_MMU */

#ifdef CONFIG_X86_STACK_PROTECTION
	mov $MAIN_TSS, %ax
    1089:	66 b8 18 00          	mov    $0x18,%ax
	ltr %ax
    108d:	0f 00 d8             	ltr    %ax
#endif
	/* Jump to C portion of kernel initialization and never return */

	jmp	_Cstart
    1090:	e9 c5 50 00 00       	jmp    615a <_Cstart>

00001095 <_x86_bss_zero>:

#else /* !CONFIG_SSE */

	/* clear out BSS double words (32-bits at a time) */

	xorl	%eax, %eax		/* fill memory with 0 */
    1095:	31 c0                	xor    %eax,%eax
	cld
    1097:	fc                   	cld    
	rep
    1098:	f3 ab                	rep stos %eax,%es:(%edi)
	stosl				/* zero memory per 4 bytes */

#endif /* CONFIG_SSE */
	ret
    109a:	c3                   	ret    

0000109b <_x86_data_copy>:
dataWords:
	movl	%edx, %ecx	/* restore # quad bytes */
	andl	$0x3, %ecx	/* only need to copy at most 3 quad bytes */
  #endif /* CONFIG_SSE */

	rep
    109b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	movsl				/* copy data 4 bytes at a time */
	ret
    109d:	c3                   	ret    

0000109e <_Idt>:
    109e:	ff 07 10 7b 00 00 02 b0 ad 1b 00 00 00 00 fe 4f     ...{...........O
    10ae:	52 e4                                               R.

000010b0 <_gdt_rom>:
    10b0:	17                   	pop    %ss
    10b1:	00 b0 10 00 00 00    	add    %dh,0x10(%eax)
    10b7:	00 ff                	add    %bh,%bh
    10b9:	ff 00                	incl   (%eax)
    10bb:	00 00                	add    %al,(%eax)
    10bd:	9b                   	fwait
    10be:	cf                   	iret   
    10bf:	00 ff                	add    %bh,%bh
    10c1:	ff 00                	incl   (%eax)
    10c3:	00 00                	add    %al,(%eax)
    10c5:	93                   	xchg   %eax,%ebx
    10c6:	cf                   	iret   
	...

000010c8 <_gdt_rom_end>:
    10c8:	66 90                	xchg   %ax,%ax
    10ca:	66 90                	xchg   %ax,%ax
    10cc:	66 90                	xchg   %ax,%ax
    10ce:	66 90                	xchg   %ax,%ax

000010d0 <__udivdi3>:
    10d0:	55                   	push   %ebp
    10d1:	57                   	push   %edi
    10d2:	56                   	push   %esi
    10d3:	53                   	push   %ebx
    10d4:	83 ec 1c             	sub    $0x1c,%esp
    10d7:	8b 5c 24 30          	mov    0x30(%esp),%ebx
    10db:	8b 4c 24 34          	mov    0x34(%esp),%ecx
    10df:	8b 7c 24 38          	mov    0x38(%esp),%edi
    10e3:	8b 74 24 3c          	mov    0x3c(%esp),%esi
    10e7:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    10eb:	89 ca                	mov    %ecx,%edx
    10ed:	89 7c 24 08          	mov    %edi,0x8(%esp)
    10f1:	85 f6                	test   %esi,%esi
    10f3:	75 3b                	jne    1130 <__udivdi3+0x60>
    10f5:	39 cf                	cmp    %ecx,%edi
    10f7:	0f 87 c3 00 00 00    	ja     11c0 <__udivdi3+0xf0>
    10fd:	89 fd                	mov    %edi,%ebp
    10ff:	85 ff                	test   %edi,%edi
    1101:	75 0b                	jne    110e <__udivdi3+0x3e>
    1103:	b8 01 00 00 00       	mov    $0x1,%eax
    1108:	31 d2                	xor    %edx,%edx
    110a:	f7 f7                	div    %edi
    110c:	89 c5                	mov    %eax,%ebp
    110e:	89 c8                	mov    %ecx,%eax
    1110:	31 d2                	xor    %edx,%edx
    1112:	f7 f5                	div    %ebp
    1114:	89 c1                	mov    %eax,%ecx
    1116:	89 d8                	mov    %ebx,%eax
    1118:	89 cf                	mov    %ecx,%edi
    111a:	f7 f5                	div    %ebp
    111c:	89 fa                	mov    %edi,%edx
    111e:	83 c4 1c             	add    $0x1c,%esp
    1121:	5b                   	pop    %ebx
    1122:	5e                   	pop    %esi
    1123:	5f                   	pop    %edi
    1124:	5d                   	pop    %ebp
    1125:	c3                   	ret    
    1126:	8d 76 00             	lea    0x0(%esi),%esi
    1129:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    1130:	39 ce                	cmp    %ecx,%esi
    1132:	77 7c                	ja     11b0 <__udivdi3+0xe0>
    1134:	0f bd fe             	bsr    %esi,%edi
    1137:	83 f7 1f             	xor    $0x1f,%edi
    113a:	0f 84 90 00 00 00    	je     11d0 <__udivdi3+0x100>
    1140:	bd 20 00 00 00       	mov    $0x20,%ebp
    1145:	8b 5c 24 08          	mov    0x8(%esp),%ebx
    1149:	29 fd                	sub    %edi,%ebp
    114b:	89 f9                	mov    %edi,%ecx
    114d:	d3 e6                	shl    %cl,%esi
    114f:	89 d8                	mov    %ebx,%eax
    1151:	89 e9                	mov    %ebp,%ecx
    1153:	d3 e8                	shr    %cl,%eax
    1155:	09 f0                	or     %esi,%eax
    1157:	89 f9                	mov    %edi,%ecx
    1159:	89 44 24 08          	mov    %eax,0x8(%esp)
    115d:	89 d8                	mov    %ebx,%eax
    115f:	d3 e0                	shl    %cl,%eax
    1161:	89 d3                	mov    %edx,%ebx
    1163:	89 e9                	mov    %ebp,%ecx
    1165:	d3 eb                	shr    %cl,%ebx
    1167:	89 f9                	mov    %edi,%ecx
    1169:	89 de                	mov    %ebx,%esi
    116b:	d3 e2                	shl    %cl,%edx
    116d:	8b 5c 24 04          	mov    0x4(%esp),%ebx
    1171:	89 e9                	mov    %ebp,%ecx
    1173:	d3 eb                	shr    %cl,%ebx
    1175:	09 da                	or     %ebx,%edx
    1177:	89 44 24 0c          	mov    %eax,0xc(%esp)
    117b:	89 d0                	mov    %edx,%eax
    117d:	89 f2                	mov    %esi,%edx
    117f:	f7 74 24 08          	divl   0x8(%esp)
    1183:	89 d6                	mov    %edx,%esi
    1185:	89 c3                	mov    %eax,%ebx
    1187:	f7 64 24 0c          	mull   0xc(%esp)
    118b:	39 d6                	cmp    %edx,%esi
    118d:	72 10                	jb     119f <__udivdi3+0xcf>
    118f:	8b 6c 24 04          	mov    0x4(%esp),%ebp
    1193:	89 f9                	mov    %edi,%ecx
    1195:	d3 e5                	shl    %cl,%ebp
    1197:	39 c5                	cmp    %eax,%ebp
    1199:	73 55                	jae    11f0 <__udivdi3+0x120>
    119b:	39 d6                	cmp    %edx,%esi
    119d:	75 51                	jne    11f0 <__udivdi3+0x120>
    119f:	8d 43 ff             	lea    -0x1(%ebx),%eax
    11a2:	31 ff                	xor    %edi,%edi
    11a4:	89 fa                	mov    %edi,%edx
    11a6:	83 c4 1c             	add    $0x1c,%esp
    11a9:	5b                   	pop    %ebx
    11aa:	5e                   	pop    %esi
    11ab:	5f                   	pop    %edi
    11ac:	5d                   	pop    %ebp
    11ad:	c3                   	ret    
    11ae:	66 90                	xchg   %ax,%ax
    11b0:	31 ff                	xor    %edi,%edi
    11b2:	31 c0                	xor    %eax,%eax
    11b4:	89 fa                	mov    %edi,%edx
    11b6:	83 c4 1c             	add    $0x1c,%esp
    11b9:	5b                   	pop    %ebx
    11ba:	5e                   	pop    %esi
    11bb:	5f                   	pop    %edi
    11bc:	5d                   	pop    %ebp
    11bd:	c3                   	ret    
    11be:	66 90                	xchg   %ax,%ax
    11c0:	89 d8                	mov    %ebx,%eax
    11c2:	f7 f7                	div    %edi
    11c4:	31 ff                	xor    %edi,%edi
    11c6:	89 fa                	mov    %edi,%edx
    11c8:	83 c4 1c             	add    $0x1c,%esp
    11cb:	5b                   	pop    %ebx
    11cc:	5e                   	pop    %esi
    11cd:	5f                   	pop    %edi
    11ce:	5d                   	pop    %ebp
    11cf:	c3                   	ret    
    11d0:	39 ce                	cmp    %ecx,%esi
    11d2:	72 10                	jb     11e4 <__udivdi3+0x114>
    11d4:	8b 5c 24 04          	mov    0x4(%esp),%ebx
    11d8:	31 c0                	xor    %eax,%eax
    11da:	39 5c 24 08          	cmp    %ebx,0x8(%esp)
    11de:	0f 87 38 ff ff ff    	ja     111c <__udivdi3+0x4c>
    11e4:	b8 01 00 00 00       	mov    $0x1,%eax
    11e9:	e9 2e ff ff ff       	jmp    111c <__udivdi3+0x4c>
    11ee:	66 90                	xchg   %ax,%ax
    11f0:	89 d8                	mov    %ebx,%eax
    11f2:	31 ff                	xor    %edi,%edi
    11f4:	e9 23 ff ff ff       	jmp    111c <__udivdi3+0x4c>

000011f9 <main>:
		}
	}

}

void main(void) {
    11f9:	55                   	push   %ebp
    11fa:	89 e5                	mov    %esp,%ebp
    11fc:	53                   	push   %ebx
    11fd:	81 ec 24 03 00 00    	sub    $0x324,%esp

	IOT_INFO("\nAWS IoT SDK Version %d.%d.%d-%s\n", VERSION_MAJOR, VERSION_MINOR, VERSION_PATCH, VERSION_TAG);

	//getcwd(CurrentWD, sizeof(CurrentWD));
	char *CurrentWD1 = "/home/shubham/zephyr-zephyr-aws-1.9.2/zephyr/samples/net/awsiot_shadow_sample/src";
	strcpy(CurrentWD,CurrentWD1);
    1203:	8d 9d 33 ff ff ff    	lea    -0xcd(%ebp),%ebx
    1209:	68 c0 74 00 00       	push   $0x74c0
    120e:	53                   	push   %ebx
    120f:	e8 d1 0d 00 00       	call   1fe5 <strcpy>
    1214:	58                   	pop    %eax
	snprintf(rootCA, PATH_MAX + 1, "%s/%s/%s", CurrentWD, certDirectory, AWS_IOT_ROOT_CA_FILENAME);
    1215:	8d 85 d8 fc ff ff    	lea    -0x328(%ebp),%eax
	strcpy(CurrentWD,CurrentWD1);
    121b:	5a                   	pop    %edx
	snprintf(rootCA, PATH_MAX + 1, "%s/%s/%s", CurrentWD, certDirectory, AWS_IOT_ROOT_CA_FILENAME);
    121c:	68 12 75 00 00       	push   $0x7512
    1221:	68 00 00 40 00       	push   $0x400000
    1226:	53                   	push   %ebx
    1227:	68 1d 75 00 00       	push   $0x751d
    122c:	68 c9 00 00 00       	push   $0xc9
    1231:	50                   	push   %eax
    1232:	e8 75 0d 00 00       	call   1fac <snprintf>
    1237:	83 c4 18             	add    $0x18,%esp
	snprintf(clientCRT, PATH_MAX + 1, "%s/%s/%s", CurrentWD, certDirectory, AWS_IOT_CERTIFICATE_FILENAME);
    123a:	8d 85 a1 fd ff ff    	lea    -0x25f(%ebp),%eax
    1240:	68 26 75 00 00       	push   $0x7526
    1245:	68 00 00 40 00       	push   $0x400000
    124a:	53                   	push   %ebx
    124b:	68 1d 75 00 00       	push   $0x751d
    1250:	68 c9 00 00 00       	push   $0xc9
    1255:	50                   	push   %eax
    1256:	e8 51 0d 00 00       	call   1fac <snprintf>
    125b:	83 c4 18             	add    $0x18,%esp
	snprintf(clientKey, PATH_MAX + 1, "%s/%s/%s", CurrentWD, certDirectory, AWS_IOT_PRIVATE_KEY_FILENAME);
    125e:	8d 85 6a fe ff ff    	lea    -0x196(%ebp),%eax
    1264:	68 2f 75 00 00       	push   $0x752f
    1269:	68 00 00 40 00       	push   $0x400000
    126e:	53                   	push   %ebx
    126f:	68 1d 75 00 00       	push   $0x751d
    1274:	68 c9 00 00 00       	push   $0xc9
    1279:	50                   	push   %eax
    127a:	e8 2d 0d 00 00       	call   1fac <snprintf>
    127f:	83 c4 18             	add    $0x18,%esp
    1282:	eb fe                	jmp    1282 <main+0x89>

00001284 <_to_x>:
/* Writes the specified number into the buffer in the given base,
 * using the digit characters 0-9a-z (i.e. base>36 will start writing
 * odd bytes), padding with leading zeros up to the minimum length.
 */
static int _to_x(char *buf, uint32_t n, int base, int minlen)
{
    1284:	55                   	push   %ebp
    1285:	89 e5                	mov    %esp,%ebp
    1287:	57                   	push   %edi
    1288:	56                   	push   %esi
    1289:	89 c6                	mov    %eax,%esi
    128b:	53                   	push   %ebx
    128c:	89 d0                	mov    %edx,%eax
    128e:	53                   	push   %ebx
    128f:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    1292:	89 f3                	mov    %esi,%ebx
	char *buf0 = buf;

	do {
		int d = n % base;

		n /= base;
    1294:	31 d2                	xor    %edx,%edx
		*buf++ = '0' + d + (d > 9 ? ('a' - '0' - 10) : 0);
    1296:	43                   	inc    %ebx
		n /= base;
    1297:	f7 75 f0             	divl   -0x10(%ebp)
		*buf++ = '0' + d + (d > 9 ? ('a' - '0' - 10) : 0);
    129a:	83 fa 09             	cmp    $0x9,%edx
    129d:	0f 9e c1             	setle  %cl
    12a0:	89 cf                	mov    %ecx,%edi
    12a2:	4f                   	dec    %edi
    12a3:	83 e7 27             	and    $0x27,%edi
	} while (n);
    12a6:	85 c0                	test   %eax,%eax
		*buf++ = '0' + d + (d > 9 ? ('a' - '0' - 10) : 0);
    12a8:	8d 54 17 30          	lea    0x30(%edi,%edx,1),%edx
    12ac:	88 53 ff             	mov    %dl,-0x1(%ebx)
	} while (n);
    12af:	75 e3                	jne    1294 <_to_x+0x10>
    12b1:	89 d8                	mov    %ebx,%eax
    12b3:	29 f0                	sub    %esi,%eax
    12b5:	8d 14 06             	lea    (%esi,%eax,1),%edx
	while (end - start < minlen) {
    12b8:	39 45 08             	cmp    %eax,0x8(%ebp)
    12bb:	7e 07                	jle    12c4 <_to_x+0x40>
		*end++ = '0';
    12bd:	c6 04 06 30          	movb   $0x30,(%esi,%eax,1)
    12c1:	40                   	inc    %eax
    12c2:	eb f1                	jmp    12b5 <_to_x+0x31>
	*end = 0;
    12c4:	c6 02 00             	movb   $0x0,(%edx)
	for (end--; end > start; end--, start++) {
    12c7:	4a                   	dec    %edx
    12c8:	39 f2                	cmp    %esi,%edx
    12ca:	76 0d                	jbe    12d9 <_to_x+0x55>
		char tmp = *end;
    12cc:	8a 1a                	mov    (%edx),%bl
		*end = *start;
    12ce:	8a 0e                	mov    (%esi),%cl
    12d0:	88 0a                	mov    %cl,(%edx)
	for (end--; end > start; end--, start++) {
    12d2:	46                   	inc    %esi
		*start = tmp;
    12d3:	88 5e ff             	mov    %bl,-0x1(%esi)
	for (end--; end > start; end--, start++) {
    12d6:	4a                   	dec    %edx
    12d7:	eb ef                	jmp    12c8 <_to_x+0x44>
	return _reverse_and_pad(buf0, buf, minlen);
}
    12d9:	5a                   	pop    %edx
    12da:	5b                   	pop    %ebx
    12db:	5e                   	pop    %esi
    12dc:	5f                   	pop    %edi
    12dd:	5d                   	pop    %ebp
    12de:	c3                   	ret    

000012df <_rlrshift>:

	return (buf + _to_udec(buf, (uint32_t) value, precision)) - start;
}

static	void _rlrshift(uint64_t *v)
{
    12df:	55                   	push   %ebp
	*v = (*v & 1) + (*v >> 1);
    12e0:	8b 08                	mov    (%eax),%ecx
{
    12e2:	89 e5                	mov    %esp,%ebp
	*v = (*v & 1) + (*v >> 1);
    12e4:	89 ca                	mov    %ecx,%edx
{
    12e6:	57                   	push   %edi
    12e7:	56                   	push   %esi
    12e8:	53                   	push   %ebx
	*v = (*v & 1) + (*v >> 1);
    12e9:	8b 58 04             	mov    0x4(%eax),%ebx
    12ec:	0f ac d9 01          	shrd   $0x1,%ebx,%ecx
    12f0:	83 e2 01             	and    $0x1,%edx
    12f3:	31 ff                	xor    %edi,%edi
    12f5:	d1 eb                	shr    %ebx
    12f7:	01 d1                	add    %edx,%ecx
    12f9:	11 fb                	adc    %edi,%ebx
    12fb:	89 08                	mov    %ecx,(%eax)
    12fd:	89 58 04             	mov    %ebx,0x4(%eax)
}
    1300:	5b                   	pop    %ebx
    1301:	5e                   	pop    %esi
    1302:	5f                   	pop    %edi
    1303:	5d                   	pop    %ebp
    1304:	c3                   	ret    

00001305 <_ldiv5>:
 * six.  This was tested exhaustively through the first ~10B values in
 * the input space, and for ~2e12 (4 hours runtime) random inputs
 * taken from the full 64 bit space.
 */
static void _ldiv5(uint64_t *v)
{
    1305:	55                   	push   %ebp
    1306:	89 e5                	mov    %esp,%ebp
    1308:	57                   	push   %edi
    1309:	56                   	push   %esi
    130a:	53                   	push   %ebx
    130b:	83 ec 14             	sub    $0x14,%esp
    130e:	89 45 e0             	mov    %eax,-0x20(%ebp)
	uint32_t i, hi;
	uint64_t rem = *v, quot = 0, q;
    1311:	8b 50 04             	mov    0x4(%eax),%edx
    1314:	8b 00                	mov    (%eax),%eax
	static const char shifts[] = { 32, 3, 0 };

	/* Usage in this file wants rounded behavior, not truncation.  So add
	 * two to get the threshold right.
	 */
	rem += 2;
    1316:	83 c0 02             	add    $0x2,%eax
    1319:	83 d2 00             	adc    $0x0,%edx
    131c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    131f:	89 55 e8             	mov    %edx,-0x18(%ebp)
	uint64_t rem = *v, quot = 0, q;
    1322:	31 f6                	xor    %esi,%esi
    1324:	31 ff                	xor    %edi,%edi

	for (i = 0; i < 3; i++) {
    1326:	31 db                	xor    %ebx,%ebx
		hi = rem >> shifts[i];
    1328:	0f be 83 46 75 00 00 	movsbl 0x7546(%ebx),%eax
    132f:	89 45 ec             	mov    %eax,-0x14(%ebp)
    1332:	8b 55 e8             	mov    -0x18(%ebp),%edx
    1335:	8a 4d ec             	mov    -0x14(%ebp),%cl
    1338:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    133b:	0f ad d0             	shrd   %cl,%edx,%eax
    133e:	d3 ea                	shr    %cl,%edx
    1340:	f6 c1 20             	test   $0x20,%cl
    1343:	74 02                	je     1347 <_ldiv5+0x42>
    1345:	89 d0                	mov    %edx,%eax
		q = (uint64_t)(hi / 5) << shifts[i];
    1347:	b9 05 00 00 00       	mov    $0x5,%ecx
    134c:	31 d2                	xor    %edx,%edx
    134e:	f7 f1                	div    %ecx
    1350:	8a 4d ec             	mov    -0x14(%ebp),%cl
    1353:	31 d2                	xor    %edx,%edx
    1355:	0f a5 c2             	shld   %cl,%eax,%edx
    1358:	d3 e0                	shl    %cl,%eax
    135a:	f6 c1 20             	test   $0x20,%cl
    135d:	74 04                	je     1363 <_ldiv5+0x5e>
    135f:	89 c2                	mov    %eax,%edx
    1361:	31 c0                	xor    %eax,%eax
    1363:	89 45 ec             	mov    %eax,-0x14(%ebp)
    1366:	89 55 f0             	mov    %edx,-0x10(%ebp)
		rem -= q * 5;
    1369:	b8 05 00 00 00       	mov    $0x5,%eax
    136e:	6b 4d f0 05          	imul   $0x5,-0x10(%ebp),%ecx
    1372:	f7 65 ec             	mull   -0x14(%ebp)
    1375:	01 ca                	add    %ecx,%edx
    1377:	29 45 e4             	sub    %eax,-0x1c(%ebp)
    137a:	19 55 e8             	sbb    %edx,-0x18(%ebp)
		quot += q;
    137d:	03 75 ec             	add    -0x14(%ebp),%esi
    1380:	13 7d f0             	adc    -0x10(%ebp),%edi
	for (i = 0; i < 3; i++) {
    1383:	43                   	inc    %ebx
    1384:	83 fb 03             	cmp    $0x3,%ebx
    1387:	75 9f                	jne    1328 <_ldiv5+0x23>
	}

	*v = quot;
    1389:	8b 45 e0             	mov    -0x20(%ebp),%eax
    138c:	89 30                	mov    %esi,(%eax)
    138e:	89 78 04             	mov    %edi,0x4(%eax)
}
    1391:	83 c4 14             	add    $0x14,%esp
    1394:	5b                   	pop    %ebx
    1395:	5e                   	pop    %esi
    1396:	5f                   	pop    %edi
    1397:	5d                   	pop    %ebp
    1398:	c3                   	ret    

00001399 <_get_digit>:

static	char _get_digit(uint64_t *fr, int *digit_count)
{
    1399:	55                   	push   %ebp
    139a:	89 e5                	mov    %esp,%ebp
    139c:	57                   	push   %edi
    139d:	56                   	push   %esi
    139e:	53                   	push   %ebx
    139f:	89 c6                	mov    %eax,%esi
	int		rval;

	if (*digit_count > 0) {
    13a1:	8b 02                	mov    (%edx),%eax
    13a3:	85 c0                	test   %eax,%eax
    13a5:	7e 2d                	jle    13d4 <_get_digit+0x3b>
		*digit_count -= 1;
    13a7:	48                   	dec    %eax
		*fr = *fr * 10;
    13a8:	b9 0a 00 00 00       	mov    $0xa,%ecx
		*digit_count -= 1;
    13ad:	89 02                	mov    %eax,(%edx)
		*fr = *fr * 10;
    13af:	89 c8                	mov    %ecx,%eax
    13b1:	f7 26                	mull   (%esi)
    13b3:	6b 7e 04 0a          	imul   $0xa,0x4(%esi),%edi
    13b7:	89 d3                	mov    %edx,%ebx
    13b9:	89 c1                	mov    %eax,%ecx
    13bb:	01 fb                	add    %edi,%ebx
		rval = ((*fr >> 60) & 0xF) + '0';
		*fr &= 0x0FFFFFFFFFFFFFFFull;
    13bd:	89 0e                	mov    %ecx,(%esi)
		rval = ((*fr >> 60) & 0xF) + '0';
    13bf:	89 d8                	mov    %ebx,%eax
		*fr &= 0x0FFFFFFFFFFFFFFFull;
    13c1:	89 da                	mov    %ebx,%edx
		rval = ((*fr >> 60) & 0xF) + '0';
    13c3:	c1 e8 1c             	shr    $0x1c,%eax
		*fr &= 0x0FFFFFFFFFFFFFFFull;
    13c6:	81 e2 ff ff ff 0f    	and    $0xfffffff,%edx
		rval = ((*fr >> 60) & 0xF) + '0';
    13cc:	83 c0 30             	add    $0x30,%eax
		*fr &= 0x0FFFFFFFFFFFFFFFull;
    13cf:	89 56 04             	mov    %edx,0x4(%esi)
    13d2:	eb 05                	jmp    13d9 <_get_digit+0x40>
	} else
		rval = '0';
    13d4:	b8 30 00 00 00       	mov    $0x30,%eax
	return (char) (rval);
}
    13d9:	5b                   	pop    %ebx
    13da:	5e                   	pop    %esi
    13db:	5f                   	pop    %edi
    13dc:	5d                   	pop    %ebp
    13dd:	c3                   	ret    

000013de <_prf>:
	*sptr = p;
	return i;
}

int _prf(int (*func)(), void *dest, char *format, va_list vargs)
{
    13de:	8d 4c 24 04          	lea    0x4(%esp),%ecx
    13e2:	83 e4 f8             	and    $0xfffffff8,%esp
    13e5:	ff 71 fc             	pushl  -0x4(%ecx)
    13e8:	55                   	push   %ebp
    13e9:	89 e5                	mov    %esp,%ebp
    13eb:	57                   	push   %edi
    13ec:	56                   	push   %esi
    13ed:	53                   	push   %ebx
    13ee:	51                   	push   %ecx
    13ef:	81 ec 20 01 00 00    	sub    $0x120,%esp
	int32_t			*int32ptr_temp;
	int32_t			int32_temp;
	uint32_t			uint32_temp;
	uint64_t			double_temp;

	count = 0;
    13f5:	c7 85 ec fe ff ff 00 	movl   $0x0,-0x114(%ebp)
    13fc:	00 00 00 
{
    13ff:	8b 01                	mov    (%ecx),%eax
    1401:	8b 51 08             	mov    0x8(%ecx),%edx
    1404:	89 85 d8 fe ff ff    	mov    %eax,-0x128(%ebp)
    140a:	8b 41 04             	mov    0x4(%ecx),%eax
    140d:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
    1413:	8b 71 0c             	mov    0xc(%ecx),%esi

	while ((c = *format++)) {
    1416:	8d 42 01             	lea    0x1(%edx),%eax
    1419:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%ebp)
    141f:	0f be 02             	movsbl (%edx),%eax
    1422:	85 c0                	test   %eax,%eax
    1424:	0f 84 54 0b 00 00    	je     1f7e <__data_num_words+0xb00>
		if (c != '%') {
    142a:	83 f8 25             	cmp    $0x25,%eax
    142d:	75 31                	jne    1460 <_prf+0x82>
    142f:	c6 85 f3 fe ff ff 20 	movb   $0x20,-0x10d(%ebp)
    1436:	c7 85 e4 fe ff ff 00 	movl   $0x0,-0x11c(%ebp)
    143d:	00 00 00 
    1440:	c7 85 e8 fe ff ff 00 	movl   $0x0,-0x118(%ebp)
    1447:	00 00 00 
    144a:	c7 85 e0 fe ff ff 00 	movl   $0x0,-0x120(%ebp)
    1451:	00 00 00 
    1454:	c7 85 08 ff ff ff 00 	movl   $0x0,-0xf8(%ebp)
    145b:	00 00 00 
    145e:	eb 4b                	jmp    14ab <__data_num_words+0x2d>
			if ((*func) (c, dest) == EOF) {
    1460:	ff b5 d4 fe ff ff    	pushl  -0x12c(%ebp)
    1466:	50                   	push   %eax
    1467:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
    146d:	ff d0                	call   *%eax
    146f:	5b                   	pop    %ebx
    1470:	40                   	inc    %eax
    1471:	5f                   	pop    %edi
    1472:	75 0f                	jne    1483 <__data_num_words+0x5>
				return EOF;
    1474:	c7 85 ec fe ff ff ff 	movl   $0xffffffff,-0x114(%ebp)
    147b:	ff ff ff 
    147e:	e9 fb 0a 00 00       	jmp    1f7e <__data_num_words+0xb00>
			}

			count++;
    1483:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
    1489:	89 b5 fc fe ff ff    	mov    %esi,-0x104(%ebp)
    148f:	40                   	inc    %eax
    1490:	e9 45 02 00 00       	jmp    16da <__data_num_words+0x25c>
			fminus = fplus = fspace = falt = false;
			pad = ' ';		/* Default pad character    */
			precision = -1;	/* No precision specified   */

			while (strchr("-+ #0", (c = *format++)) != NULL) {
				switch (c) {
    1495:	80 fa 23             	cmp    $0x23,%dl
    1498:	74 75                	je     150f <__data_num_words+0x91>
    149a:	7e 44                	jle    14e0 <__data_num_words+0x62>
    149c:	80 fa 2d             	cmp    $0x2d,%dl
    149f:	75 58                	jne    14f9 <__data_num_words+0x7b>
				case '-':
					fminus = true;
    14a1:	c7 85 e0 fe ff ff 01 	movl   $0x1,-0x120(%ebp)
    14a8:	00 00 00 
		if (c != '%') {
    14ab:	8b bd 04 ff ff ff    	mov    -0xfc(%ebp),%edi
			while (strchr("-+ #0", (c = *format++)) != NULL) {
    14b1:	ff 85 04 ff ff ff    	incl   -0xfc(%ebp)
    14b7:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
    14bd:	0f be 58 ff          	movsbl -0x1(%eax),%ebx
    14c1:	53                   	push   %ebx
    14c2:	88 9d 0c ff ff ff    	mov    %bl,-0xf4(%ebp)
    14c8:	68 3b 75 00 00       	push   $0x753b
    14cd:	e8 31 0b 00 00       	call   2003 <strchr>
    14d2:	5a                   	pop    %edx
    14d3:	85 c0                	test   %eax,%eax
    14d5:	59                   	pop    %ecx
    14d6:	8a 95 0c ff ff ff    	mov    -0xf4(%ebp),%dl
    14dc:	75 b7                	jne    1495 <__data_num_words+0x17>
    14de:	eb 44                	jmp    1524 <__data_num_words+0xa6>
				switch (c) {
    14e0:	84 d2                	test   %dl,%dl
    14e2:	0f 84 96 0a 00 00    	je     1f7e <__data_num_words+0xb00>
    14e8:	80 fa 20             	cmp    $0x20,%dl
    14eb:	75 be                	jne    14ab <__data_num_words+0x2d>
				case '+':
					fplus = true;
					break;

				case ' ':
					fspace = true;
    14ed:	c7 85 e4 fe ff ff 01 	movl   $0x1,-0x11c(%ebp)
    14f4:	00 00 00 
					break;
    14f7:	eb b2                	jmp    14ab <__data_num_words+0x2d>
				switch (c) {
    14f9:	80 fa 30             	cmp    $0x30,%dl
    14fc:	74 1d                	je     151b <__data_num_words+0x9d>
    14fe:	80 fa 2b             	cmp    $0x2b,%dl
    1501:	75 a8                	jne    14ab <__data_num_words+0x2d>
					fplus = true;
    1503:	c7 85 e8 fe ff ff 01 	movl   $0x1,-0x118(%ebp)
    150a:	00 00 00 
					break;
    150d:	eb 9c                	jmp    14ab <__data_num_words+0x2d>

				case '#':
					falt = true;
    150f:	c7 85 08 ff ff ff 01 	movl   $0x1,-0xf8(%ebp)
    1516:	00 00 00 
					break;
    1519:	eb 90                	jmp    14ab <__data_num_words+0x2d>

				case '0':
					pad = '0';
    151b:	c6 85 f3 fe ff ff 30 	movb   $0x30,-0x10d(%ebp)
					break;
    1522:	eb 87                	jmp    14ab <__data_num_words+0x2d>
				case '\0':
					return count;
				}
			}

			if (c == '*') {
    1524:	83 fb 2a             	cmp    $0x2a,%ebx
    1527:	75 35                	jne    155e <__data_num_words+0xe0>
				/* Is the width a parameter? */
				width = (int32_t) va_arg(vargs, int32_t);
    1529:	8b 0e                	mov    (%esi),%ecx
    152b:	8d 46 04             	lea    0x4(%esi),%eax
    152e:	89 8d f8 fe ff ff    	mov    %ecx,-0x108(%ebp)
				if (width < 0) {
    1534:	85 c9                	test   %ecx,%ecx
    1536:	79 10                	jns    1548 <__data_num_words+0xca>
					fminus = true;
					width = -width;
    1538:	f7 9d f8 fe ff ff    	negl   -0x108(%ebp)
					fminus = true;
    153e:	c7 85 e0 fe ff ff 01 	movl   $0x1,-0x120(%ebp)
    1545:	00 00 00 
				}
				c = *format++;
    1548:	8b 8d 04 ff ff ff    	mov    -0xfc(%ebp),%ecx
				width = (int32_t) va_arg(vargs, int32_t);
    154e:	89 c6                	mov    %eax,%esi
				c = *format++;
    1550:	8d 47 02             	lea    0x2(%edi),%eax
    1553:	0f be 19             	movsbl (%ecx),%ebx
    1556:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%ebp)
    155c:	eb 39                	jmp    1597 <__data_num_words+0x119>
	return ((((unsigned)c) >= ' ') && (((unsigned)c) <= '~'));
}

static inline int isdigit(int a)
{
	return (((unsigned)(a)-'0') < 10);
    155e:	8d 43 d0             	lea    -0x30(%ebx),%eax
			} else if (!isdigit(c))
				width = 0;
    1561:	c7 85 f8 fe ff ff 00 	movl   $0x0,-0x108(%ebp)
    1568:	00 00 00 
			} else if (!isdigit(c))
    156b:	83 f8 09             	cmp    $0x9,%eax
    156e:	77 3d                	ja     15ad <__data_num_words+0x12f>
	while (isdigit(((int) *p)))
    1570:	0f be 1f             	movsbl (%edi),%ebx
    1573:	8d 7f 01             	lea    0x1(%edi),%edi
    1576:	8d 43 d0             	lea    -0x30(%ebx),%eax
    1579:	83 f8 09             	cmp    $0x9,%eax
    157c:	77 13                	ja     1591 <__data_num_words+0x113>
		i = 10 * i + *p++ - '0';
    157e:	6b 85 f8 fe ff ff 0a 	imul   $0xa,-0x108(%ebp),%eax
    1585:	8d 44 03 d0          	lea    -0x30(%ebx,%eax,1),%eax
    1589:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
    158f:	eb df                	jmp    1570 <__data_num_words+0xf2>
			else {
				width = _atoi(&format);	/* Find width */
				c = *format++;
    1591:	89 bd 04 ff ff ff    	mov    %edi,-0xfc(%ebp)
			 * If <width> is INT_MIN, then its absolute value can
			 * not be expressed as a positive number using 32-bit
			 * two's complement.  To cover that case, cast it to
			 * an unsigned before comparing it against MAXFLD.
			 */
			if ((unsigned) width > MAXFLD) {
    1597:	81 bd f8 fe ff ff c8 	cmpl   $0xc8,-0x108(%ebp)
    159e:	00 00 00 
    15a1:	76 0a                	jbe    15ad <__data_num_words+0x12f>
				width = MAXFLD;
    15a3:	c7 85 f8 fe ff ff c8 	movl   $0xc8,-0x108(%ebp)
    15aa:	00 00 00 
			precision = -1;	/* No precision specified   */
    15ad:	c7 85 0c ff ff ff ff 	movl   $0xffffffff,-0xf4(%ebp)
    15b4:	ff ff ff 
			}

			if (c == '.') {
    15b7:	83 fb 2e             	cmp    $0x2e,%ebx
    15ba:	75 6c                	jne    1628 <__data_num_words+0x1aa>
				c = *format++;
				if (c == '*') {
    15bc:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
    15c2:	80 38 2a             	cmpb   $0x2a,(%eax)
    15c5:	74 0c                	je     15d3 <__data_num_words+0x155>
    15c7:	c7 85 0c ff ff ff 00 	movl   $0x0,-0xf4(%ebp)
    15ce:	00 00 00 
    15d1:	eb 14                	jmp    15e7 <__data_num_words+0x169>
					precision = (int32_t)
    15d3:	8b 0e                	mov    (%esi),%ecx
				c = *format++;
    15d5:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
    15db:	40                   	inc    %eax
					precision = (int32_t)
    15dc:	89 8d 0c ff ff ff    	mov    %ecx,-0xf4(%ebp)
    15e2:	83 c6 04             	add    $0x4,%esi
    15e5:	eb 1f                	jmp    1606 <__data_num_words+0x188>
	while (isdigit(((int) *p)))
    15e7:	0f be 10             	movsbl (%eax),%edx
    15ea:	8d 4a d0             	lea    -0x30(%edx),%ecx
    15ed:	83 f9 09             	cmp    $0x9,%ecx
    15f0:	77 14                	ja     1606 <__data_num_words+0x188>
		i = 10 * i + *p++ - '0';
    15f2:	6b 8d 0c ff ff ff 0a 	imul   $0xa,-0xf4(%ebp),%ecx
    15f9:	40                   	inc    %eax
    15fa:	8d 4c 0a d0          	lea    -0x30(%edx,%ecx,1),%ecx
    15fe:	89 8d 0c ff ff ff    	mov    %ecx,-0xf4(%ebp)
    1604:	eb e1                	jmp    15e7 <__data_num_words+0x169>
					va_arg(vargs, int32_t);
				} else
					precision = _atoi(&format);

				if (precision > MAXFLD)
    1606:	81 bd 0c ff ff ff c8 	cmpl   $0xc8,-0xf4(%ebp)
    160d:	00 00 00 
    1610:	7e 0a                	jle    161c <__data_num_words+0x19e>
					precision = -1;
    1612:	c7 85 0c ff ff ff ff 	movl   $0xffffffff,-0xf4(%ebp)
    1619:	ff ff ff 
				c = *format++;
    161c:	8d 48 01             	lea    0x1(%eax),%ecx
    161f:	0f be 18             	movsbl (%eax),%ebx
    1622:	89 8d 04 ff ff ff    	mov    %ecx,-0xfc(%ebp)
			 *    L: long double
			 *    z: size_t or ssize_t
			 * No further special processing is done for them.
			 */

			if (strchr("hlLz", c) != NULL) {
    1628:	53                   	push   %ebx
    1629:	68 41 75 00 00       	push   $0x7541
    162e:	e8 d0 09 00 00       	call   2003 <strchr>
    1633:	59                   	pop    %ecx
    1634:	85 c0                	test   %eax,%eax
    1636:	5f                   	pop    %edi
    1637:	0f 84 b4 00 00 00    	je     16f1 <__data_num_words+0x273>
				i = c;
				c = *format++;
    163d:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
    1643:	40                   	inc    %eax
    1644:	0f be 58 ff          	movsbl -0x1(%eax),%ebx
    1648:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%ebp)
    164e:	e9 9e 00 00 00       	jmp    16f1 <__data_num_words+0x273>
				 */
			}

			need_justifying = false;
			prefix = 0;
			switch (c) {
    1653:	0f 8e 5e 08 00 00    	jle    1eb7 <__data_num_words+0xa39>
				int32ptr_temp = (int32_t *)va_arg(vargs, int32_t *);
				*int32ptr_temp = count;
				break;

			case 'o':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
    1659:	8d 46 04             	lea    0x4(%esi),%eax
    165c:	8b 16                	mov    (%esi),%edx
    165e:	89 85 fc fe ff ff    	mov    %eax,-0x104(%ebp)
	if (alt_form) {
    1664:	83 bd 08 ff ff ff 00 	cmpl   $0x0,-0xf8(%ebp)
    166b:	0f 84 f9 07 00 00    	je     1e6a <__data_num_words+0x9ec>
		*buf++ = '0';
    1671:	c6 85 27 ff ff ff 30 	movb   $0x30,-0xd9(%ebp)
    1678:	8d 85 28 ff ff ff    	lea    -0xd8(%ebp),%eax
		if (!value) {
    167e:	85 d2                	test   %edx,%edx
    1680:	0f 85 ea 07 00 00    	jne    1e70 <__data_num_words+0x9f2>
			prefix = 0;
    1686:	31 db                	xor    %ebx,%ebx
			*buf++ = 0;
    1688:	c6 85 28 ff ff ff 00 	movb   $0x0,-0xd8(%ebp)
				c = _to_octal(buf, uint32_temp, falt, precision);
				need_justifying = true;
				if (precision != -1)
    168f:	83 bd 0c ff ff ff ff 	cmpl   $0xffffffff,-0xf4(%ebp)
    1696:	74 07                	je     169f <__data_num_words+0x221>
					pad = ' ';
    1698:	c6 85 f3 fe ff ff 20 	movb   $0x20,-0x10d(%ebp)

			if (c >= MAXFLD + 1)
				return EOF;

			if (need_justifying) {
				if (c < width) {
    169f:	8b 8d 08 ff ff ff    	mov    -0xf8(%ebp),%ecx
    16a5:	39 8d f8 fe ff ff    	cmp    %ecx,-0x108(%ebp)
    16ab:	0f 8f 9c 05 00 00    	jg     1c4d <__data_num_words+0x7cf>
					} else {
						/* Right justify */
						(void) memmove((buf + (width - c)), buf, (size_t) (c
										+ 1));
						if (pad == ' ')
							prefix = 0;
    16b1:	8d b5 27 ff ff ff    	lea    -0xd9(%ebp),%esi
    16b7:	8b 9d ec fe ff ff    	mov    -0x114(%ebp),%ebx
    16bd:	29 f3                	sub    %esi,%ebx
    16bf:	8b 95 08 ff ff ff    	mov    -0xf8(%ebp),%edx
    16c5:	8d bd 27 ff ff ff    	lea    -0xd9(%ebp),%edi
    16cb:	29 f2                	sub    %esi,%edx
    16cd:	8d 04 1e             	lea    (%esi,%ebx,1),%eax
    16d0:	01 fa                	add    %edi,%edx
							buf[i] = pad;
					}
					c = width;
				}

				for (cptr = buf; c > 0; c--, cptr++, count++) {
    16d2:	85 d2                	test   %edx,%edx
    16d4:	0f 8f fc 05 00 00    	jg     1cd6 <__data_num_words+0x858>
			switch (c) {
    16da:	8b b5 fc fe ff ff    	mov    -0x104(%ebp),%esi
    16e0:	8b 95 04 ff ff ff    	mov    -0xfc(%ebp),%edx
    16e6:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
    16ec:	e9 25 fd ff ff       	jmp    1416 <_prf+0x38>
    16f1:	83 fb 67             	cmp    $0x67,%ebx
    16f4:	0f 8f 3a 07 00 00    	jg     1e34 <__data_num_words+0x9b6>
    16fa:	83 fb 65             	cmp    $0x65,%ebx
    16fd:	0f 8c f4 05 00 00    	jl     1cf7 <__data_num_words+0x879>
				u.d = (double) va_arg(vargs, double);
    1703:	8d 46 08             	lea    0x8(%esi),%eax
				double_temp = u.i;
    1706:	8b 56 04             	mov    0x4(%esi),%edx
				u.d = (double) va_arg(vargs, double);
    1709:	89 85 fc fe ff ff    	mov    %eax,-0x104(%ebp)
				double_temp = u.i;
    170f:	8b 06                	mov    (%esi),%eax
	fract = (double_temp << 11) & ~HIGHBIT64;
    1711:	89 c6                	mov    %eax,%esi
	exp = double_temp >> 52 & 0x7ff;
    1713:	89 d1                	mov    %edx,%ecx
    1715:	c1 e9 14             	shr    $0x14,%ecx
	fract = (double_temp << 11) & ~HIGHBIT64;
    1718:	89 d7                	mov    %edx,%edi
    171a:	0f a4 f7 0b          	shld   $0xb,%esi,%edi
    171e:	81 e7 ff ff ff 7f    	and    $0x7fffffff,%edi
	exp = double_temp >> 52 & 0x7ff;
    1724:	81 e1 ff 07 00 00    	and    $0x7ff,%ecx
	fract = (double_temp << 11) & ~HIGHBIT64;
    172a:	c1 e6 0b             	shl    $0xb,%esi
    172d:	89 bd 18 ff ff ff    	mov    %edi,-0xe8(%ebp)
    1733:	89 f0                	mov    %esi,%eax
    1735:	89 b5 14 ff ff ff    	mov    %esi,-0xec(%ebp)
	if (exp == 0x7ff) {
    173b:	81 f9 ff 07 00 00    	cmp    $0x7ff,%ecx
    1741:	75 53                	jne    1796 <__data_num_words+0x318>
		if (!fract) {
    1743:	09 c7                	or     %eax,%edi
    1745:	75 2c                	jne    1773 <__data_num_words+0x2f5>
			*buf++ = sign ? '-' : '+';
    1747:	c1 fa 1f             	sar    $0x1f,%edx
			*buf++ = 'I';
    174a:	c6 85 28 ff ff ff 49 	movb   $0x49,-0xd8(%ebp)
			*buf++ = sign ? '-' : '+';
    1751:	83 e2 02             	and    $0x2,%edx
			*buf++ = 'N';
    1754:	c6 85 29 ff ff ff 4e 	movb   $0x4e,-0xd7(%ebp)
			*buf++ = sign ? '-' : '+';
    175b:	83 c2 2b             	add    $0x2b,%edx
			*buf++ = 'F';
    175e:	c6 85 2a ff ff ff 46 	movb   $0x46,-0xd6(%ebp)
			*buf++ = sign ? '-' : '+';
    1765:	88 95 27 ff ff ff    	mov    %dl,-0xd9(%ebp)
			*buf++ = 'F';
    176b:	8d 85 2b ff ff ff    	lea    -0xd5(%ebp),%eax
    1771:	eb 1b                	jmp    178e <__data_num_words+0x310>
			*buf++ = 'N';
    1773:	c6 85 27 ff ff ff 4e 	movb   $0x4e,-0xd9(%ebp)
			*buf++ = 'a';
    177a:	c6 85 28 ff ff ff 61 	movb   $0x61,-0xd8(%ebp)
			*buf++ = 'N';
    1781:	c6 85 29 ff ff ff 4e 	movb   $0x4e,-0xd7(%ebp)
    1788:	8d 85 2a ff ff ff    	lea    -0xd6(%ebp),%eax
		*buf = 0;
    178e:	c6 00 00             	movb   $0x0,(%eax)
    1791:	e9 04 04 00 00       	jmp    1b9a <__data_num_words+0x71c>
	if ((exp | fract) != 0) {
    1796:	89 ce                	mov    %ecx,%esi
    1798:	09 c6                	or     %eax,%esi
    179a:	09 fe                	or     %edi,%esi
    179c:	74 1f                	je     17bd <__data_num_words+0x33f>
		fract |= HIGHBIT64;
    179e:	81 cf 00 00 00 80    	or     $0x80000000,%edi
    17a4:	89 85 14 ff ff ff    	mov    %eax,-0xec(%ebp)
		exp -= (1023 - 1);	/* +1 since .1 vs 1. */
    17aa:	8d b1 02 fc ff ff    	lea    -0x3fe(%ecx),%esi
		fract |= HIGHBIT64;
    17b0:	89 bd 18 ff ff ff    	mov    %edi,-0xe8(%ebp)
		decexp = true;		/* Wasn't zero */
    17b6:	b8 01 00 00 00       	mov    $0x1,%eax
    17bb:	eb 04                	jmp    17c1 <__data_num_words+0x343>
	if ((exp | fract) != 0) {
    17bd:	31 f6                	xor    %esi,%esi
		decexp = false;		/* It was zero */
    17bf:	31 c0                	xor    %eax,%eax
	if (decexp && sign) {
    17c1:	c1 ea 1f             	shr    $0x1f,%edx
    17c4:	74 0d                	je     17d3 <__data_num_words+0x355>
    17c6:	85 c0                	test   %eax,%eax
    17c8:	74 09                	je     17d3 <__data_num_words+0x355>
		*buf++ = '-';
    17ca:	c6 85 27 ff ff ff 2d 	movb   $0x2d,-0xd9(%ebp)
    17d1:	eb 2e                	jmp    1801 <__data_num_words+0x383>
	} else if (fplus) {
    17d3:	83 bd e8 fe ff ff 00 	cmpl   $0x0,-0x118(%ebp)
    17da:	74 09                	je     17e5 <__data_num_words+0x367>
		*buf++ = '+';
    17dc:	c6 85 27 ff ff ff 2b 	movb   $0x2b,-0xd9(%ebp)
    17e3:	eb 1c                	jmp    1801 <__data_num_words+0x383>
	} else if (fspace) {
    17e5:	8d 85 27 ff ff ff    	lea    -0xd9(%ebp),%eax
    17eb:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
    17f1:	83 bd e4 fe ff ff 00 	cmpl   $0x0,-0x11c(%ebp)
    17f8:	74 13                	je     180d <__data_num_words+0x38f>
		*buf++ = ' ';
    17fa:	c6 85 27 ff ff ff 20 	movb   $0x20,-0xd9(%ebp)
    1801:	8d 85 28 ff ff ff    	lea    -0xd8(%ebp),%eax
    1807:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
	decexp = 0;
    180d:	c7 85 00 ff ff ff 00 	movl   $0x0,-0x100(%ebp)
    1814:	00 00 00 
	while (exp <= -3) {
    1817:	83 fe fe             	cmp    $0xfffffffe,%esi
    181a:	7d 76                	jge    1892 <__data_num_words+0x414>
		while ((fract >> 32) >= (MAXFP1 / 5)) {
    181c:	8b 8d 18 ff ff ff    	mov    -0xe8(%ebp),%ecx
    1822:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
    1828:	81 f9 32 33 33 33    	cmp    $0x33333332,%ecx
    182e:	76 0e                	jbe    183e <__data_num_words+0x3c0>
			_rlrshift(&fract);
    1830:	8d 85 14 ff ff ff    	lea    -0xec(%ebp),%eax
			exp++;
    1836:	46                   	inc    %esi
			_rlrshift(&fract);
    1837:	e8 a3 fa ff ff       	call   12df <_rlrshift>
    183c:	eb de                	jmp    181c <__data_num_words+0x39e>
		fract *= 5;
    183e:	ba 05 00 00 00       	mov    $0x5,%edx
    1843:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
    1846:	f7 e2                	mul    %edx
		decexp--;
    1848:	ff 8d 00 ff ff ff    	decl   -0x100(%ebp)
		fract *= 5;
    184e:	01 ca                	add    %ecx,%edx
    1850:	89 85 14 ff ff ff    	mov    %eax,-0xec(%ebp)
    1856:	89 95 18 ff ff ff    	mov    %edx,-0xe8(%ebp)
		exp++;
    185c:	46                   	inc    %esi
		decexp--;
    185d:	31 c9                	xor    %ecx,%ecx
		while ((fract >> 32) <= (MAXFP1 / 2)) {
    185f:	81 fa ff ff ff 7f    	cmp    $0x7fffffff,%edx
    1865:	77 09                	ja     1870 <__data_num_words+0x3f2>
			fract <<= 1;
    1867:	01 c0                	add    %eax,%eax
    1869:	b1 01                	mov    $0x1,%cl
    186b:	11 d2                	adc    %edx,%edx
			exp--;
    186d:	4e                   	dec    %esi
    186e:	eb ef                	jmp    185f <__data_num_words+0x3e1>
    1870:	84 c9                	test   %cl,%cl
    1872:	74 a3                	je     1817 <__data_num_words+0x399>
    1874:	89 85 14 ff ff ff    	mov    %eax,-0xec(%ebp)
    187a:	89 95 18 ff ff ff    	mov    %edx,-0xe8(%ebp)
    1880:	eb 95                	jmp    1817 <__data_num_words+0x399>
    1882:	84 c9                	test   %cl,%cl
    1884:	74 0c                	je     1892 <__data_num_words+0x414>
    1886:	89 85 14 ff ff ff    	mov    %eax,-0xec(%ebp)
    188c:	89 95 18 ff ff ff    	mov    %edx,-0xe8(%ebp)
	while (exp > 0) {
    1892:	85 f6                	test   %esi,%esi
    1894:	7e 31                	jle    18c7 <__data_num_words+0x449>
		_ldiv5(&fract);
    1896:	8d 85 14 ff ff ff    	lea    -0xec(%ebp),%eax
		exp--;
    189c:	4e                   	dec    %esi
		_ldiv5(&fract);
    189d:	e8 63 fa ff ff       	call   1305 <_ldiv5>
		decexp++;
    18a2:	ff 85 00 ff ff ff    	incl   -0x100(%ebp)
    18a8:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
    18ae:	8b 95 18 ff ff ff    	mov    -0xe8(%ebp),%edx
    18b4:	31 c9                	xor    %ecx,%ecx
		while ((fract >> 32) <= (MAXFP1 / 2)) {
    18b6:	81 fa ff ff ff 7f    	cmp    $0x7fffffff,%edx
    18bc:	77 c4                	ja     1882 <__data_num_words+0x404>
			fract <<= 1;
    18be:	01 c0                	add    %eax,%eax
    18c0:	b1 01                	mov    $0x1,%cl
    18c2:	11 d2                	adc    %edx,%edx
			exp--;
    18c4:	4e                   	dec    %esi
    18c5:	eb ef                	jmp    18b6 <__data_num_words+0x438>
		_rlrshift(&fract);
    18c7:	8d 85 14 ff ff ff    	lea    -0xec(%ebp),%eax
		exp++;
    18cd:	46                   	inc    %esi
		_rlrshift(&fract);
    18ce:	e8 0c fa ff ff       	call   12df <_rlrshift>
	while (exp < (0 + 4)) {
    18d3:	83 fe 04             	cmp    $0x4,%esi
    18d6:	75 ef                	jne    18c7 <__data_num_words+0x449>
	if (precision < 0)
    18d8:	83 bd 0c ff ff ff 00 	cmpl   $0x0,-0xf4(%ebp)
    18df:	79 0a                	jns    18eb <__data_num_words+0x46d>
		precision = 6;		/* Default precision if none given */
    18e1:	c7 85 0c ff ff ff 06 	movl   $0x6,-0xf4(%ebp)
    18e8:	00 00 00 
	if ((c == 'g') || (c == 'G')) {
    18eb:	89 d8                	mov    %ebx,%eax
    18ed:	83 e0 df             	and    $0xffffffdf,%eax
    18f0:	83 f8 47             	cmp    $0x47,%eax
    18f3:	75 47                	jne    193c <__data_num_words+0x4be>
		if (!falt && (precision > 0))
    18f5:	31 d2                	xor    %edx,%edx
    18f7:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
    18fd:	83 f0 01             	xor    $0x1,%eax
    1900:	83 bd 0c ff ff ff 00 	cmpl   $0x0,-0xf4(%ebp)
    1907:	0f 9f c2             	setg   %dl
	prune_zero = false;		/* Assume trailing 0's allowed     */
    190a:	21 c2                	and    %eax,%edx
    190c:	89 95 dc fe ff ff    	mov    %edx,-0x124(%ebp)
		if ((decexp < (-4 + 1)) || (decexp > (precision + 1))) {
    1912:	83 bd 00 ff ff ff fd 	cmpl   $0xfffffffd,-0x100(%ebp)
    1919:	7c 0f                	jl     192a <__data_num_words+0x4ac>
    191b:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
    1921:	40                   	inc    %eax
    1922:	39 85 00 ff ff ff    	cmp    %eax,-0x100(%ebp)
    1928:	7e 21                	jle    194b <__data_num_words+0x4cd>
				c = 'E';
    192a:	83 fb 67             	cmp    $0x67,%ebx
    192d:	0f 94 c3             	sete   %bl
    1930:	0f b6 db             	movzbl %bl,%ebx
    1933:	4b                   	dec    %ebx
    1934:	83 e3 e0             	and    $0xffffffe0,%ebx
    1937:	83 c3 65             	add    $0x65,%ebx
    193a:	eb 26                	jmp    1962 <__data_num_words+0x4e4>
	prune_zero = false;		/* Assume trailing 0's allowed     */
    193c:	c7 85 dc fe ff ff 00 	movl   $0x0,-0x124(%ebp)
    1943:	00 00 00 
	if (c == 'f') {
    1946:	83 fb 66             	cmp    $0x66,%ebx
    1949:	75 17                	jne    1962 <__data_num_words+0x4e4>
    194b:	8b b5 00 ff ff ff    	mov    -0x100(%ebp),%esi
    1951:	03 b5 0c ff ff ff    	add    -0xf4(%ebp),%esi
    1957:	79 02                	jns    195b <__data_num_words+0x4dd>
    1959:	31 f6                	xor    %esi,%esi
		exp = precision + decexp;
    195b:	bb 66 00 00 00       	mov    $0x66,%ebx
    1960:	eb 09                	jmp    196b <__data_num_words+0x4ed>
		exp = precision + 1;
    1962:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
    1968:	8d 70 01             	lea    0x1(%eax),%esi
	digit_count = 16;
    196b:	c7 85 10 ff ff ff 10 	movl   $0x10,-0xf0(%ebp)
    1972:	00 00 00 
	ltemp = 0x0800000000000000;
    1975:	c7 85 1c ff ff ff 00 	movl   $0x0,-0xe4(%ebp)
    197c:	00 00 00 
    197f:	c7 85 20 ff ff ff 00 	movl   $0x8000000,-0xe0(%ebp)
    1986:	00 00 08 
    1989:	83 fe 10             	cmp    $0x10,%esi
    198c:	7e 05                	jle    1993 <__data_num_words+0x515>
    198e:	be 10 00 00 00       	mov    $0x10,%esi
	while (exp--) {
    1993:	85 f6                	test   %esi,%esi
    1995:	74 19                	je     19b0 <__data_num_words+0x532>
		_ldiv5(&ltemp);
    1997:	8d 85 1c ff ff ff    	lea    -0xe4(%ebp),%eax
    199d:	4e                   	dec    %esi
    199e:	e8 62 f9 ff ff       	call   1305 <_ldiv5>
		_rlrshift(&ltemp);
    19a3:	8d 85 1c ff ff ff    	lea    -0xe4(%ebp),%eax
    19a9:	e8 31 f9 ff ff       	call   12df <_rlrshift>
    19ae:	eb e3                	jmp    1993 <__data_num_words+0x515>
	fract += ltemp;
    19b0:	8b 85 1c ff ff ff    	mov    -0xe4(%ebp),%eax
    19b6:	8b 95 20 ff ff ff    	mov    -0xe0(%ebp),%edx
    19bc:	03 85 14 ff ff ff    	add    -0xec(%ebp),%eax
    19c2:	13 95 18 ff ff ff    	adc    -0xe8(%ebp),%edx
    19c8:	89 85 14 ff ff ff    	mov    %eax,-0xec(%ebp)
	if ((fract >> 32) & 0xF0000000) {
    19ce:	89 d0                	mov    %edx,%eax
	fract += ltemp;
    19d0:	89 95 18 ff ff ff    	mov    %edx,-0xe8(%ebp)
	if ((fract >> 32) & 0xF0000000) {
    19d6:	a9 00 00 00 f0       	test   $0xf0000000,%eax
    19db:	74 1c                	je     19f9 <__data_num_words+0x57b>
		_ldiv5(&fract);
    19dd:	8d 85 14 ff ff ff    	lea    -0xec(%ebp),%eax
    19e3:	e8 1d f9 ff ff       	call   1305 <_ldiv5>
		_rlrshift(&fract);
    19e8:	8d 85 14 ff ff ff    	lea    -0xec(%ebp),%eax
    19ee:	e8 ec f8 ff ff       	call   12df <_rlrshift>
		decexp++;
    19f3:	ff 85 00 ff ff ff    	incl   -0x100(%ebp)
	if (c == 'f') {
    19f9:	83 fb 66             	cmp    $0x66,%ebx
    19fc:	0f 85 bb 00 00 00    	jne    1abd <__data_num_words+0x63f>
		if (decexp > 0) {
    1a02:	83 bd 00 ff ff ff 00 	cmpl   $0x0,-0x100(%ebp)
    1a09:	7e 37                	jle    1a42 <__data_num_words+0x5c4>
    1a0b:	8b b5 00 ff ff ff    	mov    -0x100(%ebp),%esi
    1a11:	8b bd f4 fe ff ff    	mov    -0x10c(%ebp),%edi
    1a17:	03 b5 f4 fe ff ff    	add    -0x10c(%ebp),%esi
				*buf++ = _get_digit(&fract, &digit_count);
    1a1d:	8d 95 10 ff ff ff    	lea    -0xf0(%ebp),%edx
    1a23:	8d 85 14 ff ff ff    	lea    -0xec(%ebp),%eax
    1a29:	e8 6b f9 ff ff       	call   1399 <_get_digit>
    1a2e:	47                   	inc    %edi
			while (decexp > 0) {
    1a2f:	39 fe                	cmp    %edi,%esi
				*buf++ = _get_digit(&fract, &digit_count);
    1a31:	88 47 ff             	mov    %al,-0x1(%edi)
			while (decexp > 0) {
    1a34:	75 e7                	jne    1a1d <__data_num_words+0x59f>
    1a36:	c7 85 00 ff ff ff 00 	movl   $0x0,-0x100(%ebp)
    1a3d:	00 00 00 
    1a40:	eb 0c                	jmp    1a4e <__data_num_words+0x5d0>
			*buf++ = '0';
    1a42:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
    1a48:	8d 78 01             	lea    0x1(%eax),%edi
    1a4b:	c6 00 30             	movb   $0x30,(%eax)
		if (falt || (precision > 0))
    1a4e:	83 bd 0c ff ff ff 00 	cmpl   $0x0,-0xf4(%ebp)
    1a55:	7f 0d                	jg     1a64 <__data_num_words+0x5e6>
    1a57:	f6 85 08 ff ff ff 01 	testb  $0x1,-0xf8(%ebp)
    1a5e:	0f 84 f5 04 00 00    	je     1f59 <__data_num_words+0xadb>
			*buf++ = '.';
    1a64:	c6 07 2e             	movb   $0x2e,(%edi)
    1a67:	8d 77 02             	lea    0x2(%edi),%esi
    1a6a:	8b 8d 0c ff ff ff    	mov    -0xf4(%ebp),%ecx
		while (precision-- > 0) {
    1a70:	49                   	dec    %ecx
    1a71:	83 f9 ff             	cmp    $0xffffffff,%ecx
    1a74:	74 38                	je     1aae <__data_num_words+0x630>
			if (decexp < 0) {
    1a76:	83 bd 00 ff ff ff 00 	cmpl   $0x0,-0x100(%ebp)
    1a7d:	74 0c                	je     1a8b <__data_num_words+0x60d>
				*buf++ = '0';
    1a7f:	c6 46 ff 30          	movb   $0x30,-0x1(%esi)
				decexp++;
    1a83:	ff 85 00 ff ff ff    	incl   -0x100(%ebp)
    1a89:	eb 20                	jmp    1aab <__data_num_words+0x62d>
				*buf++ = _get_digit(&fract, &digit_count);
    1a8b:	8d 95 10 ff ff ff    	lea    -0xf0(%ebp),%edx
    1a91:	8d 85 14 ff ff ff    	lea    -0xec(%ebp),%eax
    1a97:	89 8d 08 ff ff ff    	mov    %ecx,-0xf8(%ebp)
    1a9d:	e8 f7 f8 ff ff       	call   1399 <_get_digit>
    1aa2:	8b 8d 08 ff ff ff    	mov    -0xf8(%ebp),%ecx
    1aa8:	88 46 ff             	mov    %al,-0x1(%esi)
    1aab:	46                   	inc    %esi
    1aac:	eb c2                	jmp    1a70 <__data_num_words+0x5f2>
    1aae:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
    1ab4:	8d 7c 07 01          	lea    0x1(%edi,%eax,1),%edi
    1ab8:	e9 9c 04 00 00       	jmp    1f59 <__data_num_words+0xadb>
		*buf = _get_digit(&fract, &digit_count);
    1abd:	8d 95 10 ff ff ff    	lea    -0xf0(%ebp),%edx
    1ac3:	8d 85 14 ff ff ff    	lea    -0xec(%ebp),%eax
    1ac9:	e8 cb f8 ff ff       	call   1399 <_get_digit>
    1ace:	8b bd f4 fe ff ff    	mov    -0x10c(%ebp),%edi
			decexp--;
    1ad4:	3c 30                	cmp    $0x30,%al
		*buf = _get_digit(&fract, &digit_count);
    1ad6:	88 07                	mov    %al,(%edi)
			decexp--;
    1ad8:	0f 95 c0             	setne  %al
    1adb:	0f b6 c0             	movzbl %al,%eax
    1ade:	29 85 00 ff ff ff    	sub    %eax,-0x100(%ebp)
		if (falt || (precision > 0))
    1ae4:	83 bd 0c ff ff ff 00 	cmpl   $0x0,-0xf4(%ebp)
    1aeb:	7f 0a                	jg     1af7 <__data_num_words+0x679>
		if (*buf++ != '0')
    1aed:	47                   	inc    %edi
		if (falt || (precision > 0))
    1aee:	f6 85 08 ff ff ff 01 	testb  $0x1,-0xf8(%ebp)
    1af5:	74 30                	je     1b27 <__data_num_words+0x6a9>
			*buf++ = '.';
    1af7:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
    1afd:	8b b5 0c ff ff ff    	mov    -0xf4(%ebp),%esi
    1b03:	8d 78 02             	lea    0x2(%eax),%edi
    1b06:	c6 40 01 2e          	movb   $0x2e,0x1(%eax)
    1b0a:	01 fe                	add    %edi,%esi
		while (precision-- > 0)
    1b0c:	39 fe                	cmp    %edi,%esi
    1b0e:	74 17                	je     1b27 <__data_num_words+0x6a9>
			*buf++ = _get_digit(&fract, &digit_count);
    1b10:	8d 95 10 ff ff ff    	lea    -0xf0(%ebp),%edx
    1b16:	8d 85 14 ff ff ff    	lea    -0xec(%ebp),%eax
    1b1c:	e8 78 f8 ff ff       	call   1399 <_get_digit>
    1b21:	47                   	inc    %edi
    1b22:	88 47 ff             	mov    %al,-0x1(%edi)
    1b25:	eb e5                	jmp    1b0c <__data_num_words+0x68e>
	if (prune_zero) {
    1b27:	83 bd dc fe ff ff 00 	cmpl   $0x0,-0x124(%ebp)
    1b2e:	74 11                	je     1b41 <__data_num_words+0x6c3>
		while (*--buf == '0')
    1b30:	89 f8                	mov    %edi,%eax
    1b32:	4f                   	dec    %edi
    1b33:	8a 17                	mov    (%edi),%dl
    1b35:	80 fa 30             	cmp    $0x30,%dl
    1b38:	74 f6                	je     1b30 <__data_num_words+0x6b2>
		if (*buf != '.')
    1b3a:	80 fa 2e             	cmp    $0x2e,%dl
    1b3d:	74 02                	je     1b41 <__data_num_words+0x6c3>
    1b3f:	89 c7                	mov    %eax,%edi
	if ((c == 'e') || (c == 'E')) {
    1b41:	89 d8                	mov    %ebx,%eax
    1b43:	83 e0 df             	and    $0xffffffdf,%eax
    1b46:	83 f8 45             	cmp    $0x45,%eax
    1b49:	75 4a                	jne    1b95 <__data_num_words+0x717>
		*buf++ = (char) c;
    1b4b:	88 1f                	mov    %bl,(%edi)
    1b4d:	8d 4f 02             	lea    0x2(%edi),%ecx
		if (decexp < 0) {
    1b50:	83 bd 00 ff ff ff 00 	cmpl   $0x0,-0x100(%ebp)
    1b57:	79 0c                	jns    1b65 <__data_num_words+0x6e7>
			decexp = -decexp;
    1b59:	f7 9d 00 ff ff ff    	negl   -0x100(%ebp)
			*buf++ = '-';
    1b5f:	c6 47 01 2d          	movb   $0x2d,0x1(%edi)
    1b63:	eb 04                	jmp    1b69 <__data_num_words+0x6eb>
			*buf++ = '+';
    1b65:	c6 47 01 2b          	movb   $0x2b,0x1(%edi)
		*buf++ = (char) ((decexp / 100) + '0');
    1b69:	8b 85 00 ff ff ff    	mov    -0x100(%ebp),%eax
    1b6f:	be 64 00 00 00       	mov    $0x64,%esi
    1b74:	99                   	cltd   
    1b75:	f7 fe                	idiv   %esi
    1b77:	83 c0 30             	add    $0x30,%eax
		*buf++ = (char) ((decexp / 10) + '0');
    1b7a:	bb 0a 00 00 00       	mov    $0xa,%ebx
		*buf++ = (char) ((decexp / 100) + '0');
    1b7f:	88 01                	mov    %al,(%ecx)
		*buf++ = (char) ((decexp / 10) + '0');
    1b81:	89 d0                	mov    %edx,%eax
    1b83:	99                   	cltd   
    1b84:	f7 fb                	idiv   %ebx
    1b86:	83 c0 30             	add    $0x30,%eax
		*buf++ = (char) (decexp + '0');
    1b89:	83 c2 30             	add    $0x30,%edx
		*buf++ = (char) ((decexp / 10) + '0');
    1b8c:	88 41 01             	mov    %al,0x1(%ecx)
		*buf++ = (char) (decexp + '0');
    1b8f:	8d 79 03             	lea    0x3(%ecx),%edi
    1b92:	88 51 02             	mov    %dl,0x2(%ecx)
	*buf = 0;
    1b95:	c6 07 00             	movb   $0x0,(%edi)
	return buf - start;
    1b98:	89 f8                	mov    %edi,%eax
    1b9a:	8d 8d 27 ff ff ff    	lea    -0xd9(%ebp),%ecx
				if (fplus || fspace || (buf[0] == '-'))
    1ba0:	8b 9d e8 fe ff ff    	mov    -0x118(%ebp),%ebx
	return buf - start;
    1ba6:	29 c8                	sub    %ecx,%eax
				if (fplus || fspace || (buf[0] == '-'))
    1ba8:	0b 9d e4 fe ff ff    	or     -0x11c(%ebp),%ebx
    1bae:	0f 85 83 00 00 00    	jne    1c37 <__data_num_words+0x7b9>
    1bb4:	31 db                	xor    %ebx,%ebx
    1bb6:	80 bd 27 ff ff ff 2d 	cmpb   $0x2d,-0xd9(%ebp)
    1bbd:	0f 94 c3             	sete   %bl
    1bc0:	eb 75                	jmp    1c37 <__data_num_words+0x7b9>
			switch (c) {
    1bc2:	0f 8e e8 01 00 00    	jle    1db0 <__data_num_words+0x932>
				int32_temp = (int32_t) va_arg(vargs, int32_t);
    1bc8:	8d 46 04             	lea    0x4(%esi),%eax
    1bcb:	8b 1e                	mov    (%esi),%ebx
    1bcd:	89 85 fc fe ff ff    	mov    %eax,-0x104(%ebp)
	if (value < 0) {
    1bd3:	85 db                	test   %ebx,%ebx
    1bd5:	0f 89 9f 01 00 00    	jns    1d7a <__data_num_words+0x8fc>
		*buf++ = '-';
    1bdb:	c6 85 27 ff ff ff 2d 	movb   $0x2d,-0xd9(%ebp)
		if (value != 0x80000000)
    1be2:	ba 00 00 00 80       	mov    $0x80000000,%edx
    1be7:	81 fb 00 00 00 80    	cmp    $0x80000000,%ebx
    1bed:	74 04                	je     1bf3 <__data_num_words+0x775>
			value = -value;
    1bef:	89 da                	mov    %ebx,%edx
    1bf1:	f7 da                	neg    %edx
		*buf++ = ' ';
    1bf3:	8d bd 28 ff ff ff    	lea    -0xd8(%ebp),%edi
	return _to_x(buf, value, 10, precision);
    1bf9:	ff b5 0c ff ff ff    	pushl  -0xf4(%ebp)
    1bff:	b9 0a 00 00 00       	mov    $0xa,%ecx
    1c04:	89 f8                	mov    %edi,%eax
				if (fplus || fspace || (int32_temp < 0))
    1c06:	c1 eb 1f             	shr    $0x1f,%ebx
	return _to_x(buf, value, 10, precision);
    1c09:	e8 76 f6 ff ff       	call   1284 <_to_x>
    1c0e:	5a                   	pop    %edx
			prefix = 0;
    1c0f:	8b 95 e8 fe ff ff    	mov    -0x118(%ebp),%edx
    1c15:	0b 95 e4 fe ff ff    	or     -0x11c(%ebp),%edx
	return (buf + _to_udec(buf, (uint32_t) value, precision)) - start;
    1c1b:	01 f8                	add    %edi,%eax
    1c1d:	8d 8d 27 ff ff ff    	lea    -0xd9(%ebp),%ecx
			prefix = 0;
    1c23:	09 d3                	or     %edx,%ebx
	return (buf + _to_udec(buf, (uint32_t) value, precision)) - start;
    1c25:	29 c8                	sub    %ecx,%eax
				if (precision != -1)
    1c27:	83 bd 0c ff ff ff ff 	cmpl   $0xffffffff,-0xf4(%ebp)
    1c2e:	74 07                	je     1c37 <__data_num_words+0x7b9>
					pad = ' ';
    1c30:	c6 85 f3 fe ff ff 20 	movb   $0x20,-0x10d(%ebp)
			if (c >= MAXFLD + 1)
    1c37:	3d c8 00 00 00       	cmp    $0xc8,%eax
    1c3c:	0f 8f 32 f8 ff ff    	jg     1474 <_prf+0x96>
    1c42:	89 85 08 ff ff ff    	mov    %eax,-0xf8(%ebp)
    1c48:	e9 52 fa ff ff       	jmp    169f <__data_num_words+0x221>
					if (fminus)	{
    1c4d:	83 bd e0 fe ff ff 00 	cmpl   $0x0,-0x120(%ebp)
    1c54:	74 27                	je     1c7d <__data_num_words+0x7ff>
							buf[i] = ' ';
    1c56:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
						for (i = c; i < width; i++)
    1c5c:	ff 85 08 ff ff ff    	incl   -0xf8(%ebp)
    1c62:	8b 9d 08 ff ff ff    	mov    -0xf8(%ebp),%ebx
							buf[i] = ' ';
    1c68:	c6 84 28 27 ff ff ff 	movb   $0x20,-0xd9(%eax,%ebp,1)
    1c6f:	20 
						for (i = c; i < width; i++)
    1c70:	39 9d f8 fe ff ff    	cmp    %ebx,-0x108(%ebp)
    1c76:	75 de                	jne    1c56 <__data_num_words+0x7d8>
    1c78:	e9 34 fa ff ff       	jmp    16b1 <__data_num_words+0x233>
						(void) memmove((buf + (width - c)), buf, (size_t) (c
    1c7d:	8b b5 f8 fe ff ff    	mov    -0x108(%ebp),%esi
										+ 1));
    1c83:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
						(void) memmove((buf + (width - c)), buf, (size_t) (c
    1c89:	2b b5 08 ff ff ff    	sub    -0xf8(%ebp),%esi
										+ 1));
    1c8f:	40                   	inc    %eax
						(void) memmove((buf + (width - c)), buf, (size_t) (c
    1c90:	50                   	push   %eax
    1c91:	8d 85 27 ff ff ff    	lea    -0xd9(%ebp),%eax
    1c97:	50                   	push   %eax
    1c98:	01 f0                	add    %esi,%eax
    1c9a:	50                   	push   %eax
    1c9b:	e8 00 04 00 00       	call   20a0 <memmove>
    1ca0:	83 c4 0c             	add    $0xc,%esp
						if (pad == ' ')
    1ca3:	80 bd f3 fe ff ff 20 	cmpb   $0x20,-0x10d(%ebp)
    1caa:	75 02                	jne    1cae <__data_num_words+0x830>
							prefix = 0;
    1cac:	31 db                	xor    %ebx,%ebx
						c = width - c + prefix;
    1cae:	8d 04 33             	lea    (%ebx,%esi,1),%eax
						for (i = prefix; i < c; i++)
    1cb1:	39 c3                	cmp    %eax,%ebx
    1cb3:	7d 10                	jge    1cc5 <__data_num_words+0x847>
							buf[i] = pad;
    1cb5:	8a 8d f3 fe ff ff    	mov    -0x10d(%ebp),%cl
						for (i = prefix; i < c; i++)
    1cbb:	43                   	inc    %ebx
							buf[i] = pad;
    1cbc:	88 8c 2b 26 ff ff ff 	mov    %cl,-0xda(%ebx,%ebp,1)
    1cc3:	eb ec                	jmp    1cb1 <__data_num_words+0x833>
    1cc5:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
    1ccb:	89 85 08 ff ff ff    	mov    %eax,-0xf8(%ebp)
    1cd1:	e9 db f9 ff ff       	jmp    16b1 <__data_num_words+0x233>
					if ((*func)(*cptr, dest) == EOF)
    1cd6:	ff b5 d4 fe ff ff    	pushl  -0x12c(%ebp)
    1cdc:	0f be 06             	movsbl (%esi),%eax
    1cdf:	50                   	push   %eax
    1ce0:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
    1ce6:	ff d0                	call   *%eax
    1ce8:	5a                   	pop    %edx
    1ce9:	40                   	inc    %eax
    1cea:	59                   	pop    %ecx
    1ceb:	0f 84 83 f7 ff ff    	je     1474 <_prf+0x96>
				for (cptr = buf; c > 0; c--, cptr++, count++) {
    1cf1:	46                   	inc    %esi
    1cf2:	e9 c8 f9 ff ff       	jmp    16bf <__data_num_words+0x241>
			switch (c) {
    1cf7:	83 fb 47             	cmp    $0x47,%ebx
    1cfa:	0f 84 03 fa ff ff    	je     1703 <__data_num_words+0x285>
    1d00:	7f 48                	jg     1d4a <__data_num_words+0x8cc>
    1d02:	83 fb 25             	cmp    $0x25,%ebx
    1d05:	75 21                	jne    1d28 <__data_num_words+0x8aa>
				if ((*func)('%', dest) == EOF) {
    1d07:	ff b5 d4 fe ff ff    	pushl  -0x12c(%ebp)
    1d0d:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
    1d13:	6a 25                	push   $0x25
    1d15:	ff d0                	call   *%eax
    1d17:	5b                   	pop    %ebx
    1d18:	40                   	inc    %eax
    1d19:	5f                   	pop    %edi
    1d1a:	0f 84 54 f7 ff ff    	je     1474 <_prf+0x96>
				count++;
    1d20:	ff 85 ec fe ff ff    	incl   -0x114(%ebp)
    1d26:	eb 11                	jmp    1d39 <__data_num_words+0x8bb>
			switch (c) {
    1d28:	83 fb 45             	cmp    $0x45,%ebx
    1d2b:	0f 84 d2 f9 ff ff    	je     1703 <__data_num_words+0x285>
    1d31:	85 db                	test   %ebx,%ebx
    1d33:	0f 84 45 02 00 00    	je     1f7e <__data_num_words+0xb00>
    1d39:	89 b5 fc fe ff ff    	mov    %esi,-0x104(%ebp)
    1d3f:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
    1d45:	e9 90 f9 ff ff       	jmp    16da <__data_num_words+0x25c>
    1d4a:	83 fb 63             	cmp    $0x63,%ebx
    1d4d:	0f 85 6f fe ff ff    	jne    1bc2 <__data_num_words+0x744>
				buf[0] = (char) ((int32_t) va_arg(vargs, int32_t));
    1d53:	8d 46 04             	lea    0x4(%esi),%eax
				buf[1] = '\0';
    1d56:	c6 85 28 ff ff ff 00 	movb   $0x0,-0xd8(%ebp)
				buf[0] = (char) ((int32_t) va_arg(vargs, int32_t));
    1d5d:	89 85 fc fe ff ff    	mov    %eax,-0x104(%ebp)
    1d63:	8b 06                	mov    (%esi),%eax
    1d65:	88 85 27 ff ff ff    	mov    %al,-0xd9(%ebp)
				c = 1;
    1d6b:	c7 85 0c ff ff ff 01 	movl   $0x1,-0xf4(%ebp)
    1d72:	00 00 00 
				break;
    1d75:	e9 f1 01 00 00       	jmp    1f6b <__data_num_words+0xaed>
	} else if (fplus)
    1d7a:	83 bd e8 fe ff ff 00 	cmpl   $0x0,-0x118(%ebp)
    1d81:	74 09                	je     1d8c <__data_num_words+0x90e>
		*buf++ = '+';
    1d83:	c6 85 27 ff ff ff 2b 	movb   $0x2b,-0xd9(%ebp)
    1d8a:	eb 10                	jmp    1d9c <__data_num_words+0x91e>
	else if (fspace)
    1d8c:	83 bd e4 fe ff ff 00 	cmpl   $0x0,-0x11c(%ebp)
    1d93:	74 0e                	je     1da3 <__data_num_words+0x925>
		*buf++ = ' ';
    1d95:	c6 85 27 ff ff ff 20 	movb   $0x20,-0xd9(%ebp)
    1d9c:	89 da                	mov    %ebx,%edx
    1d9e:	e9 50 fe ff ff       	jmp    1bf3 <__data_num_words+0x775>
	else if (fspace)
    1da3:	89 da                	mov    %ebx,%edx
    1da5:	8d bd 27 ff ff ff    	lea    -0xd9(%ebp),%edi
    1dab:	e9 49 fe ff ff       	jmp    1bf9 <__data_num_words+0x77b>
			switch (c) {
    1db0:	83 fb 58             	cmp    $0x58,%ebx
    1db3:	75 84                	jne    1d39 <__data_num_words+0x8bb>
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
    1db5:	8d 46 04             	lea    0x4(%esi),%eax
    1db8:	8b 16                	mov    (%esi),%edx
    1dba:	89 85 fc fe ff ff    	mov    %eax,-0x104(%ebp)
	if (alt_form) {
    1dc0:	8d bd 27 ff ff ff    	lea    -0xd9(%ebp),%edi
    1dc6:	83 bd 08 ff ff ff 00 	cmpl   $0x0,-0xf8(%ebp)
    1dcd:	74 14                	je     1de3 <__data_num_words+0x965>
		*buf++ = '0';
    1dcf:	c6 85 27 ff ff ff 30 	movb   $0x30,-0xd9(%ebp)
		*buf++ = 'x';
    1dd6:	c6 85 28 ff ff ff 78 	movb   $0x78,-0xd8(%ebp)
    1ddd:	8d bd 29 ff ff ff    	lea    -0xd7(%ebp),%edi
	len = _to_x(buf, value, 16, precision);
    1de3:	ff b5 0c ff ff ff    	pushl  -0xf4(%ebp)
    1de9:	b9 10 00 00 00       	mov    $0x10,%ecx
    1dee:	89 f8                	mov    %edi,%eax
    1df0:	e8 8f f4 ff ff       	call   1284 <_to_x>
    1df5:	5a                   	pop    %edx
	if (prefix == 'X') {
    1df6:	8d 8d 27 ff ff ff    	lea    -0xd9(%ebp),%ecx
    1dfc:	83 fb 58             	cmp    $0x58,%ebx
    1dff:	74 2b                	je     1e2c <__data_num_words+0x9ae>
	return len + (buf - buf0);
    1e01:	8d 8d 27 ff ff ff    	lea    -0xd9(%ebp),%ecx
					prefix = 2;
    1e07:	31 db                	xor    %ebx,%ebx
	return len + (buf - buf0);
    1e09:	29 cf                	sub    %ecx,%edi
    1e0b:	01 f8                	add    %edi,%eax
					prefix = 2;
    1e0d:	83 bd 08 ff ff ff 00 	cmpl   $0x0,-0xf8(%ebp)
    1e14:	0f 95 c3             	setne  %bl
    1e17:	01 db                	add    %ebx,%ebx
    1e19:	e9 09 fe ff ff       	jmp    1c27 <__data_num_words+0x7a9>
		if (*buf >= 'a' && *buf <= 'z') {
    1e1e:	8d 5a 9f             	lea    -0x61(%edx),%ebx
    1e21:	80 fb 19             	cmp    $0x19,%bl
    1e24:	77 05                	ja     1e2b <__data_num_words+0x9ad>
			*buf += 'A' - 'a';
    1e26:	83 ea 20             	sub    $0x20,%edx
    1e29:	88 11                	mov    %dl,(%ecx)
	for (/**/; *buf; buf++) {
    1e2b:	41                   	inc    %ecx
    1e2c:	8a 11                	mov    (%ecx),%dl
    1e2e:	84 d2                	test   %dl,%dl
    1e30:	75 ec                	jne    1e1e <__data_num_words+0x9a0>
    1e32:	eb cd                	jmp    1e01 <__data_num_words+0x983>
			switch (c) {
    1e34:	83 fb 70             	cmp    $0x70,%ebx
    1e37:	75 5b                	jne    1e94 <__data_num_words+0xa16>
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
    1e39:	8d 46 04             	lea    0x4(%esi),%eax
    1e3c:	8b 16                	mov    (%esi),%edx
    1e3e:	89 85 fc fe ff ff    	mov    %eax,-0x104(%ebp)
	len = _to_x(buf, value, 16, precision);
    1e44:	b9 10 00 00 00       	mov    $0x10,%ecx
    1e49:	8d 85 29 ff ff ff    	lea    -0xd7(%ebp),%eax
    1e4f:	6a 08                	push   $0x8
		*buf++ = '0';
    1e51:	c6 85 27 ff ff ff 30 	movb   $0x30,-0xd9(%ebp)
		*buf++ = 'x';
    1e58:	c6 85 28 ff ff ff 78 	movb   $0x78,-0xd8(%ebp)
	len = _to_x(buf, value, 16, precision);
    1e5f:	e8 20 f4 ff ff       	call   1284 <_to_x>
    1e64:	5b                   	pop    %ebx
	return len + (buf - buf0);
    1e65:	83 c0 02             	add    $0x2,%eax
    1e68:	eb 23                	jmp    1e8d <__data_num_words+0xa0f>
	if (alt_form) {
    1e6a:	8d 85 27 ff ff ff    	lea    -0xd9(%ebp),%eax
	return (buf - buf0) + _to_x(buf, value, 8, precision);
    1e70:	ff b5 0c ff ff ff    	pushl  -0xf4(%ebp)
    1e76:	89 c3                	mov    %eax,%ebx
    1e78:	8d 8d 27 ff ff ff    	lea    -0xd9(%ebp),%ecx
    1e7e:	29 cb                	sub    %ecx,%ebx
    1e80:	b9 08 00 00 00       	mov    $0x8,%ecx
    1e85:	e8 fa f3 ff ff       	call   1284 <_to_x>
    1e8a:	5e                   	pop    %esi
    1e8b:	01 d8                	add    %ebx,%eax
			prefix = 0;
    1e8d:	31 db                	xor    %ebx,%ebx
    1e8f:	e9 93 fd ff ff       	jmp    1c27 <__data_num_words+0x7a9>
			switch (c) {
    1e94:	7f 2f                	jg     1ec5 <__data_num_words+0xa47>
    1e96:	83 fb 6e             	cmp    $0x6e,%ebx
    1e99:	0f 85 b4 f7 ff ff    	jne    1653 <__data_num_words+0x1d5>
				int32ptr_temp = (int32_t *)va_arg(vargs, int32_t *);
    1e9f:	8d 46 04             	lea    0x4(%esi),%eax
				*int32ptr_temp = count;
    1ea2:	8b 9d ec fe ff ff    	mov    -0x114(%ebp),%ebx
				int32ptr_temp = (int32_t *)va_arg(vargs, int32_t *);
    1ea8:	89 85 fc fe ff ff    	mov    %eax,-0x104(%ebp)
				*int32ptr_temp = count;
    1eae:	8b 06                	mov    (%esi),%eax
    1eb0:	89 18                	mov    %ebx,(%eax)
				break;
    1eb2:	e9 88 fe ff ff       	jmp    1d3f <__data_num_words+0x8c1>
			switch (c) {
    1eb7:	83 fb 69             	cmp    $0x69,%ebx
    1eba:	0f 84 08 fd ff ff    	je     1bc8 <__data_num_words+0x74a>
    1ec0:	e9 74 fe ff ff       	jmp    1d39 <__data_num_words+0x8bb>
    1ec5:	83 fb 75             	cmp    $0x75,%ebx
    1ec8:	75 24                	jne    1eee <__data_num_words+0xa70>
	return _to_x(buf, value, 10, precision);
    1eca:	ff b5 0c ff ff ff    	pushl  -0xf4(%ebp)
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
    1ed0:	8d 46 04             	lea    0x4(%esi),%eax
	return _to_x(buf, value, 10, precision);
    1ed3:	b9 0a 00 00 00       	mov    $0xa,%ecx
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
    1ed8:	89 85 fc fe ff ff    	mov    %eax,-0x104(%ebp)
	return _to_x(buf, value, 10, precision);
    1ede:	8b 16                	mov    (%esi),%edx
    1ee0:	8d 85 27 ff ff ff    	lea    -0xd9(%ebp),%eax
    1ee6:	e8 99 f3 ff ff       	call   1284 <_to_x>
    1eeb:	59                   	pop    %ecx
    1eec:	eb 9f                	jmp    1e8d <__data_num_words+0xa0f>
			switch (c) {
    1eee:	83 fb 78             	cmp    $0x78,%ebx
    1ef1:	0f 84 be fe ff ff    	je     1db5 <__data_num_words+0x937>
    1ef7:	83 fb 73             	cmp    $0x73,%ebx
    1efa:	0f 85 39 fe ff ff    	jne    1d39 <__data_num_words+0x8bb>
				cptr_temp = (char *) va_arg(vargs, char *);
    1f00:	8d 46 04             	lea    0x4(%esi),%eax
    1f03:	8b 16                	mov    (%esi),%edx
    1f05:	89 85 fc fe ff ff    	mov    %eax,-0x104(%ebp)
				for (c = 0; c < MAXFLD; c++) {
    1f0b:	31 c0                	xor    %eax,%eax
					if (cptr_temp[c] == '\0') {
    1f0d:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
    1f11:	74 08                	je     1f1b <__data_num_words+0xa9d>
				for (c = 0; c < MAXFLD; c++) {
    1f13:	40                   	inc    %eax
    1f14:	3d c8 00 00 00       	cmp    $0xc8,%eax
    1f19:	75 f2                	jne    1f0d <__data_num_words+0xa8f>
				if ((precision >= 0) && (precision < c))
    1f1b:	8b 9d 0c ff ff ff    	mov    -0xf4(%ebp),%ebx
    1f21:	83 eb 00             	sub    $0x0,%ebx
    1f24:	78 08                	js     1f2e <__data_num_words+0xab0>
    1f26:	39 85 0c ff ff ff    	cmp    %eax,-0xf4(%ebp)
    1f2c:	7c 06                	jl     1f34 <__data_num_words+0xab6>
    1f2e:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%ebp)
				if (c > 0) {
    1f34:	83 bd 0c ff ff ff 00 	cmpl   $0x0,-0xf4(%ebp)
    1f3b:	0f 84 fe fd ff ff    	je     1d3f <__data_num_words+0x8c1>
					memcpy(buf, cptr_temp, (size_t) c);
    1f41:	ff b5 0c ff ff ff    	pushl  -0xf4(%ebp)
    1f47:	8d 85 27 ff ff ff    	lea    -0xd9(%ebp),%eax
    1f4d:	52                   	push   %edx
    1f4e:	50                   	push   %eax
    1f4f:	e8 84 01 00 00       	call   20d8 <memcpy>
    1f54:	83 c4 0c             	add    $0xc,%esp
    1f57:	eb 12                	jmp    1f6b <__data_num_words+0xaed>
	if (prune_zero) {
    1f59:	83 bd dc fe ff ff 00 	cmpl   $0x0,-0x124(%ebp)
    1f60:	0f 85 ca fb ff ff    	jne    1b30 <__data_num_words+0x6b2>
    1f66:	e9 2a fc ff ff       	jmp    1b95 <__data_num_words+0x717>
					prefix = 2;
    1f6b:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
    1f71:	31 db                	xor    %ebx,%ebx
    1f73:	89 85 08 ff ff ff    	mov    %eax,-0xf8(%ebp)
    1f79:	e9 21 f7 ff ff       	jmp    169f <__data_num_words+0x221>
				}
			}
		}
	}
	return count;
}
    1f7e:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
    1f84:	8d 65 f0             	lea    -0x10(%ebp),%esp
    1f87:	59                   	pop    %ecx
    1f88:	5b                   	pop    %ebx
    1f89:	5e                   	pop    %esi
    1f8a:	5f                   	pop    %edi
    1f8b:	5d                   	pop    %ebp
    1f8c:	8d 61 fc             	lea    -0x4(%ecx),%esp
    1f8f:	c3                   	ret    

00001f90 <sprintf_out>:
	char *ptr;
	int len;
};

static int sprintf_out(int c, struct emitter *p)
{
    1f90:	55                   	push   %ebp
    1f91:	89 e5                	mov    %esp,%ebp
    1f93:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (p->len > 1) { /* need to reserve a byte for EOS */
    1f96:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
    1f9a:	7e 0c                	jle    1fa8 <sprintf_out+0x18>
		*(p->ptr) = c;
    1f9c:	8b 10                	mov    (%eax),%edx
    1f9e:	8b 4d 08             	mov    0x8(%ebp),%ecx
    1fa1:	88 0a                	mov    %cl,(%edx)
		p->ptr += 1;
    1fa3:	ff 00                	incl   (%eax)
		p->len -= 1;
    1fa5:	ff 48 04             	decl   0x4(%eax)
	}
	return 0; /* indicate keep going so we get the total count */
}
    1fa8:	31 c0                	xor    %eax,%eax
    1faa:	5d                   	pop    %ebp
    1fab:	c3                   	ret    

00001fac <snprintf>:

int snprintf(char *_MLIBC_RESTRICT s, size_t len,
	     const char *_MLIBC_RESTRICT format, ...)
{
    1fac:	55                   	push   %ebp
    1fad:	89 e5                	mov    %esp,%ebp
    1faf:	83 ec 0c             	sub    $0xc,%esp
    1fb2:	8b 45 0c             	mov    0xc(%ebp),%eax
    1fb5:	8b 55 08             	mov    0x8(%ebp),%edx

	struct emitter p;
	int     r;
	char    dummy;

	if (len == 0) {
    1fb8:	85 c0                	test   %eax,%eax
    1fba:	75 03                	jne    1fbf <snprintf+0x13>
		s = &dummy; /* write final NUL to dummy, can't change *s */
    1fbc:	8d 55 f7             	lea    -0x9(%ebp),%edx
	}

	p.ptr = s;
	p.len = (int) len;
    1fbf:	89 45 fc             	mov    %eax,-0x4(%ebp)

	va_start(vargs, format);
    1fc2:	8d 45 14             	lea    0x14(%ebp),%eax
	r = _prf(sprintf_out, (void *) (&p), format, vargs);
    1fc5:	50                   	push   %eax
    1fc6:	8d 45 f8             	lea    -0x8(%ebp),%eax
    1fc9:	ff 75 10             	pushl  0x10(%ebp)
	p.ptr = s;
    1fcc:	89 55 f8             	mov    %edx,-0x8(%ebp)
	r = _prf(sprintf_out, (void *) (&p), format, vargs);
    1fcf:	50                   	push   %eax
    1fd0:	68 90 1f 00 00       	push   $0x1f90
    1fd5:	e8 04 f4 ff ff       	call   13de <_prf>
	va_end(vargs);

	*(p.ptr) = 0;
    1fda:	8b 55 f8             	mov    -0x8(%ebp),%edx
	r = _prf(sprintf_out, (void *) (&p), format, vargs);
    1fdd:	83 c4 10             	add    $0x10,%esp
	*(p.ptr) = 0;
    1fe0:	c6 02 00             	movb   $0x0,(%edx)
	return r;
}
    1fe3:	c9                   	leave  
    1fe4:	c3                   	ret    

00001fe5 <strcpy>:
 *
 * @return pointer to destination buffer <d>
 */

char *strcpy(char *_MLIBC_RESTRICT d, const char *_MLIBC_RESTRICT s)
{
    1fe5:	55                   	push   %ebp
    1fe6:	89 e5                	mov    %esp,%ebp
    1fe8:	53                   	push   %ebx
    1fe9:	8b 45 08             	mov    0x8(%ebp),%eax
    1fec:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	char *dest = d;

	while (*s != '\0') {
    1fef:	89 c2                	mov    %eax,%edx
    1ff1:	8a 19                	mov    (%ecx),%bl
    1ff3:	84 db                	test   %bl,%bl
    1ff5:	74 06                	je     1ffd <strcpy+0x18>
		*d = *s;
    1ff7:	88 1a                	mov    %bl,(%edx)
		d++;
		s++;
    1ff9:	41                   	inc    %ecx
		d++;
    1ffa:	42                   	inc    %edx
    1ffb:	eb f4                	jmp    1ff1 <strcpy+0xc>
	}

	*d = '\0';
    1ffd:	c6 02 00             	movb   $0x0,(%edx)

	return dest;
}
    2000:	5b                   	pop    %ebx
    2001:	5d                   	pop    %ebp
    2002:	c3                   	ret    

00002003 <strchr>:
 *
 * @return pointer to 1st instance of found byte, or NULL if not found
 */

char *strchr(const char *s, int c)
{
    2003:	55                   	push   %ebp
    2004:	89 e5                	mov    %esp,%ebp
    2006:	53                   	push   %ebx
    2007:	8b 55 0c             	mov    0xc(%ebp),%edx
    200a:	8b 45 08             	mov    0x8(%ebp),%eax
	char tmp = (char) c;
    200d:	88 d3                	mov    %dl,%bl

	while ((*s != tmp) && (*s != '\0'))
    200f:	8a 08                	mov    (%eax),%cl
    2011:	38 cb                	cmp    %cl,%bl
    2013:	74 0d                	je     2022 <strchr+0x1f>
    2015:	84 c9                	test   %cl,%cl
    2017:	74 03                	je     201c <strchr+0x19>
		s++;
    2019:	40                   	inc    %eax
    201a:	eb f3                	jmp    200f <strchr+0xc>

	return (*s == tmp) ? (char *) s : NULL;
    201c:	84 d2                	test   %dl,%dl
    201e:	74 02                	je     2022 <strchr+0x1f>
    2020:	31 c0                	xor    %eax,%eax
}
    2022:	5b                   	pop    %ebx
    2023:	5d                   	pop    %ebp
    2024:	c3                   	ret    

00002025 <strrchr>:
 *
 * @return pointer to last instance of found byte, or NULL if not found
 */

char *strrchr(const char *s, int c)
{
    2025:	55                   	push   %ebp
	char *match = NULL;
    2026:	31 c0                	xor    %eax,%eax
{
    2028:	89 e5                	mov    %esp,%ebp
    202a:	8b 55 08             	mov    0x8(%ebp),%edx

	do {
		if (*s == (char)c) {
    202d:	8a 0a                	mov    (%edx),%cl
    202f:	3a 4d 0c             	cmp    0xc(%ebp),%cl
    2032:	75 02                	jne    2036 <strrchr+0x11>
    2034:	89 d0                	mov    %edx,%eax
			match = (char *)s;
		}
	} while (*s++);
    2036:	42                   	inc    %edx
    2037:	84 c9                	test   %cl,%cl
    2039:	75 f2                	jne    202d <strrchr+0x8>

	return match;
}
    203b:	5d                   	pop    %ebp
    203c:	c3                   	ret    

0000203d <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
    203d:	55                   	push   %ebp
	size_t n = 0;
    203e:	31 c0                	xor    %eax,%eax
{
    2040:	89 e5                	mov    %esp,%ebp
    2042:	8b 55 08             	mov    0x8(%ebp),%edx

	while (*s != '\0') {
    2045:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
    2049:	74 03                	je     204e <strlen+0x11>
		s++;
		n++;
    204b:	40                   	inc    %eax
    204c:	eb f7                	jmp    2045 <strlen+0x8>
	}

	return n;
}
    204e:	5d                   	pop    %ebp
    204f:	c3                   	ret    

00002050 <strcmp>:
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
    2050:	55                   	push   %ebp
	while ((*s1 == *s2) && (*s1 != '\0')) {
    2051:	31 c9                	xor    %ecx,%ecx
{
    2053:	89 e5                	mov    %esp,%ebp
	while ((*s1 == *s2) && (*s1 != '\0')) {
    2055:	8b 45 08             	mov    0x8(%ebp),%eax
    2058:	8b 55 0c             	mov    0xc(%ebp),%edx
    205b:	0f be 04 08          	movsbl (%eax,%ecx,1),%eax
    205f:	0f be 14 0a          	movsbl (%edx,%ecx,1),%edx
    2063:	38 d0                	cmp    %dl,%al
    2065:	75 08                	jne    206f <strcmp+0x1f>
    2067:	41                   	inc    %ecx
    2068:	84 c0                	test   %al,%al
    206a:	75 e9                	jne    2055 <strcmp+0x5>
    206c:	0f be d0             	movsbl %al,%edx
		s1++;
		s2++;
	}

	return *s1 - *s2;
    206f:	29 d0                	sub    %edx,%eax
}
    2071:	5d                   	pop    %ebp
    2072:	c3                   	ret    

00002073 <memcmp>:
 * @brief Compare two memory areas
 *
 * @return negative # if <m1> < <m2>, 0 if <m1> == <m2>, else positive #
 */
int memcmp(const void *m1, const void *m2, size_t n)
{
    2073:	55                   	push   %ebp
    2074:	31 c0                	xor    %eax,%eax
    2076:	89 e5                	mov    %esp,%ebp
    2078:	53                   	push   %ebx
    2079:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const char *c1 = m1;
	const char *c2 = m2;

	if (!n)
    207c:	85 c9                	test   %ecx,%ecx
    207e:	74 1d                	je     209d <memcmp+0x2a>
    2080:	8b 55 0c             	mov    0xc(%ebp),%edx
    2083:	8b 45 08             	mov    0x8(%ebp),%eax
		return 0;

	while ((--n > 0) && (*c1 == *c2)) {
    2086:	49                   	dec    %ecx
    2087:	75 0a                	jne    2093 <memcmp+0x20>
		c1++;
		c2++;
	}

	return *c1 - *c2;
    2089:	0f be 00             	movsbl (%eax),%eax
    208c:	0f be 12             	movsbl (%edx),%edx
    208f:	29 d0                	sub    %edx,%eax
    2091:	eb 0a                	jmp    209d <memcmp+0x2a>
	while ((--n > 0) && (*c1 == *c2)) {
    2093:	8a 1a                	mov    (%edx),%bl
    2095:	38 18                	cmp    %bl,(%eax)
    2097:	75 f0                	jne    2089 <memcmp+0x16>
		c1++;
    2099:	40                   	inc    %eax
		c2++;
    209a:	42                   	inc    %edx
    209b:	eb e9                	jmp    2086 <memcmp+0x13>
}
    209d:	5b                   	pop    %ebx
    209e:	5d                   	pop    %ebp
    209f:	c3                   	ret    

000020a0 <memmove>:
 *
 * @return pointer to destination buffer <d>
 */

void *memmove(void *d, const void *s, size_t n)
{
    20a0:	55                   	push   %ebp
    20a1:	89 e5                	mov    %esp,%ebp
    20a3:	56                   	push   %esi
    20a4:	53                   	push   %ebx
    20a5:	8b 45 08             	mov    0x8(%ebp),%eax
    20a8:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	char *dest = d;
	const char *src  = s;

	if ((size_t) (d - s) < n) {
    20ab:	89 c1                	mov    %eax,%ecx
{
    20ad:	8b 75 10             	mov    0x10(%ebp),%esi
	if ((size_t) (d - s) < n) {
    20b0:	29 d9                	sub    %ebx,%ecx
    20b2:	39 f1                	cmp    %esi,%ecx
    20b4:	72 04                	jb     20ba <memmove+0x1a>
    20b6:	31 c9                	xor    %ecx,%ecx
    20b8:	eb 0d                	jmp    20c7 <memmove+0x27>
		 * The <src> buffer overlaps with the start of the <dest> buffer.
		 * Copy backwards to prevent the premature corruption of <src>.
		 */

		while (n > 0) {
			n--;
    20ba:	4e                   	dec    %esi
		while (n > 0) {
    20bb:	85 f6                	test   %esi,%esi
			dest[n] = src[n];
    20bd:	8a 0c 33             	mov    (%ebx,%esi,1),%cl
    20c0:	88 0c 30             	mov    %cl,(%eax,%esi,1)
		while (n > 0) {
    20c3:	75 f5                	jne    20ba <memmove+0x1a>
    20c5:	eb 0d                	jmp    20d4 <memmove+0x34>
		}
	} else {
		/* It is safe to perform a forward-copy */
		while (n > 0) {
    20c7:	39 ce                	cmp    %ecx,%esi
    20c9:	74 09                	je     20d4 <memmove+0x34>
			*dest = *src;
    20cb:	8a 14 0b             	mov    (%ebx,%ecx,1),%dl
    20ce:	88 14 08             	mov    %dl,(%eax,%ecx,1)
    20d1:	41                   	inc    %ecx
    20d2:	eb f3                	jmp    20c7 <memmove+0x27>
			n--;
		}
	}

	return d;
}
    20d4:	5b                   	pop    %ebx
    20d5:	5e                   	pop    %esi
    20d6:	5d                   	pop    %ebp
    20d7:	c3                   	ret    

000020d8 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *_MLIBC_RESTRICT d, const void *_MLIBC_RESTRICT s, size_t n)
{
    20d8:	55                   	push   %ebp
    20d9:	89 e5                	mov    %esp,%ebp
    20db:	57                   	push   %edi
    20dc:	56                   	push   %esi
    20dd:	53                   	push   %ebx
    20de:	8b 45 08             	mov    0x8(%ebp),%eax
    20e1:	8b 55 0c             	mov    0xc(%ebp),%edx
	/* attempt word-sized copying only if buffers have identical alignment */

	unsigned char *d_byte = (unsigned char *)d;
	const unsigned char *s_byte = (const unsigned char *)s;

	if ((((unsigned int)d ^ (unsigned int)s_byte) & 0x3) == 0) {
    20e4:	89 c1                	mov    %eax,%ecx
{
    20e6:	8b 5d 10             	mov    0x10(%ebp),%ebx
	if ((((unsigned int)d ^ (unsigned int)s_byte) & 0x3) == 0) {
    20e9:	31 d1                	xor    %edx,%ecx
    20eb:	80 e1 03             	and    $0x3,%cl
    20ee:	75 3d                	jne    212d <memcpy+0x55>
    20f0:	89 c1                	mov    %eax,%ecx
    20f2:	89 de                	mov    %ebx,%esi

		/* do byte-sized copying until word-aligned or finished */

		while (((unsigned int)d_byte) & 0x3) {
    20f4:	f6 c1 03             	test   $0x3,%cl
    20f7:	74 0f                	je     2108 <memcpy+0x30>
			if (n == 0) {
    20f9:	85 f6                	test   %esi,%esi
    20fb:	74 41                	je     213e <memcpy+0x66>
				return d;
			}
			*(d_byte++) = *(s_byte++);
    20fd:	42                   	inc    %edx
    20fe:	41                   	inc    %ecx
    20ff:	8a 5a ff             	mov    -0x1(%edx),%bl
			n--;
    2102:	4e                   	dec    %esi
			*(d_byte++) = *(s_byte++);
    2103:	88 59 ff             	mov    %bl,-0x1(%ecx)
    2106:	eb ec                	jmp    20f4 <memcpy+0x1c>
    2108:	31 db                	xor    %ebx,%ebx
		/* do word-sized copying as long as possible */

		unsigned int *d_word = (unsigned int *)d_byte;
		const unsigned int *s_word = (const unsigned int *)s_byte;

		while (n >= sizeof(unsigned int)) {
    210a:	89 f7                	mov    %esi,%edi
    210c:	29 df                	sub    %ebx,%edi
    210e:	83 ff 03             	cmp    $0x3,%edi
    2111:	76 0b                	jbe    211e <memcpy+0x46>
			*(d_word++) = *(s_word++);
    2113:	8b 3c 1a             	mov    (%edx,%ebx,1),%edi
    2116:	89 3c 19             	mov    %edi,(%ecx,%ebx,1)
    2119:	83 c3 04             	add    $0x4,%ebx
    211c:	eb ec                	jmp    210a <memcpy+0x32>
    211e:	89 f3                	mov    %esi,%ebx
    2120:	83 e6 fc             	and    $0xfffffffc,%esi
    2123:	83 e3 03             	and    $0x3,%ebx
		while (n >= sizeof(unsigned int)) {
    2126:	01 f2                	add    %esi,%edx
    2128:	8d 3c 31             	lea    (%ecx,%esi,1),%edi
    212b:	eb 02                	jmp    212f <memcpy+0x57>
	unsigned char *d_byte = (unsigned char *)d;
    212d:	89 c7                	mov    %eax,%edi
    212f:	31 f6                	xor    %esi,%esi
		s_byte = (unsigned char *)s_word;
	}

	/* do byte-sized copying until finished */

	while (n > 0) {
    2131:	39 f3                	cmp    %esi,%ebx
    2133:	74 09                	je     213e <memcpy+0x66>
		*(d_byte++) = *(s_byte++);
    2135:	8a 0c 32             	mov    (%edx,%esi,1),%cl
    2138:	88 0c 37             	mov    %cl,(%edi,%esi,1)
    213b:	46                   	inc    %esi
    213c:	eb f3                	jmp    2131 <memcpy+0x59>
		n--;
	}

	return d;
}
    213e:	5b                   	pop    %ebx
    213f:	5e                   	pop    %esi
    2140:	5f                   	pop    %edi
    2141:	5d                   	pop    %ebp
    2142:	c3                   	ret    

00002143 <memset>:
 *
 * @return pointer to start of buffer
 */

void *memset(void *buf, int c, size_t n)
{
    2143:	55                   	push   %ebp
    2144:	89 e5                	mov    %esp,%ebp
    2146:	57                   	push   %edi
    2147:	56                   	push   %esi
    2148:	53                   	push   %ebx
    2149:	8b 55 0c             	mov    0xc(%ebp),%edx
    214c:	8b 5d 10             	mov    0x10(%ebp),%ebx
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
    214f:	88 d0                	mov    %dl,%al
	unsigned char *d_byte = (unsigned char *)buf;
    2151:	8b 4d 08             	mov    0x8(%ebp),%ecx

	while (((unsigned int)d_byte) & 0x3) {
    2154:	f6 c1 03             	test   $0x3,%cl
    2157:	74 0b                	je     2164 <memset+0x21>
		if (n == 0) {
    2159:	85 db                	test   %ebx,%ebx
    215b:	74 41                	je     219e <memset+0x5b>
			return buf;
		}
		*(d_byte++) = c_byte;
    215d:	41                   	inc    %ecx
		n--;
    215e:	4b                   	dec    %ebx
		*(d_byte++) = c_byte;
    215f:	88 41 ff             	mov    %al,-0x1(%ecx)
    2162:	eb f0                	jmp    2154 <memset+0x11>
	};

	/* do word-sized initialization as long as possible */

	unsigned int *d_word = (unsigned int *)d_byte;
	unsigned int c_word = (unsigned int)(unsigned char)c;
    2164:	0f b6 d2             	movzbl %dl,%edx

	c_word |= c_word << 8;
    2167:	89 d6                	mov    %edx,%esi
    2169:	c1 e6 08             	shl    $0x8,%esi
    216c:	09 f2                	or     %esi,%edx
	c_word |= c_word << 16;
    216e:	89 d6                	mov    %edx,%esi
    2170:	c1 e6 10             	shl    $0x10,%esi
    2173:	09 f2                	or     %esi,%edx

	while (n >= sizeof(unsigned int)) {
    2175:	31 f6                	xor    %esi,%esi
    2177:	89 df                	mov    %ebx,%edi
    2179:	29 f7                	sub    %esi,%edi
    217b:	83 ff 03             	cmp    $0x3,%edi
    217e:	76 08                	jbe    2188 <memset+0x45>
		*(d_word++) = c_word;
    2180:	89 14 31             	mov    %edx,(%ecx,%esi,1)
    2183:	83 c6 04             	add    $0x4,%esi
    2186:	eb ef                	jmp    2177 <memset+0x34>
    2188:	89 da                	mov    %ebx,%edx
    218a:	83 e3 fc             	and    $0xfffffffc,%ebx
    218d:	01 d9                	add    %ebx,%ecx
    218f:	83 e2 03             	and    $0x3,%edx
	while (n >= sizeof(unsigned int)) {
    2192:	31 db                	xor    %ebx,%ebx

	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;

	while (n > 0) {
    2194:	39 da                	cmp    %ebx,%edx
    2196:	74 06                	je     219e <memset+0x5b>
		*(d_byte++) = c_byte;
    2198:	88 04 19             	mov    %al,(%ecx,%ebx,1)
    219b:	43                   	inc    %ebx
    219c:	eb f6                	jmp    2194 <memset+0x51>
		n--;
	}

	return buf;
}
    219e:	5b                   	pop    %ebx
    219f:	8b 45 08             	mov    0x8(%ebp),%eax
    21a2:	5e                   	pop    %esi
    21a3:	5f                   	pop    %edi
    21a4:	5d                   	pop    %ebp
    21a5:	c3                   	ret    

000021a6 <strtol>:
 *
 * Ignores `locale' stuff.  Assumes that the upper and lower case
 * alphabets and digits are each contiguous.
 */
long strtol(const char *nptr, char **endptr, register int base)
{
    21a6:	55                   	push   %ebp
    21a7:	89 e5                	mov    %esp,%ebp
    21a9:	57                   	push   %edi
    21aa:	56                   	push   %esi
    21ab:	53                   	push   %ebx
    21ac:	83 ec 10             	sub    $0x10,%esp
    21af:	8b 75 10             	mov    0x10(%ebp),%esi
	register const char *s = nptr;
    21b2:	8b 45 08             	mov    0x8(%ebp),%eax
	 * Skip white space and pick up leading +/- sign if any.
	 * If base is 0, allow 0x for hex and 0 for octal, else
	 * assume decimal; if base is already 16, allow 0x.
	 */
	do {
		c = *s++;
    21b5:	8d 58 01             	lea    0x1(%eax),%ebx
    21b8:	0f be 4b ff          	movsbl -0x1(%ebx),%ecx
	return c == ' ' || ((unsigned)c-'\t') < 5;
    21bc:	8d 51 f7             	lea    -0x9(%ecx),%edx
	} while (isspace(c));
    21bf:	83 fa 04             	cmp    $0x4,%edx
    21c2:	77 04                	ja     21c8 <strtol+0x22>
    21c4:	89 d8                	mov    %ebx,%eax
    21c6:	eb ed                	jmp    21b5 <strtol+0xf>
    21c8:	83 f9 20             	cmp    $0x20,%ecx
    21cb:	74 f7                	je     21c4 <strtol+0x1e>
	if (c == '-') {
    21cd:	83 f9 2d             	cmp    $0x2d,%ecx
    21d0:	75 0f                	jne    21e1 <strtol+0x3b>
		neg = 1;
		c = *s++;
    21d2:	0f be 0b             	movsbl (%ebx),%ecx
		neg = 1;
    21d5:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		c = *s++;
    21dc:	8d 58 02             	lea    0x2(%eax),%ebx
    21df:	eb 12                	jmp    21f3 <strtol+0x4d>
	register int neg = 0, any, cutlim;
    21e1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	} else if (c == '+')
    21e8:	83 f9 2b             	cmp    $0x2b,%ecx
    21eb:	75 06                	jne    21f3 <strtol+0x4d>
		c = *s++;
    21ed:	0f be 0b             	movsbl (%ebx),%ecx
    21f0:	8d 58 02             	lea    0x2(%eax),%ebx
	if ((base == 0 || base == 16) &&
    21f3:	f7 c6 ef ff ff ff    	test   $0xffffffef,%esi
    21f9:	75 30                	jne    222b <strtol+0x85>
    21fb:	83 f9 30             	cmp    $0x30,%ecx
    21fe:	75 17                	jne    2217 <strtol+0x71>
	    c == '0' && (*s == 'x' || *s == 'X')) {
    2200:	8a 03                	mov    (%ebx),%al
    2202:	83 e0 df             	and    $0xffffffdf,%eax
    2205:	3c 58                	cmp    $0x58,%al
    2207:	75 19                	jne    2222 <strtol+0x7c>
		c = s[1];
    2209:	0f be 4b 01          	movsbl 0x1(%ebx),%ecx
		s += 2;
		base = 16;
    220d:	be 10 00 00 00       	mov    $0x10,%esi
		s += 2;
    2212:	83 c3 02             	add    $0x2,%ebx
    2215:	eb 14                	jmp    222b <strtol+0x85>
	}
	if (base == 0)
    2217:	85 f6                	test   %esi,%esi
    2219:	75 10                	jne    222b <strtol+0x85>
		base = c == '0' ? 8 : 10;
    221b:	be 0a 00 00 00       	mov    $0xa,%esi
    2220:	eb 09                	jmp    222b <strtol+0x85>
	if (base == 0)
    2222:	85 f6                	test   %esi,%esi
    2224:	75 05                	jne    222b <strtol+0x85>
		base = c == '0' ? 8 : 10;
    2226:	be 08 00 00 00       	mov    $0x8,%esi
	 * the number is too big, and we will return a range error.
	 *
	 * Set any if any `digits' consumed; make it negative to indicate
	 * overflow.
	 */
	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
    222b:	8b 45 f0             	mov    -0x10(%ebp),%eax
	cutlim = cutoff % (unsigned long)base;
    222e:	31 d2                	xor    %edx,%edx
	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
    2230:	05 ff ff ff 7f       	add    $0x7fffffff,%eax
	cutoff /= (unsigned long)base;
	for (acc = 0, any = 0;; c = *s++) {
    2235:	31 ff                	xor    %edi,%edi
	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
    2237:	89 45 ec             	mov    %eax,-0x14(%ebp)
	cutlim = cutoff % (unsigned long)base;
    223a:	f7 f6                	div    %esi
    223c:	89 45 e8             	mov    %eax,-0x18(%ebp)
    223f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	for (acc = 0, any = 0;; c = *s++) {
    2242:	31 c0                	xor    %eax,%eax
	return (((unsigned)(a)-'0') < 10);
    2244:	8d 51 d0             	lea    -0x30(%ecx),%edx
		if (isdigit(c))
    2247:	83 fa 09             	cmp    $0x9,%edx
    224a:	77 04                	ja     2250 <strtol+0xaa>
			c -= '0';
    224c:	89 d1                	mov    %edx,%ecx
    224e:	eb 1d                	jmp    226d <strtol+0xc7>
	return (((unsigned)c|32)-'a') < 26;
    2250:	89 ca                	mov    %ecx,%edx
    2252:	83 ca 20             	or     $0x20,%edx
    2255:	83 ea 61             	sub    $0x61,%edx
		else if (isalpha(c))
    2258:	83 fa 19             	cmp    $0x19,%edx
    225b:	77 41                	ja     229e <strtol+0xf8>
	return ((unsigned)(a)-'A') < 26;
    225d:	8d 51 bf             	lea    -0x41(%ecx),%edx
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
    2260:	83 fa 1a             	cmp    $0x1a,%edx
    2263:	19 d2                	sbb    %edx,%edx
    2265:	83 e2 e0             	and    $0xffffffe0,%edx
    2268:	83 c2 57             	add    $0x57,%edx
    226b:	29 d1                	sub    %edx,%ecx
		else
			break;
		if (c >= base)
    226d:	39 ce                	cmp    %ecx,%esi
    226f:	7e 2d                	jle    229e <strtol+0xf8>
			break;
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim))
    2271:	c1 ef 1f             	shr    $0x1f,%edi
    2274:	75 1e                	jne    2294 <strtol+0xee>
    2276:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    2279:	77 19                	ja     2294 <strtol+0xee>
    227b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    227e:	75 08                	jne    2288 <strtol+0xe2>
			any = -1;
    2280:	83 cf ff             	or     $0xffffffff,%edi
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim))
    2283:	3b 4d e4             	cmp    -0x1c(%ebp),%ecx
    2286:	7f 0f                	jg     2297 <strtol+0xf1>
		else {
			any = 1;
			acc *= base;
    2288:	0f af c6             	imul   %esi,%eax
			any = 1;
    228b:	bf 01 00 00 00       	mov    $0x1,%edi
			acc += c;
    2290:	01 c8                	add    %ecx,%eax
    2292:	eb 03                	jmp    2297 <strtol+0xf1>
			any = -1;
    2294:	83 cf ff             	or     $0xffffffff,%edi
	for (acc = 0, any = 0;; c = *s++) {
    2297:	43                   	inc    %ebx
    2298:	0f be 4b ff          	movsbl -0x1(%ebx),%ecx
		if (isdigit(c))
    229c:	eb a6                	jmp    2244 <strtol+0x9e>
		}
	}
	if (any < 0) {
    229e:	83 ff ff             	cmp    $0xffffffff,%edi
    22a1:	75 16                	jne    22b9 <strtol+0x113>
		acc = neg ? LONG_MIN : LONG_MAX;
		errno = ERANGE;
    22a3:	e8 7b 3e 00 00       	call   6123 <__errno>
	} else if (neg)
		acc = -acc;
	if (endptr != 0)
    22a8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
		errno = ERANGE;
    22ac:	c7 00 26 00 00 00    	movl   $0x26,(%eax)
		acc = neg ? LONG_MIN : LONG_MAX;
    22b2:	8b 45 ec             	mov    -0x14(%ebp),%eax
	if (endptr != 0)
    22b5:	75 14                	jne    22cb <strtol+0x125>
    22b7:	eb 20                	jmp    22d9 <strtol+0x133>
	} else if (neg)
    22b9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    22bd:	74 02                	je     22c1 <strtol+0x11b>
		acc = -acc;
    22bf:	f7 d8                	neg    %eax
	if (endptr != 0)
    22c1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    22c5:	74 12                	je     22d9 <strtol+0x133>
		*endptr = (char *)(any ? s - 1 : nptr);
    22c7:	85 ff                	test   %edi,%edi
    22c9:	74 06                	je     22d1 <strtol+0x12b>
    22cb:	8d 73 ff             	lea    -0x1(%ebx),%esi
    22ce:	89 75 08             	mov    %esi,0x8(%ebp)
    22d1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    22d4:	8b 7d 08             	mov    0x8(%ebp),%edi
    22d7:	89 3b                	mov    %edi,(%ebx)
	return acc;
}
    22d9:	83 c4 10             	add    $0x10,%esp
    22dc:	5b                   	pop    %ebx
    22dd:	5e                   	pop    %esi
    22de:	5f                   	pop    %edi
    22df:	5d                   	pop    %ebp
    22e0:	c3                   	ret    

000022e1 <console_out>:
 *
 * @return The character passed as input.
 */

static int console_out(int c)
{
    22e1:	55                   	push   %ebp
    22e2:	89 e5                	mov    %esp,%ebp
		return c;
	}

#endif /* CONFIG_UART_CONSOLE_DEBUG_SERVER_HOOKS */

	if ('\n' == c) {
    22e4:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
    22e8:	75 10                	jne    22fa <console_out+0x19>
		uart_poll_out(uart_console_dev, '\r');
    22ea:	a1 00 52 40 00       	mov    0x405200,%eax
static inline unsigned char uart_poll_out(struct device *dev,
					  unsigned char out_char)
{
	const struct uart_driver_api *api = dev->driver_api;

	return api->poll_out(dev, out_char);
    22ef:	8b 50 04             	mov    0x4(%eax),%edx
    22f2:	6a 0d                	push   $0xd
    22f4:	50                   	push   %eax
    22f5:	ff 52 04             	call   *0x4(%edx)
    22f8:	59                   	pop    %ecx
    22f9:	58                   	pop    %eax
	}
	uart_poll_out(uart_console_dev, c);
    22fa:	a1 00 52 40 00       	mov    0x405200,%eax
    22ff:	0f b6 4d 08          	movzbl 0x8(%ebp),%ecx
    2303:	8b 50 04             	mov    0x4(%eax),%edx
    2306:	51                   	push   %ecx
    2307:	50                   	push   %eax
    2308:	ff 52 04             	call   *0x4(%edx)
    230b:	58                   	pop    %eax

	return c;
}
    230c:	8b 45 08             	mov    0x8(%ebp),%eax
    230f:	5a                   	pop    %edx
    2310:	c9                   	leave  
    2311:	c3                   	ret    

00002312 <uart_console_hook_install>:
 *
 * @return N/A
 */

void uart_console_hook_install(void)
{
    2312:	55                   	push   %ebp
    2313:	89 e5                	mov    %esp,%ebp
	__stdout_hook_install(console_out);
	__printk_hook_install(console_out);
    2315:	68 e1 22 00 00       	push   $0x22e1
    231a:	e8 79 0c 00 00       	call   2f98 <__printk_hook_install>
    231f:	58                   	pop    %eax
}
    2320:	c9                   	leave  
    2321:	c3                   	ret    

00002322 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(struct device *arg)
{
    2322:	55                   	push   %ebp
    2323:	89 e5                	mov    %esp,%ebp

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
    2325:	68 49 75 00 00       	push   $0x7549
    232a:	e8 bb 3d 00 00       	call   60ea <device_get_binding>
    232f:	5a                   	pop    %edx
    2330:	a3 00 52 40 00       	mov    %eax,0x405200
		}
	}
	k_busy_wait(1000000);
#endif

	uart_console_hook_install();
    2335:	e8 d8 ff ff ff       	call   2312 <uart_console_hook_install>

	return 0;
}
    233a:	31 c0                	xor    %eax,%eax
    233c:	c9                   	leave  
    233d:	c3                   	ret    

0000233e <uart_pipe_isr>:

static void uart_pipe_isr(struct device *unused)
{
	ARG_UNUSED(unused);

	while (uart_irq_update(uart_pipe_dev)
    233e:	8b 15 14 52 40 00    	mov    0x405214,%edx
 */
static inline int uart_irq_update(struct device *dev)
{
	const struct uart_driver_api *api = dev->driver_api;

	if (api->irq_update) {
    2344:	8b 42 04             	mov    0x4(%edx),%eax
    2347:	8b 40 3c             	mov    0x3c(%eax),%eax
    234a:	85 c0                	test   %eax,%eax
    234c:	74 48                	je     2396 <uart_pipe_isr+0x58>
{
    234e:	55                   	push   %ebp
    234f:	89 e5                	mov    %esp,%ebp
    2351:	53                   	push   %ebx
		return api->irq_update(dev);
    2352:	52                   	push   %edx
    2353:	ff d0                	call   *%eax
    2355:	59                   	pop    %ecx
	while (uart_irq_update(uart_pipe_dev)
    2356:	85 c0                	test   %eax,%eax
    2358:	74 38                	je     2392 <uart_pipe_isr+0x54>
	       && uart_irq_is_pending(uart_pipe_dev)) {
    235a:	8b 15 14 52 40 00    	mov    0x405214,%edx
	if (api->irq_is_pending)	{
    2360:	8b 42 04             	mov    0x4(%edx),%eax
    2363:	8b 40 38             	mov    0x38(%eax),%eax
    2366:	85 c0                	test   %eax,%eax
    2368:	74 28                	je     2392 <uart_pipe_isr+0x54>
		return api->irq_is_pending(dev);
    236a:	52                   	push   %edx
    236b:	ff d0                	call   *%eax
    236d:	5a                   	pop    %edx
    236e:	85 c0                	test   %eax,%eax
    2370:	74 20                	je     2392 <uart_pipe_isr+0x54>
		int rx;

		if (!uart_irq_rx_ready(uart_pipe_dev)) {
    2372:	8b 15 14 52 40 00    	mov    0x405214,%edx
	if (api->irq_rx_ready) {
    2378:	8b 42 04             	mov    0x4(%edx),%eax
    237b:	8b 40 2c             	mov    0x2c(%eax),%eax
    237e:	85 c0                	test   %eax,%eax
    2380:	75 15                	jne    2397 <uart_pipe_isr+0x59>
	while (uart_irq_update(uart_pipe_dev)
    2382:	8b 15 14 52 40 00    	mov    0x405214,%edx
	if (api->irq_update) {
    2388:	8b 42 04             	mov    0x4(%edx),%eax
    238b:	8b 40 3c             	mov    0x3c(%eax),%eax
    238e:	85 c0                	test   %eax,%eax
    2390:	75 c0                	jne    2352 <uart_pipe_isr+0x14>
		 * may provide new buffer or alter data offset.
		 */
		recv_off += rx;
		recv_buf = app_cb(recv_buf, &recv_off);
	}
}
    2392:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    2395:	c9                   	leave  
    2396:	c3                   	ret    
		return api->irq_rx_ready(dev);
    2397:	52                   	push   %edx
    2398:	ff d0                	call   *%eax
    239a:	59                   	pop    %ecx
		if (!uart_irq_rx_ready(uart_pipe_dev)) {
    239b:	85 c0                	test   %eax,%eax
    239d:	74 e3                	je     2382 <uart_pipe_isr+0x44>
		rx = uart_fifo_read(uart_pipe_dev, recv_buf + recv_off,
    239f:	8b 1d 14 52 40 00    	mov    0x405214,%ebx
	if (api->fifo_read) {
    23a5:	8b 43 04             	mov    0x4(%ebx),%eax
    23a8:	8b 48 10             	mov    0x10(%eax),%ecx
    23ab:	85 c9                	test   %ecx,%ecx
    23ad:	74 d3                	je     2382 <uart_pipe_isr+0x44>
				    recv_buf_len - recv_off);
    23af:	a1 04 52 40 00       	mov    0x405204,%eax
    23b4:	8b 15 0c 52 40 00    	mov    0x40520c,%edx
    23ba:	29 c2                	sub    %eax,%edx
		rx = uart_fifo_read(uart_pipe_dev, recv_buf + recv_off,
    23bc:	03 05 10 52 40 00    	add    0x405210,%eax
		return api->fifo_read(dev, rx_data, size);
    23c2:	52                   	push   %edx
    23c3:	50                   	push   %eax
    23c4:	53                   	push   %ebx
    23c5:	ff d1                	call   *%ecx
    23c7:	83 c4 0c             	add    $0xc,%esp
		if (!rx) {
    23ca:	85 c0                	test   %eax,%eax
    23cc:	74 b4                	je     2382 <uart_pipe_isr+0x44>
		recv_buf = app_cb(recv_buf, &recv_off);
    23ce:	68 04 52 40 00       	push   $0x405204
		recv_off += rx;
    23d3:	01 05 04 52 40 00    	add    %eax,0x405204
		recv_buf = app_cb(recv_buf, &recv_off);
    23d9:	ff 35 10 52 40 00    	pushl  0x405210
    23df:	ff 15 08 52 40 00    	call   *0x405208
    23e5:	5b                   	pop    %ebx
    23e6:	a3 10 52 40 00       	mov    %eax,0x405210
    23eb:	5a                   	pop    %edx
    23ec:	eb 94                	jmp    2382 <uart_pipe_isr+0x44>

000023ee <uart_pipe_send>:

int uart_pipe_send(const u8_t *data, int len)
{
    23ee:	55                   	push   %ebp
    23ef:	89 e5                	mov    %esp,%ebp
    23f1:	56                   	push   %esi
    23f2:	53                   	push   %ebx
    23f3:	8b 75 0c             	mov    0xc(%ebp),%esi
    23f6:	8b 5d 08             	mov    0x8(%ebp),%ebx
    23f9:	01 de                	add    %ebx,%esi
	while (len--)  {
    23fb:	39 f3                	cmp    %esi,%ebx
    23fd:	74 16                	je     2415 <uart_pipe_send+0x27>
		uart_poll_out(uart_pipe_dev, *data++);
    23ff:	a1 14 52 40 00       	mov    0x405214,%eax
    2404:	43                   	inc    %ebx
    2405:	0f b6 4b ff          	movzbl -0x1(%ebx),%ecx
	return api->poll_out(dev, out_char);
    2409:	8b 50 04             	mov    0x4(%eax),%edx
    240c:	51                   	push   %ecx
    240d:	50                   	push   %eax
    240e:	ff 52 04             	call   *0x4(%edx)
    2411:	58                   	pop    %eax
    2412:	5a                   	pop    %edx
    2413:	eb e6                	jmp    23fb <uart_pipe_send+0xd>
	}

	return 0;
}
    2415:	8d 65 f8             	lea    -0x8(%ebp),%esp
    2418:	31 c0                	xor    %eax,%eax
    241a:	5b                   	pop    %ebx
    241b:	5e                   	pop    %esi
    241c:	5d                   	pop    %ebp
    241d:	c3                   	ret    

0000241e <uart_pipe_register>:

	uart_irq_rx_enable(uart);
}

void uart_pipe_register(u8_t *buf, size_t len, uart_pipe_recv_cb cb)
{
    241e:	55                   	push   %ebp
    241f:	89 e5                	mov    %esp,%ebp
    2421:	56                   	push   %esi
    2422:	53                   	push   %ebx
    2423:	50                   	push   %eax
	recv_buf = buf;
    2424:	8b 45 08             	mov    0x8(%ebp),%eax
	recv_buf_len = len;
	app_cb = cb;

	uart_pipe_dev = device_get_binding(CONFIG_UART_PIPE_ON_DEV_NAME);
    2427:	68 50 75 00 00       	push   $0x7550
	recv_buf = buf;
    242c:	a3 10 52 40 00       	mov    %eax,0x405210
	recv_buf_len = len;
    2431:	8b 45 0c             	mov    0xc(%ebp),%eax
    2434:	a3 0c 52 40 00       	mov    %eax,0x40520c
	app_cb = cb;
    2439:	8b 45 10             	mov    0x10(%ebp),%eax
    243c:	a3 08 52 40 00       	mov    %eax,0x405208
	uart_pipe_dev = device_get_binding(CONFIG_UART_PIPE_ON_DEV_NAME);
    2441:	e8 a4 3c 00 00       	call   60ea <device_get_binding>
    2446:	5a                   	pop    %edx
    2447:	a3 14 52 40 00       	mov    %eax,0x405214

	if (uart_pipe_dev != NULL) {
    244c:	85 c0                	test   %eax,%eax
    244e:	74 62                	je     24b2 <uart_pipe_register+0x94>
    2450:	89 c3                	mov    %eax,%ebx
	if (api->irq_rx_disable) {
    2452:	8b 40 04             	mov    0x4(%eax),%eax
    2455:	8b 40 24             	mov    0x24(%eax),%eax
    2458:	85 c0                	test   %eax,%eax
    245a:	74 04                	je     2460 <uart_pipe_register+0x42>
		api->irq_rx_disable(dev);
    245c:	53                   	push   %ebx
    245d:	ff d0                	call   *%eax
    245f:	58                   	pop    %eax
	if (api->irq_tx_disable) {
    2460:	8b 43 04             	mov    0x4(%ebx),%eax
    2463:	8b 40 18             	mov    0x18(%eax),%eax
    2466:	85 c0                	test   %eax,%eax
    2468:	74 04                	je     246e <uart_pipe_register+0x50>
		api->irq_tx_disable(dev);
    246a:	53                   	push   %ebx
    246b:	ff d0                	call   *%eax
    246d:	5e                   	pop    %esi
		return api->fifo_read(dev, rx_data, size);
    246e:	8d 75 f7             	lea    -0x9(%ebp),%esi
	if (api->fifo_read) {
    2471:	8b 43 04             	mov    0x4(%ebx),%eax
    2474:	8b 40 10             	mov    0x10(%eax),%eax
    2477:	85 c0                	test   %eax,%eax
    2479:	75 09                	jne    2484 <uart_pipe_register+0x66>
 * @return N/A
 */
static inline void uart_irq_callback_set(struct device *dev,
					 uart_irq_callback_t cb)
{
	const struct uart_driver_api *api = dev->driver_api;
    247b:	8b 43 04             	mov    0x4(%ebx),%eax

	if ((api != NULL) && (api->irq_callback_set != NULL)) {
    247e:	85 c0                	test   %eax,%eax
    2480:	75 11                	jne    2493 <uart_pipe_register+0x75>
    2482:	eb 20                	jmp    24a4 <uart_pipe_register+0x86>
		return api->fifo_read(dev, rx_data, size);
    2484:	6a 01                	push   $0x1
    2486:	56                   	push   %esi
    2487:	53                   	push   %ebx
    2488:	ff d0                	call   *%eax
    248a:	83 c4 0c             	add    $0xc,%esp
	while (uart_fifo_read(uart, &c, 1)) {
    248d:	85 c0                	test   %eax,%eax
    248f:	75 e0                	jne    2471 <uart_pipe_register+0x53>
    2491:	eb e8                	jmp    247b <uart_pipe_register+0x5d>
	if ((api != NULL) && (api->irq_callback_set != NULL)) {
    2493:	8b 40 40             	mov    0x40(%eax),%eax
    2496:	85 c0                	test   %eax,%eax
    2498:	74 0a                	je     24a4 <uart_pipe_register+0x86>
		api->irq_callback_set(dev, cb);
    249a:	68 3e 23 00 00       	push   $0x233e
    249f:	53                   	push   %ebx
    24a0:	ff d0                	call   *%eax
    24a2:	5a                   	pop    %edx
    24a3:	59                   	pop    %ecx
	if (api->irq_rx_enable) {
    24a4:	8b 43 04             	mov    0x4(%ebx),%eax
    24a7:	8b 40 20             	mov    0x20(%eax),%eax
    24aa:	85 c0                	test   %eax,%eax
    24ac:	74 04                	je     24b2 <uart_pipe_register+0x94>
		api->irq_rx_enable(dev);
    24ae:	53                   	push   %ebx
    24af:	ff d0                	call   *%eax
    24b1:	58                   	pop    %eax
		uart_pipe_setup(uart_pipe_dev);
	}
}
    24b2:	8d 65 f8             	lea    -0x8(%ebp),%esp
    24b5:	5b                   	pop    %ebx
    24b6:	5e                   	pop    %esi
    24b7:	5d                   	pop    %ebp
    24b8:	c3                   	ret    

000024b9 <sys_rand32_get>:
 *
 * @return a 32-bit number
 */

u32_t sys_rand32_get(void)
{
    24b9:	55                   	push   %ebp
    24ba:	89 e5                	mov    %esp,%ebp
static ALWAYS_INLINE
	u32_t _do_read_cpu_timestamp32(void)
{
	u32_t rv;

	__asm__ volatile("rdtsc" : "=a"(rv) :  : "%edx");
    24bc:	0f 31                	rdtsc  
	return _do_read_cpu_timestamp32();
}
    24be:	5d                   	pop    %ebp
    24bf:	c3                   	ret    

000024c0 <uart_ns16550_init>:
 * @param dev UART device struct
 *
 * @return 0 if successful, failed otherwise
 */
static int uart_ns16550_init(struct device *dev)
{
    24c0:	55                   	push   %ebp
    24c1:	89 e5                	mov    %esp,%ebp
    24c3:	57                   	push   %edi
    24c4:	56                   	push   %esi
    24c5:	53                   	push   %ebx
    24c6:	83 ec 10             	sub    $0x10,%esp
    24c9:	8b 4d 08             	mov    0x8(%ebp),%ecx
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
    24cc:	8b 59 08             	mov    0x8(%ecx),%ebx
		dev->driver_api = NULL;
		return -ENOTSUP;
	}

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	dev_data->iir_cache = 0;
    24cf:	c6 43 09 00          	movb   $0x0,0x9(%ebx)
	__asm__ volatile (
    24d3:	9c                   	pushf  
    24d4:	fa                   	cli    
    24d5:	8f 45 e8             	popl   -0x18(%ebp)
#endif

	old_level = irq_lock();

	set_baud_rate(dev, dev_data->baud_rate);
    24d8:	8b 7b 04             	mov    0x4(%ebx),%edi
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
    24db:	8b 71 08             	mov    0x8(%ecx),%esi
	if ((baud_rate != 0) && (dev_cfg->sys_clk_freq != 0)) {
    24de:	85 ff                	test   %edi,%edi
    24e0:	74 3e                	je     2520 <uart_ns16550_init+0x60>
	const struct uart_ns16550_device_config * const dev_cfg = DEV_CFG(dev);
    24e2:	8b 01                	mov    (%ecx),%eax
	if ((baud_rate != 0) && (dev_cfg->sys_clk_freq != 0)) {
    24e4:	8b 40 08             	mov    0x8(%eax),%eax
    24e7:	8b 00                	mov    (%eax),%eax
    24e9:	85 c0                	test   %eax,%eax
    24eb:	74 33                	je     2520 <uart_ns16550_init+0x60>
		divisor = (dev_cfg->sys_clk_freq / baud_rate) >> 4;
    24ed:	31 d2                	xor    %edx,%edx
    24ef:	f7 f7                	div    %edi
    24f1:	89 45 ec             	mov    %eax,-0x14(%ebp)
		lcr_cache = INBYTE(LCR(dev));
    24f4:	8b 06                	mov    (%esi),%eax
    24f6:	83 c0 03             	add    $0x3,%eax
    24f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
static ALWAYS_INLINE
	u8_t sys_in8(io_port_t port)
{
	u8_t ret;

	__asm__ volatile("inb	%w1, %b0;\n\t"
    24fc:	89 c2                	mov    %eax,%edx
    24fe:	ec                   	in     (%dx),%al
    24ff:	88 45 e7             	mov    %al,-0x19(%ebp)
	__asm__ volatile("outb	%b0, %w1;\n\t"
    2502:	b0 80                	mov    $0x80,%al
    2504:	ee                   	out    %al,(%dx)
		divisor = (dev_cfg->sys_clk_freq / baud_rate) >> 4;
    2505:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2508:	8b 16                	mov    (%esi),%edx
    250a:	c1 e8 04             	shr    $0x4,%eax
    250d:	ee                   	out    %al,(%dx)
		OUTBYTE(BRDH(dev), (unsigned char)((divisor >> 8) & 0xff));
    250e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2511:	42                   	inc    %edx
    2512:	c1 e8 0c             	shr    $0xc,%eax
    2515:	ee                   	out    %al,(%dx)
    2516:	8a 45 e7             	mov    -0x19(%ebp),%al
    2519:	8b 55 f0             	mov    -0x10(%ebp),%edx
    251c:	ee                   	out    %al,(%dx)
		dev_data->baud_rate = baud_rate;
    251d:	89 7e 04             	mov    %edi,0x4(%esi)
#ifdef CONFIG_UART_NS16550_DLF
	set_dlf(dev, dev_data->dlf);
#endif

	/* 8 data bits, 1 stop bit, no parity, clear DLAB */
	OUTBYTE(LCR(dev), LCR_CS8 | LCR_1_STB | LCR_PDIS);
    2520:	8b 36                	mov    (%esi),%esi
    2522:	b0 03                	mov    $0x3,%al
    2524:	8d 56 03             	lea    0x3(%esi),%edx
    2527:	ee                   	out    %al,(%dx)

	mdc = MCR_OUT2 | MCR_RTS | MCR_DTR;
	if ((dev_data->options & UART_OPTION_AFCE) == UART_OPTION_AFCE)
    2528:	8a 43 08             	mov    0x8(%ebx),%al
		mdc |= MCR_AFCE;

	OUTBYTE(MDC(dev), mdc);
    252b:	8d 56 04             	lea    0x4(%esi),%edx
	if ((dev_data->options & UART_OPTION_AFCE) == UART_OPTION_AFCE)
    252e:	83 e0 01             	and    $0x1,%eax
		mdc |= MCR_AFCE;
    2531:	3c 01                	cmp    $0x1,%al
    2533:	19 c0                	sbb    %eax,%eax
    2535:	83 e0 e0             	and    $0xffffffe0,%eax
    2538:	83 c0 2b             	add    $0x2b,%eax
    253b:	ee                   	out    %al,(%dx)
    253c:	b0 87                	mov    $0x87,%al
	/*
	 * Program FIFO: enabled, mode 0 (set for compatibility with quark),
	 * generate the interrupt at 8th byte
	 * Clear TX and RX FIFO
	 */
	OUTBYTE(FCR(dev),
    253e:	8d 56 02             	lea    0x2(%esi),%edx
    2541:	ee                   	out    %al,(%dx)
	__asm__ volatile("inb	%w1, %b0;\n\t"
    2542:	89 f2                	mov    %esi,%edx
    2544:	ec                   	in     (%dx),%al
	__asm__ volatile("outb	%b0, %w1;\n\t"
    2545:	31 c0                	xor    %eax,%eax

	/* clear the port */
	INBYTE(RDR(dev));

	/* disable interrupts  */
	OUTBYTE(IER(dev), 0x00);
    2547:	8d 56 01             	lea    0x1(%esi),%edx
    254a:	ee                   	out    %al,(%dx)
 *
 */

static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	if (!(key & 0x200)) {
    254b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    254e:	0f ba e0 09          	bt     $0x9,%eax
    2552:	73 01                	jae    2555 <uart_ns16550_init+0x95>
	__asm__ volatile (
    2554:	fb                   	sti    

	irq_unlock(old_level);

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	DEV_CFG(dev)->irq_config_func(dev);
    2555:	8b 01                	mov    (%ecx),%eax
    2557:	8b 40 08             	mov    0x8(%eax),%eax
    255a:	51                   	push   %ecx
    255b:	ff 50 04             	call   *0x4(%eax)
    255e:	58                   	pop    %eax
#endif

	return 0;
}
    255f:	8d 65 f4             	lea    -0xc(%ebp),%esp
    2562:	31 c0                	xor    %eax,%eax
    2564:	5b                   	pop    %ebx
    2565:	5e                   	pop    %esi
    2566:	5f                   	pop    %edi
    2567:	5d                   	pop    %ebp
    2568:	c3                   	ret    

00002569 <uart_ns16550_poll_in>:
 * @param c Pointer to character
 *
 * @return 0 if a character arrived, -1 if the input buffer if empty.
 */
static int uart_ns16550_poll_in(struct device *dev, unsigned char *c)
{
    2569:	55                   	push   %ebp
    256a:	89 e5                	mov    %esp,%ebp
	if ((INBYTE(LSR(dev)) & LSR_RXRDY) == 0x00)
    256c:	8b 45 08             	mov    0x8(%ebp),%eax
    256f:	8b 40 08             	mov    0x8(%eax),%eax
    2572:	8b 08                	mov    (%eax),%ecx
    2574:	8d 51 05             	lea    0x5(%ecx),%edx
	__asm__ volatile("inb	%w1, %b0;\n\t"
    2577:	ec                   	in     (%dx),%al
    2578:	88 c2                	mov    %al,%dl
    257a:	80 e2 01             	and    $0x1,%dl
    257d:	74 0c                	je     258b <uart_ns16550_poll_in+0x22>
    257f:	89 ca                	mov    %ecx,%edx
    2581:	ec                   	in     (%dx),%al
		return (-1);

	/* got a character */
	*c = INBYTE(RDR(dev));
    2582:	8b 55 0c             	mov    0xc(%ebp),%edx
    2585:	88 02                	mov    %al,(%edx)

	return 0;
    2587:	31 c0                	xor    %eax,%eax
    2589:	eb 03                	jmp    258e <uart_ns16550_poll_in+0x25>
    258b:	83 c8 ff             	or     $0xffffffff,%eax
}
    258e:	5d                   	pop    %ebp
    258f:	c3                   	ret    

00002590 <uart_ns16550_poll_out>:
 *
 * @return Sent character
 */
static unsigned char uart_ns16550_poll_out(struct device *dev,
					   unsigned char c)
{
    2590:	55                   	push   %ebp
    2591:	89 e5                	mov    %esp,%ebp
    2593:	53                   	push   %ebx
	/* wait for transmitter to ready to accept a character */
	while ((INBYTE(LSR(dev)) & LSR_TEMT) == 0)
    2594:	8b 45 08             	mov    0x8(%ebp),%eax
{
    2597:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	while ((INBYTE(LSR(dev)) & LSR_TEMT) == 0)
    259a:	8b 40 08             	mov    0x8(%eax),%eax
    259d:	8b 18                	mov    (%eax),%ebx
    259f:	8d 53 05             	lea    0x5(%ebx),%edx
    25a2:	ec                   	in     (%dx),%al
    25a3:	a8 40                	test   $0x40,%al
    25a5:	74 fb                	je     25a2 <uart_ns16550_poll_out+0x12>
	__asm__ volatile("outb	%b0, %w1;\n\t"
    25a7:	88 c8                	mov    %cl,%al
    25a9:	89 da                	mov    %ebx,%edx
    25ab:	ee                   	out    %al,(%dx)
		;

	OUTBYTE(THR(dev), c);

	return c;
}
    25ac:	5b                   	pop    %ebx
    25ad:	5d                   	pop    %ebp
    25ae:	c3                   	ret    

000025af <uart_ns16550_err_check>:
 *
 * @return one of UART_ERROR_OVERRUN, UART_ERROR_PARITY, UART_ERROR_FRAMING,
 * UART_ERROR_BREAK if an error was detected, 0 otherwise.
 */
static int uart_ns16550_err_check(struct device *dev)
{
    25af:	55                   	push   %ebp
    25b0:	89 e5                	mov    %esp,%ebp
	return (INBYTE(LSR(dev)) & LSR_EOB_MASK) >> 1;
    25b2:	8b 45 08             	mov    0x8(%ebp),%eax
    25b5:	8b 40 08             	mov    0x8(%eax),%eax
    25b8:	8b 00                	mov    (%eax),%eax
    25ba:	8d 50 05             	lea    0x5(%eax),%edx
	__asm__ volatile("inb	%w1, %b0;\n\t"
    25bd:	ec                   	in     (%dx),%al
    25be:	d1 e8                	shr    %eax
}
    25c0:	5d                   	pop    %ebp
	return (INBYTE(LSR(dev)) & LSR_EOB_MASK) >> 1;
    25c1:	83 e0 0f             	and    $0xf,%eax
}
    25c4:	c3                   	ret    

000025c5 <uart_ns16550_fifo_fill>:
 *
 * @return Number of bytes sent
 */
static int uart_ns16550_fifo_fill(struct device *dev, const u8_t *tx_data,
				  int size)
{
    25c5:	55                   	push   %ebp
	int i;

	for (i = 0; i < size && (INBYTE(LSR(dev)) & LSR_THRE) != 0; i++) {
    25c6:	31 c9                	xor    %ecx,%ecx
{
    25c8:	89 e5                	mov    %esp,%ebp
    25ca:	57                   	push   %edi
    25cb:	56                   	push   %esi
    25cc:	53                   	push   %ebx
    25cd:	8b 75 08             	mov    0x8(%ebp),%esi
    25d0:	8b 7d 0c             	mov    0xc(%ebp),%edi
	for (i = 0; i < size && (INBYTE(LSR(dev)) & LSR_THRE) != 0; i++) {
    25d3:	3b 4d 10             	cmp    0x10(%ebp),%ecx
    25d6:	7d 16                	jge    25ee <uart_ns16550_fifo_fill+0x29>
    25d8:	8b 46 08             	mov    0x8(%esi),%eax
    25db:	8b 18                	mov    (%eax),%ebx
    25dd:	8d 53 05             	lea    0x5(%ebx),%edx
    25e0:	ec                   	in     (%dx),%al
    25e1:	a8 20                	test   $0x20,%al
    25e3:	74 09                	je     25ee <uart_ns16550_fifo_fill+0x29>
	__asm__ volatile("outb	%b0, %w1;\n\t"
    25e5:	8a 04 0f             	mov    (%edi,%ecx,1),%al
    25e8:	89 da                	mov    %ebx,%edx
    25ea:	ee                   	out    %al,(%dx)
    25eb:	41                   	inc    %ecx
    25ec:	eb e5                	jmp    25d3 <uart_ns16550_fifo_fill+0xe>
		OUTBYTE(THR(dev), tx_data[i]);
	}
	return i;
}
    25ee:	5b                   	pop    %ebx
    25ef:	89 c8                	mov    %ecx,%eax
    25f1:	5e                   	pop    %esi
    25f2:	5f                   	pop    %edi
    25f3:	5d                   	pop    %ebp
    25f4:	c3                   	ret    

000025f5 <uart_ns16550_fifo_read>:
 *
 * @return Number of bytes read
 */
static int uart_ns16550_fifo_read(struct device *dev, u8_t *rx_data,
				  const int size)
{
    25f5:	55                   	push   %ebp
	int i;

	for (i = 0; i < size && (INBYTE(LSR(dev)) & LSR_RXRDY) != 0; i++) {
    25f6:	31 c9                	xor    %ecx,%ecx
{
    25f8:	89 e5                	mov    %esp,%ebp
    25fa:	56                   	push   %esi
    25fb:	53                   	push   %ebx
    25fc:	8b 75 08             	mov    0x8(%ebp),%esi
	for (i = 0; i < size && (INBYTE(LSR(dev)) & LSR_RXRDY) != 0; i++) {
    25ff:	3b 4d 10             	cmp    0x10(%ebp),%ecx
    2602:	7d 19                	jge    261d <uart_ns16550_fifo_read+0x28>
    2604:	8b 46 08             	mov    0x8(%esi),%eax
    2607:	8b 18                	mov    (%eax),%ebx
    2609:	8d 53 05             	lea    0x5(%ebx),%edx
	__asm__ volatile("inb	%w1, %b0;\n\t"
    260c:	ec                   	in     (%dx),%al
    260d:	a8 01                	test   $0x1,%al
    260f:	74 0c                	je     261d <uart_ns16550_fifo_read+0x28>
    2611:	89 da                	mov    %ebx,%edx
    2613:	ec                   	in     (%dx),%al
		rx_data[i] = INBYTE(RDR(dev));
    2614:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    2617:	88 04 0b             	mov    %al,(%ebx,%ecx,1)
	for (i = 0; i < size && (INBYTE(LSR(dev)) & LSR_RXRDY) != 0; i++) {
    261a:	41                   	inc    %ecx
    261b:	eb e2                	jmp    25ff <uart_ns16550_fifo_read+0xa>
	}

	return i;
}
    261d:	5b                   	pop    %ebx
    261e:	89 c8                	mov    %ecx,%eax
    2620:	5e                   	pop    %esi
    2621:	5d                   	pop    %ebp
    2622:	c3                   	ret    

00002623 <uart_ns16550_irq_tx_enable>:
 * @param dev UART device struct
 *
 * @return N/A
 */
static void uart_ns16550_irq_tx_enable(struct device *dev)
{
    2623:	55                   	push   %ebp
    2624:	89 e5                	mov    %esp,%ebp
	OUTBYTE(IER(dev), INBYTE(IER(dev)) | IER_TBE);
    2626:	8b 45 08             	mov    0x8(%ebp),%eax
    2629:	8b 40 08             	mov    0x8(%eax),%eax
    262c:	8b 10                	mov    (%eax),%edx
    262e:	42                   	inc    %edx
    262f:	ec                   	in     (%dx),%al
    2630:	83 c8 02             	or     $0x2,%eax
	__asm__ volatile("outb	%b0, %w1;\n\t"
    2633:	ee                   	out    %al,(%dx)
}
    2634:	5d                   	pop    %ebp
    2635:	c3                   	ret    

00002636 <uart_ns16550_irq_tx_disable>:
 * @param dev UART device struct
 *
 * @return N/A
 */
static void uart_ns16550_irq_tx_disable(struct device *dev)
{
    2636:	55                   	push   %ebp
    2637:	89 e5                	mov    %esp,%ebp
	OUTBYTE(IER(dev), INBYTE(IER(dev)) & (~IER_TBE));
    2639:	8b 45 08             	mov    0x8(%ebp),%eax
    263c:	8b 40 08             	mov    0x8(%eax),%eax
    263f:	8b 10                	mov    (%eax),%edx
    2641:	42                   	inc    %edx
	__asm__ volatile("inb	%w1, %b0;\n\t"
    2642:	ec                   	in     (%dx),%al
	__asm__ volatile("outb	%b0, %w1;\n\t"
    2643:	83 e0 fd             	and    $0xfffffffd,%eax
    2646:	ee                   	out    %al,(%dx)
}
    2647:	5d                   	pop    %ebp
    2648:	c3                   	ret    

00002649 <uart_ns16550_irq_tx_ready>:
 * @param dev UART device struct
 *
 * @return 1 if an IRQ is ready, 0 otherwise
 */
static int uart_ns16550_irq_tx_ready(struct device *dev)
{
    2649:	55                   	push   %ebp
    264a:	89 e5                	mov    %esp,%ebp
	return ((IIRC(dev) & IIR_ID) == IIR_THRE);
    264c:	8b 45 08             	mov    0x8(%ebp),%eax
}
    264f:	5d                   	pop    %ebp
	return ((IIRC(dev) & IIR_ID) == IIR_THRE);
    2650:	8b 40 08             	mov    0x8(%eax),%eax
    2653:	8a 40 09             	mov    0x9(%eax),%al
    2656:	83 e0 06             	and    $0x6,%eax
    2659:	3c 02                	cmp    $0x2,%al
    265b:	0f 94 c0             	sete   %al
    265e:	0f b6 c0             	movzbl %al,%eax
}
    2661:	c3                   	ret    

00002662 <uart_ns16550_irq_tx_complete>:
 * @param dev UART device struct
 *
 * @return 1 if nothing remains to be transmitted, 0 otherwise
 */
static int uart_ns16550_irq_tx_complete(struct device *dev)
{
    2662:	55                   	push   %ebp
    2663:	89 e5                	mov    %esp,%ebp
	return (INBYTE(LSR(dev)) & (LSR_TEMT | LSR_THRE)) == (LSR_TEMT | LSR_THRE);
    2665:	8b 45 08             	mov    0x8(%ebp),%eax
    2668:	8b 40 08             	mov    0x8(%eax),%eax
    266b:	8b 00                	mov    (%eax),%eax
    266d:	8d 50 05             	lea    0x5(%eax),%edx
	__asm__ volatile("inb	%w1, %b0;\n\t"
    2670:	ec                   	in     (%dx),%al
    2671:	83 e0 60             	and    $0x60,%eax
}
    2674:	5d                   	pop    %ebp
	return (INBYTE(LSR(dev)) & (LSR_TEMT | LSR_THRE)) == (LSR_TEMT | LSR_THRE);
    2675:	3c 60                	cmp    $0x60,%al
    2677:	0f 94 c0             	sete   %al
    267a:	0f b6 c0             	movzbl %al,%eax
}
    267d:	c3                   	ret    

0000267e <uart_ns16550_irq_rx_enable>:
 * @param dev UART device struct
 *
 * @return N/A
 */
static void uart_ns16550_irq_rx_enable(struct device *dev)
{
    267e:	55                   	push   %ebp
    267f:	89 e5                	mov    %esp,%ebp
	OUTBYTE(IER(dev), INBYTE(IER(dev)) | IER_RXRDY);
    2681:	8b 45 08             	mov    0x8(%ebp),%eax
    2684:	8b 40 08             	mov    0x8(%eax),%eax
    2687:	8b 10                	mov    (%eax),%edx
    2689:	42                   	inc    %edx
    268a:	ec                   	in     (%dx),%al
    268b:	83 c8 01             	or     $0x1,%eax
	__asm__ volatile("outb	%b0, %w1;\n\t"
    268e:	ee                   	out    %al,(%dx)
}
    268f:	5d                   	pop    %ebp
    2690:	c3                   	ret    

00002691 <uart_ns16550_irq_rx_disable>:
 * @param dev UART device struct
 *
 * @return N/A
 */
static void uart_ns16550_irq_rx_disable(struct device *dev)
{
    2691:	55                   	push   %ebp
    2692:	89 e5                	mov    %esp,%ebp
	OUTBYTE(IER(dev), INBYTE(IER(dev)) & (~IER_RXRDY));
    2694:	8b 45 08             	mov    0x8(%ebp),%eax
    2697:	8b 40 08             	mov    0x8(%eax),%eax
    269a:	8b 10                	mov    (%eax),%edx
    269c:	42                   	inc    %edx
	__asm__ volatile("inb	%w1, %b0;\n\t"
    269d:	ec                   	in     (%dx),%al
	__asm__ volatile("outb	%b0, %w1;\n\t"
    269e:	83 e0 fe             	and    $0xfffffffe,%eax
    26a1:	ee                   	out    %al,(%dx)
}
    26a2:	5d                   	pop    %ebp
    26a3:	c3                   	ret    

000026a4 <uart_ns16550_irq_rx_ready>:
 * @param dev UART device struct
 *
 * @return 1 if an IRQ is ready, 0 otherwise
 */
static int uart_ns16550_irq_rx_ready(struct device *dev)
{
    26a4:	55                   	push   %ebp
    26a5:	89 e5                	mov    %esp,%ebp
	return ((IIRC(dev) & IIR_ID) == IIR_RBRF);
    26a7:	8b 45 08             	mov    0x8(%ebp),%eax
}
    26aa:	5d                   	pop    %ebp
	return ((IIRC(dev) & IIR_ID) == IIR_RBRF);
    26ab:	8b 40 08             	mov    0x8(%eax),%eax
    26ae:	8a 40 09             	mov    0x9(%eax),%al
    26b1:	83 e0 06             	and    $0x6,%eax
    26b4:	3c 04                	cmp    $0x4,%al
    26b6:	0f 94 c0             	sete   %al
    26b9:	0f b6 c0             	movzbl %al,%eax
}
    26bc:	c3                   	ret    

000026bd <uart_ns16550_irq_err_enable>:
 * @param dev UART device struct
 *
 * @return N/A
 */
static void uart_ns16550_irq_err_enable(struct device *dev)
{
    26bd:	55                   	push   %ebp
    26be:	89 e5                	mov    %esp,%ebp
	OUTBYTE(IER(dev), INBYTE(IER(dev)) | IER_LSR);
    26c0:	8b 45 08             	mov    0x8(%ebp),%eax
    26c3:	8b 40 08             	mov    0x8(%eax),%eax
    26c6:	8b 10                	mov    (%eax),%edx
    26c8:	42                   	inc    %edx
	__asm__ volatile("inb	%w1, %b0;\n\t"
    26c9:	ec                   	in     (%dx),%al
    26ca:	83 c8 04             	or     $0x4,%eax
	__asm__ volatile("outb	%b0, %w1;\n\t"
    26cd:	ee                   	out    %al,(%dx)
}
    26ce:	5d                   	pop    %ebp
    26cf:	c3                   	ret    

000026d0 <uart_ns16550_irq_err_disable>:
 * @param dev UART device struct
 *
 * @return 1 if an IRQ is ready, 0 otherwise
 */
static void uart_ns16550_irq_err_disable(struct device *dev)
{
    26d0:	55                   	push   %ebp
    26d1:	89 e5                	mov    %esp,%ebp
	OUTBYTE(IER(dev), INBYTE(IER(dev)) & (~IER_LSR));
    26d3:	8b 45 08             	mov    0x8(%ebp),%eax
    26d6:	8b 40 08             	mov    0x8(%eax),%eax
    26d9:	8b 10                	mov    (%eax),%edx
    26db:	42                   	inc    %edx
	__asm__ volatile("inb	%w1, %b0;\n\t"
    26dc:	ec                   	in     (%dx),%al
	__asm__ volatile("outb	%b0, %w1;\n\t"
    26dd:	83 e0 fb             	and    $0xfffffffb,%eax
    26e0:	ee                   	out    %al,(%dx)
}
    26e1:	5d                   	pop    %ebp
    26e2:	c3                   	ret    

000026e3 <uart_ns16550_irq_is_pending>:
 * @param dev UART device struct
 *
 * @return 1 if an IRQ is pending, 0 otherwise
 */
static int uart_ns16550_irq_is_pending(struct device *dev)
{
    26e3:	55                   	push   %ebp
    26e4:	89 e5                	mov    %esp,%ebp
	return (!(IIRC(dev) & IIR_NIP));
    26e6:	8b 45 08             	mov    0x8(%ebp),%eax
}
    26e9:	5d                   	pop    %ebp
	return (!(IIRC(dev) & IIR_NIP));
    26ea:	8b 40 08             	mov    0x8(%eax),%eax
    26ed:	8a 40 09             	mov    0x9(%eax),%al
    26f0:	f7 d0                	not    %eax
    26f2:	83 e0 01             	and    $0x1,%eax
}
    26f5:	c3                   	ret    

000026f6 <uart_ns16550_irq_update>:
 * @param dev UART device struct
 *
 * @return Always 1
 */
static int uart_ns16550_irq_update(struct device *dev)
{
    26f6:	55                   	push   %ebp
    26f7:	89 e5                	mov    %esp,%ebp
	IIRC(dev) = INBYTE(IIR(dev));
    26f9:	8b 45 08             	mov    0x8(%ebp),%eax
    26fc:	8b 48 08             	mov    0x8(%eax),%ecx
    26ff:	8b 01                	mov    (%ecx),%eax
    2701:	8d 50 02             	lea    0x2(%eax),%edx
	__asm__ volatile("inb	%w1, %b0;\n\t"
    2704:	ec                   	in     (%dx),%al
    2705:	88 41 09             	mov    %al,0x9(%ecx)

	return 1;
}
    2708:	b8 01 00 00 00       	mov    $0x1,%eax
    270d:	5d                   	pop    %ebp
    270e:	c3                   	ret    

0000270f <uart_ns16550_irq_callback_set>:
 *
 * @return N/A
 */
static void uart_ns16550_irq_callback_set(struct device *dev,
					  uart_irq_callback_t cb)
{
    270f:	55                   	push   %ebp
    2710:	89 e5                	mov    %esp,%ebp
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);

	dev_data->cb = cb;
    2712:	8b 45 08             	mov    0x8(%ebp),%eax
    2715:	8b 55 0c             	mov    0xc(%ebp),%edx
    2718:	8b 40 08             	mov    0x8(%eax),%eax
    271b:	89 50 0c             	mov    %edx,0xc(%eax)
}
    271e:	5d                   	pop    %ebp
    271f:	c3                   	ret    

00002720 <uart_ns16550_isr>:
 * @param arg Argument to ISR.
 *
 * @return N/A
 */
static void uart_ns16550_isr(void *arg)
{
    2720:	55                   	push   %ebp
    2721:	89 e5                	mov    %esp,%ebp
    2723:	8b 55 08             	mov    0x8(%ebp),%edx
	struct device *dev = arg;
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);

	if (dev_data->cb) {
    2726:	8b 42 08             	mov    0x8(%edx),%eax
    2729:	8b 40 0c             	mov    0xc(%eax),%eax
    272c:	85 c0                	test   %eax,%eax
    272e:	74 03                	je     2733 <uart_ns16550_isr+0x13>
		dev_data->cb(dev);
	}
}
    2730:	5d                   	pop    %ebp
		dev_data->cb(dev);
    2731:	ff e0                	jmp    *%eax
}
    2733:	5d                   	pop    %ebp
    2734:	c3                   	ret    

00002735 <irq_config_func_0>:
		    PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEVICE,
		    &uart_ns16550_driver_api);

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
static void irq_config_func_0(struct device *dev)
{
    2735:	55                   	push   %ebp
    2736:	89 e5                	mov    %esp,%ebp
    2738:	0f b6 05 14 83 00 00 	movzbl 0x8314,%eax
 * @returns: N/A
 */
static inline void _irq_controller_irq_config(unsigned int vector,
					      unsigned int irq, u32_t flags)
{
	__irq_controller_irq_config(vector, irq, flags);
    273f:	6a 00                	push   $0x0
    2741:	6a 04                	push   $0x4
    2743:	50                   	push   %eax
    2744:	e8 e5 02 00 00       	call   2a2e <__irq_controller_irq_config>
    2749:	83 c4 0c             	add    $0xc,%esp

	IRQ_CONNECT(UART_NS16550_PORT_0_IRQ,
		    CONFIG_UART_NS16550_PORT_0_IRQ_PRI,
		    uart_ns16550_isr, DEVICE_GET(uart_ns16550_0),
		    UART_IRQ_FLAGS);
	irq_enable(UART_NS16550_PORT_0_IRQ);
    274c:	c7 45 08 04 00 00 00 	movl   $0x4,0x8(%ebp)
}
    2753:	c9                   	leave  
	irq_enable(UART_NS16550_PORT_0_IRQ);
    2754:	e9 fb 02 00 00       	jmp    2a54 <_arch_irq_enable>

00002759 <uart_ns16550_isr_irq4_stub>:
	IRQ_CONNECT(UART_NS16550_PORT_0_IRQ,
    2759:	68 48 50 40 00       	push   $0x405048
    275e:	68 20 27 00 00       	push   $0x2720
    2763:	e9 93 33 00 00       	jmp    5afb <_interrupt_enter>

00002768 <uart_ns16550_isr_irq3_stub>:
#ifdef CONFIG_UART_INTERRUPT_DRIVEN
static void irq_config_func_1(struct device *dev)
{
	ARG_UNUSED(dev);

	IRQ_CONNECT(UART_NS16550_PORT_1_IRQ,
    2768:	68 3c 50 40 00       	push   $0x40503c
    276d:	68 20 27 00 00       	push   $0x2720
    2772:	e9 84 33 00 00       	jmp    5afb <_interrupt_enter>

00002777 <_timer_int_handler_irq2_stub>:
    2777:	6a 00                	push   $0x0
    2779:	68 a7 27 00 00       	push   $0x27a7
    277e:	e9 78 33 00 00       	jmp    5afb <_interrupt_enter>

00002783 <irq_config_func_1>:
{
    2783:	55                   	push   %ebp
    2784:	89 e5                	mov    %esp,%ebp
    2786:	0f b6 05 13 83 00 00 	movzbl 0x8313,%eax
    278d:	6a 00                	push   $0x0
    278f:	6a 03                	push   $0x3
    2791:	50                   	push   %eax
    2792:	e8 97 02 00 00       	call   2a2e <__irq_controller_irq_config>
    2797:	83 c4 0c             	add    $0xc,%esp
		    CONFIG_UART_NS16550_PORT_1_IRQ_PRI,
		    uart_ns16550_isr, DEVICE_GET(uart_ns16550_1),
		    UART_IRQ_FLAGS);
	irq_enable(UART_NS16550_PORT_1_IRQ);
    279a:	c7 45 08 03 00 00 00 	movl   $0x3,0x8(%ebp)
}
    27a1:	c9                   	leave  
	irq_enable(UART_NS16550_PORT_1_IRQ);
    27a2:	e9 ad 02 00 00       	jmp    2a54 <_arch_irq_enable>

000027a7 <_timer_int_handler>:
 * is pushed onto the kernel stack.
 *
 * @return N/A
 */
void _timer_int_handler(void *unused)
{
    27a7:	55                   	push   %ebp
	/*
	 * one more tick has occurred -- don't need to do anything special since
	 * timer is already configured to interrupt on the following tick
	 */

	_sys_clock_tick_announce();
    27a8:	a1 04 01 40 00       	mov    0x400104,%eax
{
    27ad:	89 e5                	mov    %esp,%ebp
	_sys_clock_tick_announce();
    27af:	89 45 08             	mov    %eax,0x8(%ebp)
	programmed_ticks = 1;
	_sys_clock_final_tick_announce();
#endif
#endif /* !CONFIG_TICKLESS_IDLE */

}
    27b2:	5d                   	pop    %ebp
	_sys_clock_tick_announce();
    27b3:	e9 d8 46 00 00       	jmp    6e90 <_nano_sys_clock_tick_announce>

000027b8 <_sys_clock_driver_init>:
 *
 * @return 0
 */

int _sys_clock_driver_init(struct device *device)
{
    27b8:	55                   	push   %ebp
    27b9:	89 e5                	mov    %esp,%ebp
    27bb:	57                   	push   %edi
    27bc:	56                   	push   %esi
    27bd:	53                   	push   %ebx
	/*
	 * Initial state of HPET is unknown, so put it back in a reset-like
	 * state (i.e. set main counter to 0 and disable interrupts)
	 */

	*_HPET_GENERAL_CONFIG &= ~HPET_ENABLE_CNF;
    27be:	a1 10 00 d0 fe       	mov    0xfed00010,%eax
	/*
	 * Convert the 'sys_clock_us_per_tick' value
	 * from microseconds to femptoseconds
	 */

	tickFempto = (u64_t)sys_clock_us_per_tick * 1000000000;
    27c3:	be 00 ca 9a 3b       	mov    $0x3b9aca00,%esi
	*_HPET_GENERAL_CONFIG &= ~HPET_ENABLE_CNF;
    27c8:	83 e0 fe             	and    $0xfffffffe,%eax
    27cb:	a3 10 00 d0 fe       	mov    %eax,0xfed00010
	*_HPET_MAIN_COUNTER_VALUE = 0;
    27d0:	c7 05 f0 00 d0 fe 00 	movl   $0x0,0xfed000f0
    27d7:	00 00 00 
	tickFempto = (u64_t)sys_clock_us_per_tick * 1000000000;
    27da:	89 f0                	mov    %esi,%eax
	*_HPET_MAIN_COUNTER_VALUE = 0;
    27dc:	c7 05 f4 00 d0 fe 00 	movl   $0x0,0xfed000f4
    27e3:	00 00 00 
	tickFempto = (u64_t)sys_clock_us_per_tick * 1000000000;
    27e6:	f7 2d 10 01 40 00    	imull  0x400110
	 * to determine the frequency of clock applied to the HPET device.
	 */

	/* read the clock period: units are fempto (10^-15) seconds */

	hpetClockPeriod = HPET_COUNTER_CLK_PERIOD(*_HPET_GENERAL_CAPS);
    27ec:	8b 0d 00 00 d0 fe    	mov    0xfed00000,%ecx
    27f2:	8b 1d 04 00 d0 fe    	mov    0xfed00004,%ebx
    27f8:	89 d9                	mov    %ebx,%ecx
    27fa:	31 db                	xor    %ebx,%ebx
	/*
	 * compute value for the comparator register to achieve
	 * 'sys_clock_us_per_tick' period
	 */

	counter_load_value = (u32_t)(tickFempto / hpetClockPeriod);
    27fc:	53                   	push   %ebx
    27fd:	51                   	push   %ecx
    27fe:	52                   	push   %edx
    27ff:	50                   	push   %eax
    2800:	e8 cb e8 ff ff       	call   10d0 <__udivdi3>
    2805:	31 db                	xor    %ebx,%ebx
	       (u32_t)(*_HPET_TIMER0_CONFIG_CAPS >> 32));

	/* Initialize sys_clock_hw_cycles_per_tick/sec */

	sys_clock_hw_cycles_per_tick = counter_load_value;
	sys_clock_hw_cycles_per_sec = sys_clock_hw_cycles_per_tick *
    2807:	6b d0 64             	imul   $0x64,%eax,%edx
	sys_clock_hw_cycles_per_tick = counter_load_value;
    280a:	a3 0c 01 40 00       	mov    %eax,0x40010c
	sys_clock_hw_cycles_per_sec = sys_clock_hw_cycles_per_tick *
    280f:	89 15 08 01 40 00    	mov    %edx,0x400108
	/*
	 * Configure HPET replace legacy 8254 timer.
	 * In this case the timer0 interrupt is routed to IRQ2
	 * and legacy timer generates no interrupts
	 */
	*_HPET_GENERAL_CONFIG |= HPET_LEGACY_RT_CNF;
    2815:	8b 15 10 00 d0 fe    	mov    0xfed00010,%edx
	counter_load_value = (u32_t)(tickFempto / hpetClockPeriod);
    281b:	83 c4 10             	add    $0x10,%esp
	*_HPET_GENERAL_CONFIG |= HPET_LEGACY_RT_CNF;
    281e:	83 ca 02             	or     $0x2,%edx
    2821:	89 15 10 00 d0 fe    	mov    %edx,0xfed00010
	 * Setting 32-bit mode during the first load of the comparator
	 * value is required to work around some hardware that otherwise
	 * does not work properly.
	 */

	*_HPET_TIMER0_CONFIG_CAPS |= HPET_Tn_TYPE_CNF | HPET_Tn_32MODE_CNF;
    2827:	8b 35 00 01 d0 fe    	mov    0xfed00100,%esi
    282d:	8b 3d 04 01 d0 fe    	mov    0xfed00104,%edi
    2833:	89 f2                	mov    %esi,%edx
    2835:	81 ca 08 01 00 00    	or     $0x108,%edx
    283b:	89 15 00 01 d0 fe    	mov    %edx,0xfed00100
    2841:	89 3d 04 01 d0 fe    	mov    %edi,0xfed00104

	/*
	 * Set the comparator register for timer0.  The write to the comparator
	 * register is allowed due to setting the HPET_Tn_VAL_SET_CNF bit.
	 */
	*_HPET_TIMER0_CONFIG_CAPS |= HPET_Tn_VAL_SET_CNF;
    2847:	8b 35 00 01 d0 fe    	mov    0xfed00100,%esi
    284d:	8b 3d 04 01 d0 fe    	mov    0xfed00104,%edi
    2853:	89 f2                	mov    %esi,%edx
    2855:	83 ca 40             	or     $0x40,%edx
    2858:	89 15 00 01 d0 fe    	mov    %edx,0xfed00100
    285e:	89 3d 04 01 d0 fe    	mov    %edi,0xfed00104
	*_HPET_TIMER0_COMPARATOR = counter_load_value;
    2864:	a3 08 01 d0 fe       	mov    %eax,0xfed00108
    2869:	89 1d 0c 01 d0 fe    	mov    %ebx,0xfed0010c
	/*
	 * After the comparator is loaded, 32-bit mode can be safely
	 * switched off
	 */
	*_HPET_TIMER0_CONFIG_CAPS &= ~HPET_Tn_32MODE_CNF;
    286f:	8b 0d 00 01 d0 fe    	mov    0xfed00100,%ecx
    2875:	8b 1d 04 01 d0 fe    	mov    0xfed00104,%ebx
    287b:	89 cf                	mov    %ecx,%edi
    287d:	81 e7 ff fe ff ff    	and    $0xfffffeff,%edi
    2883:	89 3d 00 01 d0 fe    	mov    %edi,0xfed00100
    2889:	89 1d 04 01 d0 fe    	mov    %ebx,0xfed00104
	 * this case program leaves the IRQ fields blank.
	 */

	*_HPET_TIMER0_CONFIG_CAPS =
#if CONFIG_HPET_TIMER_IRQ < 32
		(*_HPET_TIMER0_CONFIG_CAPS & ~HPET_Tn_INT_ROUTE_CNF_MASK) |
    288f:	a1 00 01 d0 fe       	mov    0xfed00100,%eax
    2894:	8b 15 04 01 d0 fe    	mov    0xfed00104,%edx
    289a:	89 c3                	mov    %eax,%ebx
    289c:	80 e7 c1             	and    $0xc1,%bh
    289f:	80 cf 04             	or     $0x4,%bh
	*_HPET_TIMER0_CONFIG_CAPS =
    28a2:	89 1d 00 01 d0 fe    	mov    %ebx,0xfed00100
    28a8:	89 15 04 01 d0 fe    	mov    %edx,0xfed00104
    28ae:	0f b6 05 12 83 00 00 	movzbl 0x8312,%eax
    28b5:	6a 00                	push   $0x0
    28b7:	6a 02                	push   $0x2
    28b9:	50                   	push   %eax
    28ba:	e8 6f 01 00 00       	call   2a2e <__irq_controller_irq_config>
    28bf:	83 c4 0c             	add    $0xc,%esp
	IRQ_CONNECT(CONFIG_HPET_TIMER_IRQ, CONFIG_HPET_TIMER_IRQ_PRIORITY,
		   _timer_int_handler, 0, HPET_IOAPIC_FLAGS);

	/* enable the IRQ in the interrupt controller */

	irq_enable(CONFIG_HPET_TIMER_IRQ);
    28c2:	6a 02                	push   $0x2
    28c4:	e8 8b 01 00 00       	call   2a54 <_arch_irq_enable>
    28c9:	58                   	pop    %eax

	/* enable the HPET generally, and timer0 specifically */

	*_HPET_GENERAL_CONFIG |= HPET_ENABLE_CNF;
    28ca:	a1 10 00 d0 fe       	mov    0xfed00010,%eax
    28cf:	83 c8 01             	or     $0x1,%eax
    28d2:	a3 10 00 d0 fe       	mov    %eax,0xfed00010
	*_HPET_TIMER0_CONFIG_CAPS |= HPET_Tn_INT_ENB_CNF;

	return 0;
}
    28d7:	31 c0                	xor    %eax,%eax
	*_HPET_TIMER0_CONFIG_CAPS |= HPET_Tn_INT_ENB_CNF;
    28d9:	8b 0d 00 01 d0 fe    	mov    0xfed00100,%ecx
    28df:	8b 1d 04 01 d0 fe    	mov    0xfed00104,%ebx
    28e5:	89 cf                	mov    %ecx,%edi
    28e7:	83 cf 04             	or     $0x4,%edi
    28ea:	89 3d 00 01 d0 fe    	mov    %edi,0xfed00100
    28f0:	89 1d 04 01 d0 fe    	mov    %ebx,0xfed00104
}
    28f6:	8d 65 f4             	lea    -0xc(%ebp),%esp
    28f9:	5b                   	pop    %ebx
    28fa:	5e                   	pop    %esi
    28fb:	5f                   	pop    %edi
    28fc:	5d                   	pop    %ebp
    28fd:	c3                   	ret    

000028fe <_i8259_init>:
 *
 * @return N/A
 */

int _i8259_init(struct device *unused)
{
    28fe:	55                   	push   %ebp
	__asm__ volatile("outb	%b0, %w1;\n\t"
    28ff:	b0 ff                	mov    $0xff,%al
    2901:	89 e5                	mov    %esp,%ebp
    2903:	e6 a1                	out    %al,$0xa1
    2905:	e6 21                	out    %al,$0x21
	ARG_UNUSED(unused);
	sys_out8(PIC_DISABLE, PIC_PORT2(PIC_SLAVE_BASE_ADRS));
	sys_out8(PIC_DISABLE, PIC_PORT2(PIC_MASTER_BASE_ADRS));
	return 0;
}
    2907:	31 c0                	xor    %eax,%eax
    2909:	5d                   	pop    %ebp
    290a:	c3                   	ret    

0000290b <_loapic_init>:
 * @return N/A
 *
 */

static int _loapic_init(struct device *unused)
{
    290b:	55                   	push   %ebp
    290c:	89 e5                	mov    %esp,%ebp
static ALWAYS_INLINE
	u32_t sys_read32(mm_reg_t addr)
{
	u32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
    290e:	a1 f0 00 e0 fe       	mov    0xfee000f0,%eax
	ARG_UNUSED(unused);
	s32_t loApicMaxLvt; /* local APIC Max LVT */

	/* enable the Local APIC */
	sys_write32(sys_read32(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_SVR)
    2913:	80 cc 01             	or     $0x1,%ah
	__asm__ volatile("movl	%0, %1;\n\t"
    2916:	a3 f0 00 e0 fe       	mov    %eax,0xfee000f0
		    | LOAPIC_ENABLE, CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_SVR);

	loApicMaxLvt = (*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_VER) &
    291b:	a1 30 00 e0 fe       	mov    0xfee00030,%eax
			LOAPIC_MAXLVT_MASK) >> 16;

	/* reset the DFR, TPR, TIMER_CONFIG, and TIMER_ICR */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_DFR) =
    2920:	c7 05 e0 00 e0 fe ff 	movl   $0xffffffff,0xfee000e0
    2927:	ff ff ff 
			LOAPIC_MAXLVT_MASK) >> 16;
    292a:	c1 f8 10             	sar    $0x10,%eax
		(int)0xffffffff;
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TPR) = (int)0x0;
    292d:	c7 05 80 00 e0 fe 00 	movl   $0x0,0xfee00080
    2934:	00 00 00 
	*(volatile int *) (CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER_CONFIG) =
    2937:	c7 05 e0 03 e0 fe 00 	movl   $0x0,0xfee003e0
    293e:	00 00 00 
		(int)0x0;
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER_ICR) = (int)0x0;
    2941:	c7 05 80 03 e0 fe 00 	movl   $0x0,0xfee00380
    2948:	00 00 00 
	/* program Local Vector Table for the Virtual Wire Mode */

	/* set LINT0: extInt, high-polarity, edge-trigger, not-masked */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT0) =
		(*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT0) &
    294b:	8b 15 50 03 e0 fe    	mov    0xfee00350,%edx
    2951:	81 e2 ff 58 fe ff    	and    $0xfffe58ff,%edx
		 ~(LOAPIC_MODE | LOAPIC_LOW | LOAPIC_LEVEL | LOAPIC_LVT_MASKED)) |
    2957:	80 ce 07             	or     $0x7,%dh
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT0) =
    295a:	89 15 50 03 e0 fe    	mov    %edx,0xfee00350
		(LOAPIC_EXT | LOAPIC_HIGH | LOAPIC_EDGE);

	/* set LINT1: NMI, high-polarity, edge-trigger, not-masked */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT1) =
		(*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT1) &
    2960:	8b 15 60 03 e0 fe    	mov    0xfee00360,%edx
    2966:	81 e2 ff 58 fe ff    	and    $0xfffe58ff,%edx
		 ~(LOAPIC_MODE | LOAPIC_LOW | LOAPIC_LEVEL | LOAPIC_LVT_MASKED)) |
    296c:	80 ce 04             	or     $0x4,%dh
	loApicMaxLvt = (*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_VER) &
    296f:	0f b6 c0             	movzbl %al,%eax
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT1) =
    2972:	89 15 60 03 e0 fe    	mov    %edx,0xfee00360
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER) =
		LOAPIC_LVT_MASKED;
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_ERROR) =
		LOAPIC_LVT_MASKED;

	if (loApicMaxLvt >= LOAPIC_LVT_P6)
    2978:	83 f8 03             	cmp    $0x3,%eax
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER) =
    297b:	c7 05 20 03 e0 fe 00 	movl   $0x10000,0xfee00320
    2982:	00 01 00 
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_ERROR) =
    2985:	c7 05 70 03 e0 fe 00 	movl   $0x10000,0xfee00370
    298c:	00 01 00 
	if (loApicMaxLvt >= LOAPIC_LVT_P6)
    298f:	7e 19                	jle    29aa <_loapic_init+0x9f>
		*(volatile int *) (CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_PMC) =
    2991:	c7 05 40 03 e0 fe 00 	movl   $0x10000,0xfee00340
    2998:	00 01 00 
			LOAPIC_LVT_MASKED;

	if (loApicMaxLvt >= LOAPIC_LVT_PENTIUM4)
    299b:	83 f8 04             	cmp    $0x4,%eax
    299e:	74 0a                	je     29aa <_loapic_init+0x9f>
		*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_THERMAL) =
    29a0:	c7 05 30 03 e0 fe 00 	movl   $0x10000,0xfee00330
    29a7:	00 01 00 

	/* discard a pending interrupt if any */
#if CONFIG_EOI_FORWARDING_BUG
	_lakemont_eoi();
#else
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_EOI) = 0;
    29aa:	c7 05 b0 00 e0 fe 00 	movl   $0x0,0xfee000b0
    29b1:	00 00 00 
#endif

	return 0;
}
    29b4:	31 c0                	xor    %eax,%eax
    29b6:	5d                   	pop    %ebp
    29b7:	c3                   	ret    

000029b8 <_loapic_int_vec_set>:
 */

void _loapic_int_vec_set(unsigned int irq, /* IRQ number of the interrupt */
				  unsigned int vector /* vector to copy into the LVT */
				  )
{
    29b8:	55                   	push   %ebp
    29b9:	89 e5                	mov    %esp,%ebp
	 *
	 * It's assumed that LVTs are spaced by 0x10 bytes
	 */

	pLvt = (volatile int *)
			(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER + (irq * 0x10));
    29bb:	8b 45 08             	mov    0x8(%ebp),%eax
    29be:	05 32 00 ee 0f       	add    $0xfee0032,%eax
    29c3:	c1 e0 04             	shl    $0x4,%eax
	__asm__ volatile (
    29c6:	9c                   	pushf  
    29c7:	fa                   	cli    
    29c8:	59                   	pop    %ecx

	/* update the 'vector' bits in the LVT */

	oldLevel = irq_lock();
	*pLvt = (*pLvt & ~LOAPIC_VECTOR) | vector;
    29c9:	8b 10                	mov    (%eax),%edx
    29cb:	30 d2                	xor    %dl,%dl
    29cd:	0b 55 0c             	or     0xc(%ebp),%edx
    29d0:	0f ba e1 09          	bt     $0x9,%ecx
    29d4:	89 10                	mov    %edx,(%eax)
    29d6:	73 01                	jae    29d9 <_loapic_int_vec_set+0x21>
	__asm__ volatile (
    29d8:	fb                   	sti    
	irq_unlock(oldLevel);
}
    29d9:	5d                   	pop    %ebp
    29da:	c3                   	ret    

000029db <_loapic_irq_enable>:
 *
 * @return N/A
 */

void _loapic_irq_enable(unsigned int irq)
{
    29db:	55                   	push   %ebp
    29dc:	89 e5                	mov    %esp,%ebp
	 * See the comments in _LoApicLvtVecSet() regarding IRQ to LVT mappings
	 * and ths assumption concerning LVT spacing.
	 */

	pLvt = (volatile int *)
		(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER + (irq * 0x10));
    29de:	8b 45 08             	mov    0x8(%ebp),%eax
    29e1:	05 32 00 ee 0f       	add    $0xfee0032,%eax
    29e6:	c1 e0 04             	shl    $0x4,%eax
	__asm__ volatile (
    29e9:	9c                   	pushf  
    29ea:	fa                   	cli    
    29eb:	59                   	pop    %ecx

	/* clear the mask bit in the LVT */

	oldLevel = irq_lock();
	*pLvt = *pLvt & ~LOAPIC_LVT_MASKED;
    29ec:	8b 10                	mov    (%eax),%edx
    29ee:	81 e2 ff ff fe ff    	and    $0xfffeffff,%edx
    29f4:	0f ba e1 09          	bt     $0x9,%ecx
    29f8:	89 10                	mov    %edx,(%eax)
    29fa:	73 01                	jae    29fd <_loapic_irq_enable+0x22>
	__asm__ volatile (
    29fc:	fb                   	sti    
	irq_unlock(oldLevel);
}
    29fd:	5d                   	pop    %ebp
    29fe:	c3                   	ret    

000029ff <__irq_controller_isr_vector_get>:
 *
 * @return The vector of the interrupt that is currently being processed, or -1
 * if no IRQ is being serviced.
 */
int __irq_controller_isr_vector_get(void)
{
    29ff:	55                   	push   %ebp
    2a00:	b9 70 01 e0 fe       	mov    $0xfee00170,%ecx
    2a05:	89 e5                	mov    %esp,%ebp
	int pReg, block;

	/* Block 0 bits never lit up as these are all exception or reserved
	 * vectors
	 */
	for (block = 7; likely(block > 0); block--) {
    2a07:	b8 07 00 00 00       	mov    $0x7,%eax
	__asm__ volatile("movl	%1, %0;\n\t"
    2a0c:	8b 11                	mov    (%ecx),%edx
		pReg = sys_read32(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_ISR +
				  (block * 0x10));
		if (pReg) {
    2a0e:	85 d2                	test   %edx,%edx
    2a10:	74 11                	je     2a23 <__irq_controller_isr_vector_get+0x24>
	__asm__ volatile (
    2a12:	0f bd d2             	bsr    %edx,%edx
    2a15:	75 05                	jne    2a1c <__irq_controller_isr_vector_get+0x1d>
    2a17:	ba ff ff ff ff       	mov    $0xffffffff,%edx
			return (block * 32) + (find_msb_set(pReg) - 1);
    2a1c:	c1 e0 05             	shl    $0x5,%eax
    2a1f:	01 d0                	add    %edx,%eax
    2a21:	eb 09                	jmp    2a2c <__irq_controller_isr_vector_get+0x2d>
    2a23:	83 e9 10             	sub    $0x10,%ecx
	for (block = 7; likely(block > 0); block--) {
    2a26:	48                   	dec    %eax
    2a27:	75 e3                	jne    2a0c <__irq_controller_isr_vector_get+0xd>
		}

	}
	return -1;
    2a29:	83 c8 ff             	or     $0xffffffff,%eax
}
    2a2c:	5d                   	pop    %ebp
    2a2d:	c3                   	ret    

00002a2e <__irq_controller_irq_config>:
 * @param flags interrupt flags
 *
 */
void __irq_controller_irq_config(unsigned int vector, unsigned int irq,
				 u32_t flags)
{
    2a2e:	55                   	push   %ebp
    2a2f:	89 e5                	mov    %esp,%ebp
    2a31:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a34:	8b 55 08             	mov    0x8(%ebp),%edx
	__ASSERT(irq >= 0 && irq <= HARDWARE_IRQ_LIMIT, "invalid irq line");

	if (IS_IOAPIC_IRQ(irq)) {
		_ioapic_irq_set(irq, vector, flags);
    2a37:	89 55 0c             	mov    %edx,0xc(%ebp)
	if (IS_IOAPIC_IRQ(irq)) {
    2a3a:	83 f8 17             	cmp    $0x17,%eax
    2a3d:	77 09                	ja     2a48 <__irq_controller_irq_config+0x1a>
		_ioapic_irq_set(irq, vector, flags);
    2a3f:	89 45 08             	mov    %eax,0x8(%ebp)
	} else {
		_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
	}
}
    2a42:	5d                   	pop    %ebp
		_ioapic_irq_set(irq, vector, flags);
    2a43:	e9 af 00 00 00       	jmp    2af7 <_ioapic_irq_set>
		_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
    2a48:	83 e8 18             	sub    $0x18,%eax
    2a4b:	89 45 08             	mov    %eax,0x8(%ebp)
}
    2a4e:	5d                   	pop    %ebp
		_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
    2a4f:	e9 64 ff ff ff       	jmp    29b8 <_loapic_int_vec_set>

00002a54 <_arch_irq_enable>:
 * virtualization.
 *
 * @return N/A
 */
void _arch_irq_enable(unsigned int irq)
{
    2a54:	55                   	push   %ebp
    2a55:	89 e5                	mov    %esp,%ebp
    2a57:	8b 45 08             	mov    0x8(%ebp),%eax
	if (IS_IOAPIC_IRQ(irq)) {
    2a5a:	83 f8 17             	cmp    $0x17,%eax
    2a5d:	77 06                	ja     2a65 <_arch_irq_enable+0x11>
		_ioapic_irq_enable(irq);
	} else {
		_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
	}
}
    2a5f:	5d                   	pop    %ebp
		_ioapic_irq_enable(irq);
    2a60:	e9 7f 00 00 00       	jmp    2ae4 <_ioapic_irq_enable>
		_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
    2a65:	83 e8 18             	sub    $0x18,%eax
    2a68:	89 45 08             	mov    %eax,0x8(%ebp)
}
    2a6b:	5d                   	pop    %ebp
		_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
    2a6c:	e9 6a ff ff ff       	jmp    29db <_loapic_irq_enable>

00002a71 <__IoApicSet>:
 * @param offset Register offset (8 bits)
 * @param value Value to set the register
 * @return N/A
 */
static void __IoApicSet(s32_t offset, u32_t value)
{
    2a71:	55                   	push   %ebp
    2a72:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
    2a74:	9c                   	pushf  
    2a75:	fa                   	cli    
    2a76:	59                   	pop    %ecx
    2a77:	0f ba e1 09          	bt     $0x9,%ecx

	/* lock interrupts to ensure indirect addressing works "atomically" */

	key = irq_lock();

	*(volatile char *)(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_IND) = (char)offset;
    2a7b:	a2 00 00 c0 fe       	mov    %al,0xfec00000
	*((volatile u32_t *)(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_DATA)) = value;
    2a80:	89 15 10 00 c0 fe    	mov    %edx,0xfec00010
    2a86:	73 01                	jae    2a89 <__IoApicSet+0x18>
	__asm__ volatile (
    2a88:	fb                   	sti    

	irq_unlock(key);
}
    2a89:	5d                   	pop    %ebp
    2a8a:	c3                   	ret    

00002a8b <_IoApicRedUpdateLo>:
 * @return N/A
 */
static void _IoApicRedUpdateLo(unsigned int irq,
				u32_t value,
				u32_t mask)
{
    2a8b:	55                   	push   %ebp
	s32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */
    2a8c:	01 c0                	add    %eax,%eax
{
    2a8e:	89 e5                	mov    %esp,%ebp
	s32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */
    2a90:	83 c0 10             	add    $0x10,%eax
{
    2a93:	56                   	push   %esi
    2a94:	53                   	push   %ebx
	__asm__ volatile (
    2a95:	9c                   	pushf  
    2a96:	fa                   	cli    
    2a97:	5e                   	pop    %esi
    2a98:	0f ba e6 09          	bt     $0x9,%esi
		(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_IND)) = (char)offset;
    2a9c:	a2 00 00 c0 fe       	mov    %al,0xfec00000
	value = *((volatile u32_t *)(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_DATA));
    2aa1:	8b 1d 10 00 c0 fe    	mov    0xfec00010,%ebx
    2aa7:	73 01                	jae    2aaa <_IoApicRedUpdateLo+0x1f>
	__asm__ volatile (
    2aa9:	fb                   	sti    
	ioApicRedSetLo(irq, (ioApicRedGetLo(irq) & ~mask) | (value & mask));
    2aaa:	31 da                	xor    %ebx,%edx
    2aac:	21 ca                	and    %ecx,%edx
    2aae:	31 da                	xor    %ebx,%edx
}
    2ab0:	5b                   	pop    %ebx
    2ab1:	5e                   	pop    %esi
    2ab2:	5d                   	pop    %ebp
	__IoApicSet(offset, lower32);
    2ab3:	e9 b9 ff ff ff       	jmp    2a71 <__IoApicSet>

00002ab8 <_ioapic_init>:
{
    2ab8:	55                   	push   %ebp
    2ab9:	89 e5                	mov    %esp,%ebp
    2abb:	53                   	push   %ebx
    2abc:	bb 11 00 00 00       	mov    $0x11,%ebx
	__IoApicSet(offset, upper32);
    2ac1:	31 d2                	xor    %edx,%edx
    2ac3:	89 d8                	mov    %ebx,%eax
    2ac5:	e8 a7 ff ff ff       	call   2a71 <__IoApicSet>
	__IoApicSet(offset, lower32);
    2aca:	8d 43 ff             	lea    -0x1(%ebx),%eax
    2acd:	ba 00 00 01 00       	mov    $0x10000,%edx
    2ad2:	83 c3 02             	add    $0x2,%ebx
    2ad5:	e8 97 ff ff ff       	call   2a71 <__IoApicSet>
	for (ix = 0; ix < CONFIG_IOAPIC_NUM_RTES; ix++) {
    2ada:	83 fb 41             	cmp    $0x41,%ebx
    2add:	75 e2                	jne    2ac1 <_ioapic_init+0x9>
}
    2adf:	31 c0                	xor    %eax,%eax
    2ae1:	5b                   	pop    %ebx
    2ae2:	5d                   	pop    %ebp
    2ae3:	c3                   	ret    

00002ae4 <_ioapic_irq_enable>:
{
    2ae4:	55                   	push   %ebp
	_IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
    2ae5:	b9 00 00 01 00       	mov    $0x10000,%ecx
{
    2aea:	89 e5                	mov    %esp,%ebp
	_IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
    2aec:	31 d2                	xor    %edx,%edx
    2aee:	8b 45 08             	mov    0x8(%ebp),%eax
}
    2af1:	5d                   	pop    %ebp
	_IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
    2af2:	e9 94 ff ff ff       	jmp    2a8b <_IoApicRedUpdateLo>

00002af7 <_ioapic_irq_set>:
{
    2af7:	55                   	push   %ebp
	__IoApicSet(offset, upper32);
    2af8:	31 d2                	xor    %edx,%edx
{
    2afa:	89 e5                	mov    %esp,%ebp
    2afc:	56                   	push   %esi
    2afd:	53                   	push   %ebx
    2afe:	8b 5d 08             	mov    0x8(%ebp),%ebx
	s32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */
    2b01:	01 db                	add    %ebx,%ebx
		   (vector & IOAPIC_VEC_MASK) | flags;
    2b03:	0f b6 75 0c          	movzbl 0xc(%ebp),%esi
	s32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */
    2b07:	8d 43 11             	lea    0x11(%ebx),%eax
	rteValue = IOAPIC_FIXED | IOAPIC_INT_MASK | IOAPIC_PHYSICAL |
    2b0a:	0b 75 10             	or     0x10(%ebp),%esi
	__IoApicSet(offset, upper32);
    2b0d:	e8 5f ff ff ff       	call   2a71 <__IoApicSet>
	rteValue = IOAPIC_FIXED | IOAPIC_INT_MASK | IOAPIC_PHYSICAL |
    2b12:	81 ce 00 00 01 00    	or     $0x10000,%esi
	s32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */
    2b18:	8d 43 10             	lea    0x10(%ebx),%eax
	__IoApicSet(offset, lower32);
    2b1b:	89 f2                	mov    %esi,%edx
}
    2b1d:	5b                   	pop    %ebx
    2b1e:	5e                   	pop    %esi
    2b1f:	5d                   	pop    %ebp
	__IoApicSet(offset, lower32);
    2b20:	e9 4c ff ff ff       	jmp    2a71 <__IoApicSet>

00002b25 <slip_init>:
	return 0;
}


static int slip_init(struct device *dev)
{
    2b25:	55                   	push   %ebp
    2b26:	89 e5                	mov    %esp,%ebp
	struct slip_context *slip = dev->driver_data;
    2b28:	8b 45 08             	mov    0x8(%ebp),%eax
    2b2b:	8b 40 08             	mov    0x8(%eax),%eax

#if defined(CONFIG_SLIP_TAP) && defined(CONFIG_NET_IPV4)
	SYS_LOG_DBG("ARP enabled");
#endif

	uart_pipe_register(slip->buf, sizeof(slip->buf), recv_cb);
    2b2e:	83 c0 02             	add    $0x2,%eax
	slip->state = STATE_OK;
    2b31:	c6 40 12 01          	movb   $0x1,0x12(%eax)
	slip->rx = NULL;
    2b35:	c7 40 02 00 00 00 00 	movl   $0x0,0x2(%eax)
	slip->first = false;
    2b3c:	c6 40 ff 00          	movb   $0x0,-0x1(%eax)
	uart_pipe_register(slip->buf, sizeof(slip->buf), recv_cb);
    2b40:	68 54 2b 00 00       	push   $0x2b54
    2b45:	6a 01                	push   $0x1
    2b47:	50                   	push   %eax
    2b48:	e8 d1 f8 ff ff       	call   241e <uart_pipe_register>
    2b4d:	83 c4 0c             	add    $0xc,%esp

	return 0;
}
    2b50:	31 c0                	xor    %eax,%eax
    2b52:	c9                   	leave  
    2b53:	c3                   	ret    

00002b54 <recv_cb>:
{
    2b54:	55                   	push   %ebp
    2b55:	89 e5                	mov    %esp,%ebp
    2b57:	57                   	push   %edi
    2b58:	56                   	push   %esi
    2b59:	53                   	push   %ebx
    2b5a:	53                   	push   %ebx
    2b5b:	31 f6                	xor    %esi,%esi
    2b5d:	8b 7d 08             	mov    0x8(%ebp),%edi
	if (!slip->init_done) {
    2b60:	80 7f fe 00          	cmpb   $0x0,-0x2(%edi)
    2b64:	0f 84 a8 01 00 00    	je     2d12 <recv_cb+0x1be>
	for (i = 0; i < *off; i++) {
    2b6a:	8b 45 0c             	mov    0xc(%ebp),%eax
    2b6d:	3b 30                	cmp    (%eax),%esi
    2b6f:	0f 83 9d 01 00 00    	jae    2d12 <recv_cb+0x1be>
	switch (slip->state) {
    2b75:	8a 47 12             	mov    0x12(%edi),%al
		if (slip_input_byte(slip, buf[i])) {
    2b78:	0f b6 1c 37          	movzbl (%edi,%esi,1),%ebx
	switch (slip->state) {
    2b7c:	3c 01                	cmp    $0x1,%al
    2b7e:	74 49                	je     2bc9 <recv_cb+0x75>
    2b80:	72 09                	jb     2b8b <recv_cb+0x37>
    2b82:	3c 02                	cmp    $0x2,%al
    2b84:	74 17                	je     2b9d <recv_cb+0x49>
    2b86:	e9 d1 00 00 00       	jmp    2c5c <recv_cb+0x108>
		if (c == SLIP_END) {
    2b8b:	80 fb c0             	cmp    $0xc0,%bl
    2b8e:	0f 85 40 01 00 00    	jne    2cd4 <recv_cb+0x180>
			slip->state = STATE_OK;
    2b94:	c6 47 12 01          	movb   $0x1,0x12(%edi)
    2b98:	e9 37 01 00 00       	jmp    2cd4 <recv_cb+0x180>
		if (c == SLIP_ESC_END) {
    2b9d:	80 fb dc             	cmp    $0xdc,%bl
    2ba0:	74 12                	je     2bb4 <recv_cb+0x60>
		} else if (c == SLIP_ESC_ESC) {
    2ba2:	80 fb dd             	cmp    $0xdd,%bl
    2ba5:	74 14                	je     2bbb <recv_cb+0x67>
			SLIP_STATS(slip->garbage++);
    2ba7:	66 ff 47 22          	incw   0x22(%edi)
			slip->state = STATE_GARBAGE;
    2bab:	c6 47 12 00          	movb   $0x0,0x12(%edi)
    2baf:	e9 20 01 00 00       	jmp    2cd4 <recv_cb+0x180>
			c = SLIP_END;
    2bb4:	bb c0 00 00 00       	mov    $0xc0,%ebx
    2bb9:	eb 05                	jmp    2bc0 <recv_cb+0x6c>
			c = SLIP_ESC;
    2bbb:	bb db 00 00 00       	mov    $0xdb,%ebx
		slip->state = STATE_OK;
    2bc0:	c6 47 12 01          	movb   $0x1,0x12(%edi)
    2bc4:	e9 93 00 00 00       	jmp    2c5c <recv_cb+0x108>
		if (c == SLIP_ESC) {
    2bc9:	80 fb db             	cmp    $0xdb,%bl
    2bcc:	75 09                	jne    2bd7 <recv_cb+0x83>
			slip->state = STATE_ESC;
    2bce:	c6 47 12 02          	movb   $0x2,0x12(%edi)
    2bd2:	e9 fd 00 00 00       	jmp    2cd4 <recv_cb+0x180>
		if (c == SLIP_END) {
    2bd7:	80 fb c0             	cmp    $0xc0,%bl
    2bda:	75 18                	jne    2bf4 <recv_cb+0xa0>
			if (slip->rx) {
    2bdc:	8b 5f 02             	mov    0x2(%edi),%ebx
			slip->state = STATE_OK;
    2bdf:	c6 47 12 01          	movb   $0x1,0x12(%edi)
			slip->first = false;
    2be3:	c6 47 ff 00          	movb   $0x0,-0x1(%edi)
			if (slip->rx) {
    2be7:	85 db                	test   %ebx,%ebx
    2be9:	0f 85 eb 00 00 00    	jne    2cda <recv_cb+0x186>
    2bef:	e9 e0 00 00 00       	jmp    2cd4 <recv_cb+0x180>
		if (slip->first && !slip->rx) {
    2bf4:	80 7f ff 00          	cmpb   $0x0,-0x1(%edi)
    2bf8:	74 0b                	je     2c05 <recv_cb+0xb1>
    2bfa:	83 7f 02 00          	cmpl   $0x0,0x2(%edi)
    2bfe:	75 5c                	jne    2c5c <recv_cb+0x108>
    2c00:	e9 cf 00 00 00       	jmp    2cd4 <recv_cb+0x180>
			slip->first = true;
    2c05:	c6 47 ff 01          	movb   $0x1,-0x1(%edi)
			slip->rx = net_pkt_get_reserve_rx(0, K_NO_WAIT);
    2c09:	6a 00                	push   $0x0
    2c0b:	6a 00                	push   $0x0
    2c0d:	e8 15 0f 00 00       	call   3b27 <net_pkt_get_reserve_rx>
    2c12:	5a                   	pop    %edx
			if (!slip->rx) {
    2c13:	85 c0                	test   %eax,%eax
			slip->rx = net_pkt_get_reserve_rx(0, K_NO_WAIT);
    2c15:	59                   	pop    %ecx
    2c16:	89 47 02             	mov    %eax,0x2(%edi)
			if (!slip->rx) {
    2c19:	0f 84 b5 00 00 00    	je     2cd4 <recv_cb+0x180>
			slip->last = net_pkt_get_frag(slip->rx, K_NO_WAIT);
    2c1f:	6a 00                	push   $0x0
    2c21:	50                   	push   %eax
    2c22:	e8 68 0f 00 00       	call   3b8f <net_pkt_get_frag>
    2c27:	5a                   	pop    %edx
			if (!slip->last) {
    2c28:	85 c0                	test   %eax,%eax
			slip->last = net_pkt_get_frag(slip->rx, K_NO_WAIT);
    2c2a:	59                   	pop    %ecx
    2c2b:	89 47 06             	mov    %eax,0x6(%edi)
			if (!slip->last) {
    2c2e:	75 15                	jne    2c45 <recv_cb+0xf1>
				net_pkt_unref(slip->rx);
    2c30:	ff 77 02             	pushl  0x2(%edi)
    2c33:	e8 a3 0f 00 00       	call   3bdb <net_pkt_unref>
    2c38:	58                   	pop    %eax
				slip->rx = NULL;
    2c39:	c7 47 02 00 00 00 00 	movl   $0x0,0x2(%edi)
    2c40:	e9 8f 00 00 00       	jmp    2cd4 <recv_cb+0x180>
			net_pkt_frag_add(slip->rx, slip->last);
    2c45:	50                   	push   %eax
    2c46:	ff 77 02             	pushl  0x2(%edi)
    2c49:	e8 fe 0f 00 00       	call   3c4c <net_pkt_frag_add>
    2c4e:	59                   	pop    %ecx
    2c4f:	58                   	pop    %eax
	return net_buf_frags_len(pkt->frags);
}

static inline u8_t *net_pkt_ip_data(struct net_pkt *pkt)
{
	return pkt->frags->data;
    2c50:	8b 47 02             	mov    0x2(%edi),%eax
    2c53:	8b 40 08             	mov    0x8(%eax),%eax
			slip->ptr = net_pkt_ip_data(slip->rx);
    2c56:	8b 40 08             	mov    0x8(%eax),%eax
    2c59:	89 47 0a             	mov    %eax,0xa(%edi)
	if (!slip->last) {
    2c5c:	8b 47 06             	mov    0x6(%edi),%eax
    2c5f:	85 c0                	test   %eax,%eax
    2c61:	74 71                	je     2cd4 <recv_cb+0x180>
	if (!net_buf_tailroom(slip->last)) {
    2c63:	83 c0 08             	add    $0x8,%eax
    2c66:	50                   	push   %eax
    2c67:	e8 6d 08 00 00       	call   34d9 <net_buf_simple_tailroom>
    2c6c:	5a                   	pop    %edx
    2c6d:	85 c0                	test   %eax,%eax
    2c6f:	75 42                	jne    2cb3 <recv_cb+0x15f>
		frag = net_pkt_get_reserve_rx_data(0, K_NO_WAIT);
    2c71:	6a 00                	push   $0x0
    2c73:	6a 00                	push   $0x0
    2c75:	e8 e1 0e 00 00       	call   3b5b <net_pkt_get_reserve_rx_data>
    2c7a:	5a                   	pop    %edx
		if (!frag) {
    2c7b:	85 c0                	test   %eax,%eax
		frag = net_pkt_get_reserve_rx_data(0, K_NO_WAIT);
    2c7d:	59                   	pop    %ecx
		if (!frag) {
    2c7e:	75 19                	jne    2c99 <recv_cb+0x145>
			net_pkt_unref(slip->rx);
    2c80:	ff 77 02             	pushl  0x2(%edi)
    2c83:	e8 53 0f 00 00       	call   3bdb <net_pkt_unref>
    2c88:	58                   	pop    %eax
			slip->rx = NULL;
    2c89:	c7 47 02 00 00 00 00 	movl   $0x0,0x2(%edi)
			slip->last = NULL;
    2c90:	c7 47 06 00 00 00 00 	movl   $0x0,0x6(%edi)
    2c97:	eb 3b                	jmp    2cd4 <recv_cb+0x180>
		net_buf_frag_insert(slip->last, frag);
    2c99:	50                   	push   %eax
    2c9a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    2c9d:	ff 77 06             	pushl  0x6(%edi)
    2ca0:	e8 65 07 00 00       	call   340a <net_buf_frag_insert>
    2ca5:	59                   	pop    %ecx
    2ca6:	58                   	pop    %eax
		slip->last = frag;
    2ca7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2caa:	89 47 06             	mov    %eax,0x6(%edi)
		slip->ptr = slip->last->data;
    2cad:	8b 40 08             	mov    0x8(%eax),%eax
    2cb0:	89 47 0a             	mov    %eax,0xa(%edi)
	if (slip->ptr < slip->last->data) {
    2cb3:	8b 47 06             	mov    0x6(%edi),%eax
    2cb6:	8b 4f 0a             	mov    0xa(%edi),%ecx
    2cb9:	3b 48 08             	cmp    0x8(%eax),%ecx
    2cbc:	73 04                	jae    2cc2 <recv_cb+0x16e>
		*slip->ptr = c;
    2cbe:	88 19                	mov    %bl,(%ecx)
    2cc0:	eb 0f                	jmp    2cd1 <recv_cb+0x17d>
		slip->ptr = net_buf_add_u8(slip->last, c);
    2cc2:	83 c0 08             	add    $0x8,%eax
    2cc5:	53                   	push   %ebx
    2cc6:	50                   	push   %eax
    2cc7:	e8 d1 07 00 00       	call   349d <net_buf_simple_add_u8>
    2ccc:	5b                   	pop    %ebx
    2ccd:	5a                   	pop    %edx
    2cce:	89 47 0a             	mov    %eax,0xa(%edi)
	slip->ptr++;
    2cd1:	ff 47 0a             	incl   0xa(%edi)
	for (i = 0; i < *off; i++) {
    2cd4:	46                   	inc    %esi
    2cd5:	e9 90 fe ff ff       	jmp    2b6a <recv_cb+0x16>
	if (slip->last && slip->last->len) {
    2cda:	8b 47 06             	mov    0x6(%edi),%eax
    2cdd:	85 c0                	test   %eax,%eax
    2cdf:	74 31                	je     2d12 <recv_cb+0x1be>
    2ce1:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
    2ce6:	74 2a                	je     2d12 <recv_cb+0x1be>
	if (!pkt || !pkt->frags) {
    2ce8:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
    2cec:	74 24                	je     2d12 <recv_cb+0x1be>
	if (net_recv_data(slip->iface, pkt) < 0) {
    2cee:	53                   	push   %ebx
    2cef:	ff 77 0e             	pushl  0xe(%edi)
    2cf2:	e8 a8 09 00 00       	call   369f <net_recv_data>
    2cf7:	5a                   	pop    %edx
    2cf8:	85 c0                	test   %eax,%eax
    2cfa:	59                   	pop    %ecx
    2cfb:	79 07                	jns    2d04 <recv_cb+0x1b0>
		net_pkt_unref(pkt);
    2cfd:	53                   	push   %ebx
    2cfe:	e8 d8 0e 00 00       	call   3bdb <net_pkt_unref>
    2d03:	58                   	pop    %eax
	slip->rx = NULL;
    2d04:	c7 47 02 00 00 00 00 	movl   $0x0,0x2(%edi)
	slip->last = NULL;
    2d0b:	c7 47 06 00 00 00 00 	movl   $0x0,0x6(%edi)
		*off = 0;
    2d12:	8b 45 0c             	mov    0xc(%ebp),%eax
    2d15:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    2d1b:	8d 65 f4             	lea    -0xc(%ebp),%esp
    2d1e:	89 f8                	mov    %edi,%eax
    2d20:	5b                   	pop    %ebx
    2d21:	5e                   	pop    %esi
    2d22:	5f                   	pop    %edi
    2d23:	5d                   	pop    %ebp
    2d24:	c3                   	ret    

00002d25 <slip_writeb>:
{
    2d25:	55                   	push   %ebp
    2d26:	89 e5                	mov    %esp,%ebp
    2d28:	52                   	push   %edx
	uart_pipe_send(&buf[0], 1);
    2d29:	6a 01                	push   $0x1
	u8_t buf[1] = { c };
    2d2b:	88 45 ff             	mov    %al,-0x1(%ebp)
	uart_pipe_send(&buf[0], 1);
    2d2e:	8d 45 ff             	lea    -0x1(%ebp),%eax
    2d31:	50                   	push   %eax
    2d32:	e8 b7 f6 ff ff       	call   23ee <uart_pipe_send>
    2d37:	59                   	pop    %ecx
    2d38:	58                   	pop    %eax
}
    2d39:	c9                   	leave  
    2d3a:	c3                   	ret    

00002d3b <slip_writeb_esc>:
{
    2d3b:	55                   	push   %ebp
	switch (c) {
    2d3c:	3c c0                	cmp    $0xc0,%al
{
    2d3e:	89 e5                	mov    %esp,%ebp
	switch (c) {
    2d40:	74 15                	je     2d57 <slip_writeb_esc+0x1c>
    2d42:	3c db                	cmp    $0xdb,%al
    2d44:	75 22                	jne    2d68 <slip_writeb_esc+0x2d>
		slip_writeb(SLIP_ESC);
    2d46:	b8 db 00 00 00       	mov    $0xdb,%eax
    2d4b:	e8 d5 ff ff ff       	call   2d25 <slip_writeb>
		slip_writeb(SLIP_ESC_ESC);
    2d50:	b8 dd 00 00 00       	mov    $0xdd,%eax
    2d55:	eb 14                	jmp    2d6b <slip_writeb_esc+0x30>
		slip_writeb(SLIP_ESC);
    2d57:	b8 db 00 00 00       	mov    $0xdb,%eax
    2d5c:	e8 c4 ff ff ff       	call   2d25 <slip_writeb>
		slip_writeb(SLIP_ESC_END);
    2d61:	b8 dc 00 00 00       	mov    $0xdc,%eax
    2d66:	eb 03                	jmp    2d6b <slip_writeb_esc+0x30>
	switch (c) {
    2d68:	0f b6 c0             	movzbl %al,%eax
}
    2d6b:	5d                   	pop    %ebp
		slip_writeb(c);
    2d6c:	e9 b4 ff ff ff       	jmp    2d25 <slip_writeb>

00002d71 <slip_send>:
{
    2d71:	55                   	push   %ebp
    2d72:	89 e5                	mov    %esp,%ebp
    2d74:	57                   	push   %edi
    2d75:	56                   	push   %esi
    2d76:	53                   	push   %ebx
    2d77:	83 ec 08             	sub    $0x8,%esp
	u16_t ll_reserve = net_pkt_ll_reserve(pkt);
    2d7a:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (!pkt->frags) {
    2d7d:	8b 55 0c             	mov    0xc(%ebp),%edx
	u16_t ll_reserve = net_pkt_ll_reserve(pkt);
    2d80:	0f b6 40 32          	movzbl 0x32(%eax),%eax
	if (!pkt->frags) {
    2d84:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
	u16_t ll_reserve = net_pkt_ll_reserve(pkt);
    2d88:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
    2d8c:	b8 b2 ff ff ff       	mov    $0xffffffb2,%eax
	if (!pkt->frags) {
    2d91:	0f 84 9b 00 00 00    	je     2e32 <slip_send+0xc1>
	slip_writeb(SLIP_END);
    2d97:	b8 c0 00 00 00       	mov    $0xc0,%eax
    2d9c:	e8 84 ff ff ff       	call   2d25 <slip_writeb>
	for (frag = pkt->frags; frag; frag = frag->frags) {
    2da1:	8b 45 0c             	mov    0xc(%ebp),%eax
	bool send_header_once = false;
    2da4:	c6 45 f1 00          	movb   $0x0,-0xf(%ebp)
	for (frag = pkt->frags; frag; frag = frag->frags) {
    2da8:	8b 58 08             	mov    0x8(%eax),%ebx
    2dab:	85 db                	test   %ebx,%ebx
    2dad:	74 6e                	je     2e1d <slip_send+0xac>
		ptr = frag->data - ll_reserve;
    2daf:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
    2db3:	8b 4b 08             	mov    0x8(%ebx),%ecx
    2db6:	89 ce                	mov    %ecx,%esi
    2db8:	29 c6                	sub    %eax,%esi
		if (!send_header_once && ll_reserve) {
    2dba:	66 83 7d f2 00       	cmpw   $0x0,-0xe(%ebp)
    2dbf:	0f 95 c0             	setne  %al
    2dc2:	31 ff                	xor    %edi,%edi
    2dc4:	38 45 f1             	cmp    %al,-0xf(%ebp)
    2dc7:	73 1a                	jae    2de3 <slip_send+0x72>
			for (i = 0; i < ll_reserve; i++) {
    2dc9:	66 39 7d f2          	cmp    %di,-0xe(%ebp)
    2dcd:	76 12                	jbe    2de1 <slip_send+0x70>
				slip_writeb_esc(*ptr++);
    2dcf:	0f b6 04 3e          	movzbl (%esi,%edi,1),%eax
    2dd3:	89 4d ec             	mov    %ecx,-0x14(%ebp)
    2dd6:	47                   	inc    %edi
    2dd7:	e8 5f ff ff ff       	call   2d3b <slip_writeb_esc>
    2ddc:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    2ddf:	eb e8                	jmp    2dc9 <slip_send+0x58>
			for (i = 0; i < ll_reserve; i++) {
    2de1:	89 ce                	mov    %ecx,%esi
		if (net_if_get_mtu(iface) > net_buf_headroom(frag)) {
    2de3:	8b 45 08             	mov    0x8(%ebp),%eax
    2de6:	0f b7 78 28          	movzwl 0x28(%eax),%edi
    2dea:	8d 43 08             	lea    0x8(%ebx),%eax
    2ded:	50                   	push   %eax
    2dee:	e8 d7 06 00 00       	call   34ca <net_buf_simple_headroom>
    2df3:	5a                   	pop    %edx
    2df4:	39 c7                	cmp    %eax,%edi
    2df6:	76 0d                	jbe    2e05 <slip_send+0x94>
			ptr = frag->data;
    2df8:	8b 73 08             	mov    0x8(%ebx),%esi
			send_header_once = true;
    2dfb:	c6 45 f1 01          	movb   $0x1,-0xf(%ebp)
			ll_reserve = 0;
    2dff:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
		for (i = 0; i < frag->len; ++i) {
    2e05:	31 ff                	xor    %edi,%edi
    2e07:	66 39 7b 0c          	cmp    %di,0xc(%ebx)
    2e0b:	76 0c                	jbe    2e19 <slip_send+0xa8>
			slip_writeb_esc(c);
    2e0d:	0f b6 04 3e          	movzbl (%esi,%edi,1),%eax
    2e11:	47                   	inc    %edi
    2e12:	e8 24 ff ff ff       	call   2d3b <slip_writeb_esc>
    2e17:	eb ee                	jmp    2e07 <slip_send+0x96>
	for (frag = pkt->frags; frag; frag = frag->frags) {
    2e19:	8b 1b                	mov    (%ebx),%ebx
    2e1b:	eb 8e                	jmp    2dab <slip_send+0x3a>
	net_pkt_unref(pkt);
    2e1d:	ff 75 0c             	pushl  0xc(%ebp)
    2e20:	e8 b6 0d 00 00       	call   3bdb <net_pkt_unref>
    2e25:	58                   	pop    %eax
	slip_writeb(SLIP_END);
    2e26:	b8 c0 00 00 00       	mov    $0xc0,%eax
    2e2b:	e8 f5 fe ff ff       	call   2d25 <slip_writeb>
	return 0;
    2e30:	31 c0                	xor    %eax,%eax
}
    2e32:	8d 65 f4             	lea    -0xc(%ebp),%esp
    2e35:	5b                   	pop    %ebx
    2e36:	5e                   	pop    %esi
    2e37:	5f                   	pop    %edi
    2e38:	5d                   	pop    %ebp
    2e39:	c3                   	ret    

00002e3a <slip_iface_init>:

	return &slip->ll_addr;
}

static void slip_iface_init(struct net_if *iface)
{
    2e3a:	55                   	push   %ebp
    2e3b:	89 e5                	mov    %esp,%ebp
    2e3d:	56                   	push   %esi
    2e3e:	53                   	push   %ebx
    2e3f:	8b 75 08             	mov    0x8(%ebp),%esi
	struct slip_context *slip = net_if_get_device(iface)->driver_data;
    2e42:	8b 06                	mov    (%esi),%eax
    2e44:	8b 58 08             	mov    0x8(%eax),%ebx
	slip->ll_addr.addr = slip->mac_addr;
    2e47:	8d 43 15             	lea    0x15(%ebx),%eax
	slip->ll_addr.len = sizeof(slip->mac_addr);
    2e4a:	c6 43 20 06          	movb   $0x6,0x20(%ebx)
	slip->ll_addr.addr = slip->mac_addr;
    2e4e:	89 43 1c             	mov    %eax,0x1c(%ebx)
	struct net_linkaddr *ll_addr = slip_get_mac(slip);

	slip->init_done = true;
    2e51:	c6 03 01             	movb   $0x1,(%ebx)
	slip->iface = iface;
    2e54:	89 73 10             	mov    %esi,0x10(%ebx)
			goto use_random_mac;
		}
	} else {
use_random_mac:
		/* 00-00-5E-00-53-xx Documentation RFC 7042 */
		slip->mac_addr[0] = 0x00;
    2e57:	c6 43 15 00          	movb   $0x0,0x15(%ebx)
		slip->mac_addr[1] = 0x00;
    2e5b:	c6 43 16 00          	movb   $0x0,0x16(%ebx)
		slip->mac_addr[2] = 0x5E;
    2e5f:	c6 43 17 5e          	movb   $0x5e,0x17(%ebx)
		slip->mac_addr[3] = 0x00;
    2e63:	c6 43 18 00          	movb   $0x0,0x18(%ebx)
		slip->mac_addr[4] = 0x53;
    2e67:	c6 43 19 53          	movb   $0x53,0x19(%ebx)
		slip->mac_addr[5] = sys_rand32_get();
    2e6b:	e8 49 f6 ff ff       	call   24b9 <sys_rand32_get>
	}
	net_if_set_link_addr(iface, ll_addr->addr, ll_addr->len,
    2e70:	8b 53 1c             	mov    0x1c(%ebx),%edx
		slip->mac_addr[5] = sys_rand32_get();
    2e73:	88 43 1a             	mov    %al,0x1a(%ebx)
	net_if_set_link_addr(iface, ll_addr->addr, ll_addr->len,
    2e76:	8a 43 20             	mov    0x20(%ebx),%al
 * @return Value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_get(const atomic_t *target)
{
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    2e79:	8b 4e 0c             	mov    0xc(%esi),%ecx
 */
static inline int net_if_set_link_addr(struct net_if *iface,
				       u8_t *addr, u8_t len,
				       enum net_link_type type)
{
	if (atomic_test_bit(iface->flags, NET_IF_UP)) {
    2e7c:	80 e1 01             	and    $0x1,%cl
    2e7f:	75 0a                	jne    2e8b <slip_iface_init+0x51>
		return -EPERM;
	}

	iface->link_addr.addr = addr;
    2e81:	89 56 10             	mov    %edx,0x10(%esi)
	iface->link_addr.len = len;
    2e84:	88 46 14             	mov    %al,0x14(%esi)
	iface->link_addr.type = type;
    2e87:	c6 46 15 03          	movb   $0x3,0x15(%esi)
			     NET_LINK_ETHERNET);
}
    2e8b:	5b                   	pop    %ebx
    2e8c:	5e                   	pop    %esi
    2e8d:	5d                   	pop    %ebp
    2e8e:	c3                   	ret    

00002e8f <_nop_char_out>:
 * @param c Character to swallow
 *
 * @return 0
 */
static int _nop_char_out(int c)
{
    2e8f:	55                   	push   %ebp
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
    2e90:	31 c0                	xor    %eax,%eax
{
    2e92:	89 e5                	mov    %esp,%ebp
}
    2e94:	5d                   	pop    %ebp
    2e95:	c3                   	ret    

00002e96 <char_out>:
struct out_context {
	int count;
};

static int char_out(int c, struct out_context *ctx)
{
    2e96:	55                   	push   %ebp
    2e97:	89 e5                	mov    %esp,%ebp
    2e99:	8b 45 0c             	mov    0xc(%ebp),%eax
	ctx->count++;
    2e9c:	ff 00                	incl   (%eax)
	return _char_out(c);
}
    2e9e:	5d                   	pop    %ebp
	return _char_out(c);
    2e9f:	ff 25 f4 00 40 00    	jmp    *0x4000f4

00002ea5 <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, enum pad_type padding,
			      int min_width)
{
    2ea5:	55                   	push   %ebp
    2ea6:	89 e5                	mov    %esp,%ebp
    2ea8:	57                   	push   %edi
    2ea9:	56                   	push   %esi
    2eaa:	53                   	push   %ebx
    2eab:	83 ec 18             	sub    $0x18,%esp
    2eae:	89 c7                	mov    %eax,%edi
    2eb0:	8b 45 0c             	mov    0xc(%ebp),%eax
    2eb3:	89 d6                	mov    %edx,%esi
    2eb5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    2eb8:	85 c0                	test   %eax,%eax
    2eba:	7f 07                	jg     2ec3 <_printk_dec_ulong+0x1e>
    2ebc:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
    2ec3:	31 db                	xor    %ebx,%ebx
    2ec5:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    2ec8:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
    2ecc:	0f 94 c3             	sete   %bl
    2ecf:	4b                   	dec    %ebx
    2ed0:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
    2ed7:	83 e3 f0             	and    $0xfffffff0,%ebx
    2eda:	c7 45 dc 0a 00 00 00 	movl   $0xa,-0x24(%ebp)
    2ee1:	83 c3 30             	add    $0x30,%ebx
    2ee4:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    2eeb:	c7 45 ec ff c9 9a 3b 	movl   $0x3b9ac9ff,-0x14(%ebp)
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 9) {
		if (found_largest_digit || remainder > pos) {
    2ef2:	8b 55 f0             	mov    -0x10(%ebp),%edx
    2ef5:	39 55 ec             	cmp    %edx,-0x14(%ebp)
    2ef8:	72 06                	jb     2f00 <_printk_dec_ulong+0x5b>
    2efa:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    2efe:	74 22                	je     2f22 <_printk_dec_ulong+0x7d>
			found_largest_digit = 1;
			out((int)((remainder / (pos + 1)) + 48), ctx);
    2f00:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2f03:	31 d2                	xor    %edx,%edx
    2f05:	56                   	push   %esi
    2f06:	8d 48 01             	lea    0x1(%eax),%ecx
    2f09:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2f0c:	f7 f1                	div    %ecx
    2f0e:	83 c0 30             	add    $0x30,%eax
    2f11:	50                   	push   %eax
    2f12:	ff d7                	call   *%edi
    2f14:	59                   	pop    %ecx
			digits++;
    2f15:	ff 45 e0             	incl   -0x20(%ebp)
			out((int)((remainder / (pos + 1)) + 48), ctx);
    2f18:	58                   	pop    %eax
			found_largest_digit = 1;
    2f19:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
    2f20:	eb 1e                	jmp    2f40 <_printk_dec_ulong+0x9b>
		} else if (remaining <= min_width
    2f22:	8b 55 dc             	mov    -0x24(%ebp),%edx
    2f25:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
    2f28:	7c 0f                	jl     2f39 <_printk_dec_ulong+0x94>
    2f2a:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
    2f2e:	77 09                	ja     2f39 <_printk_dec_ulong+0x94>
				&& padding < PAD_SPACE_AFTER) {
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
    2f30:	56                   	push   %esi
    2f31:	53                   	push   %ebx
    2f32:	ff d7                	call   *%edi
			digits++;
    2f34:	ff 45 e0             	incl   -0x20(%ebp)
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
    2f37:	58                   	pop    %eax
    2f38:	5a                   	pop    %edx
    2f39:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		}
		remaining--;
		remainder %= (pos + 1);
    2f40:	8b 45 ec             	mov    -0x14(%ebp),%eax
		remaining--;
    2f43:	ff 4d dc             	decl   -0x24(%ebp)
		remainder %= (pos + 1);
    2f46:	40                   	inc    %eax
    2f47:	89 c2                	mov    %eax,%edx
    2f49:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2f4c:	89 d1                	mov    %edx,%ecx
    2f4e:	31 d2                	xor    %edx,%edx
    2f50:	f7 f1                	div    %ecx
    2f52:	89 55 f0             	mov    %edx,-0x10(%ebp)
		pos /= 10;
    2f55:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2f58:	31 d2                	xor    %edx,%edx
    2f5a:	b9 0a 00 00 00       	mov    $0xa,%ecx
    2f5f:	f7 f1                	div    %ecx
    2f61:	89 45 ec             	mov    %eax,-0x14(%ebp)
	while (pos >= 9) {
    2f64:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
    2f68:	75 88                	jne    2ef2 <_printk_dec_ulong+0x4d>
	}
	out((int)(remainder + 48), ctx);
    2f6a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    2f6d:	56                   	push   %esi
    2f6e:	83 c1 30             	add    $0x30,%ecx
    2f71:	51                   	push   %ecx
    2f72:	ff d7                	call   *%edi
    2f74:	59                   	pop    %ecx
    2f75:	5b                   	pop    %ebx

	if (padding == PAD_SPACE_AFTER) {
    2f76:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
    2f7a:	75 14                	jne    2f90 <_printk_dec_ulong+0xeb>
		remaining = min_width - digits;
    2f7c:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    2f7f:	2b 5d e0             	sub    -0x20(%ebp),%ebx
		while (remaining-- > 0) {
    2f82:	85 db                	test   %ebx,%ebx
    2f84:	7e 0a                	jle    2f90 <_printk_dec_ulong+0xeb>
			out(' ', ctx);
    2f86:	56                   	push   %esi
    2f87:	4b                   	dec    %ebx
    2f88:	6a 20                	push   $0x20
    2f8a:	ff d7                	call   *%edi
    2f8c:	58                   	pop    %eax
    2f8d:	5a                   	pop    %edx
    2f8e:	eb f2                	jmp    2f82 <_printk_dec_ulong+0xdd>
		}
	}
}
    2f90:	8d 65 f4             	lea    -0xc(%ebp),%esp
    2f93:	5b                   	pop    %ebx
    2f94:	5e                   	pop    %esi
    2f95:	5f                   	pop    %edi
    2f96:	5d                   	pop    %ebp
    2f97:	c3                   	ret    

00002f98 <__printk_hook_install>:
{
    2f98:	55                   	push   %ebp
    2f99:	89 e5                	mov    %esp,%ebp
	_char_out = fn;
    2f9b:	8b 45 08             	mov    0x8(%ebp),%eax
}
    2f9e:	5d                   	pop    %ebp
	_char_out = fn;
    2f9f:	a3 f4 00 40 00       	mov    %eax,0x4000f4
}
    2fa4:	c3                   	ret    

00002fa5 <_vprintk>:
{
    2fa5:	55                   	push   %ebp
    2fa6:	89 e5                	mov    %esp,%ebp
    2fa8:	57                   	push   %edi
    2fa9:	56                   	push   %esi
    2faa:	53                   	push   %ebx
    2fab:	83 ec 20             	sub    $0x20,%esp
	int long_ctr = 0;
    2fae:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
{
    2fb5:	8b 7d 08             	mov    0x8(%ebp),%edi
    2fb8:	8b 5d 14             	mov    0x14(%ebp),%ebx
	int min_width = -1;
    2fbb:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%ebp)
	enum pad_type padding = PAD_NONE;
    2fc2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	int might_format = 0; /* 1 if encountered a '%' */
    2fc9:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	while (*fmt) {
    2fd0:	8b 45 10             	mov    0x10(%ebp),%eax
    2fd3:	0f be 00             	movsbl (%eax),%eax
    2fd6:	84 c0                	test   %al,%al
    2fd8:	0f 84 bb 02 00 00    	je     3299 <_vprintk+0x2f4>
		if (!might_format) {
    2fde:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    2fe2:	75 15                	jne    2ff9 <_vprintk+0x54>
			if (*fmt != '%') {
    2fe4:	3c 25                	cmp    $0x25,%al
    2fe6:	0f 84 80 02 00 00    	je     326c <_vprintk+0x2c7>
				out((int)*fmt, ctx);
    2fec:	ff 75 0c             	pushl  0xc(%ebp)
    2fef:	50                   	push   %eax
    2ff0:	ff d7                	call   *%edi
    2ff2:	58                   	pop    %eax
    2ff3:	5a                   	pop    %edx
    2ff4:	e9 98 02 00 00       	jmp    3291 <_vprintk+0x2ec>
			switch (*fmt) {
    2ff9:	3c 64                	cmp    $0x64,%al
    2ffb:	0f 84 ee 00 00 00    	je     30ef <_vprintk+0x14a>
    3001:	7f 4f                	jg     3052 <_vprintk+0xad>
    3003:	3c 39                	cmp    $0x39,%al
    3005:	7f 2a                	jg     3031 <_vprintk+0x8c>
    3007:	3c 31                	cmp    $0x31,%al
    3009:	0f 8d ac 00 00 00    	jge    30bb <_vprintk+0x116>
    300f:	3c 2d                	cmp    $0x2d,%al
    3011:	0f 84 86 00 00 00    	je     309d <_vprintk+0xf8>
    3017:	3c 30                	cmp    $0x30,%al
    3019:	0f 84 8a 00 00 00    	je     30a9 <_vprintk+0x104>
    301f:	3c 25                	cmp    $0x25,%al
    3021:	0f 85 25 02 00 00    	jne    324c <_vprintk+0x2a7>
				out((int)'%', ctx);
    3027:	ff 75 0c             	pushl  0xc(%ebp)
    302a:	6a 25                	push   $0x25
    302c:	e9 2e 02 00 00       	jmp    325f <_vprintk+0x2ba>
			switch (*fmt) {
    3031:	3c 58                	cmp    $0x58,%al
    3033:	0f 84 27 01 00 00    	je     3160 <_vprintk+0x1bb>
    3039:	3c 63                	cmp    $0x63,%al
    303b:	0f 85 0b 02 00 00    	jne    324c <_vprintk+0x2a7>
				out(c, ctx);
    3041:	ff 75 0c             	pushl  0xc(%ebp)
    3044:	ff 33                	pushl  (%ebx)
				int c = va_arg(ap, int);
    3046:	8d 73 04             	lea    0x4(%ebx),%esi
				out(c, ctx);
    3049:	ff d7                	call   *%edi
    304b:	58                   	pop    %eax
    304c:	5a                   	pop    %edx
    304d:	e9 f6 01 00 00       	jmp    3248 <_vprintk+0x2a3>
			switch (*fmt) {
    3052:	3c 70                	cmp    $0x70,%al
    3054:	0f 84 e6 00 00 00    	je     3140 <_vprintk+0x19b>
    305a:	7f 10                	jg     306c <_vprintk+0xc7>
    305c:	3c 69                	cmp    $0x69,%al
    305e:	0f 84 8b 00 00 00    	je     30ef <_vprintk+0x14a>
    3064:	3c 6c                	cmp    $0x6c,%al
    3066:	74 7f                	je     30e7 <_vprintk+0x142>
    3068:	3c 68                	cmp    $0x68,%al
    306a:	eb 26                	jmp    3092 <_vprintk+0xed>
    306c:	3c 75                	cmp    $0x75,%al
    306e:	0f 84 a7 00 00 00    	je     311b <_vprintk+0x176>
    3074:	7f 12                	jg     3088 <_vprintk+0xe3>
    3076:	3c 73                	cmp    $0x73,%al
    3078:	0f 85 ce 01 00 00    	jne    324c <_vprintk+0x2a7>
				char *s = va_arg(ap, char *);
    307e:	8d 73 04             	lea    0x4(%ebx),%esi
    3081:	8b 1b                	mov    (%ebx),%ebx
				while (*s)
    3083:	e9 ae 01 00 00       	jmp    3236 <_vprintk+0x291>
			switch (*fmt) {
    3088:	3c 78                	cmp    $0x78,%al
    308a:	0f 84 d0 00 00 00    	je     3160 <_vprintk+0x1bb>
    3090:	3c 7a                	cmp    $0x7a,%al
    3092:	0f 84 f9 01 00 00    	je     3291 <_vprintk+0x2ec>
    3098:	e9 af 01 00 00       	jmp    324c <_vprintk+0x2a7>
				padding = PAD_SPACE_AFTER;
    309d:	c7 45 ec 03 00 00 00 	movl   $0x3,-0x14(%ebp)
    30a4:	e9 e8 01 00 00       	jmp    3291 <_vprintk+0x2ec>
				if (min_width < 0 && padding == PAD_NONE) {
    30a9:	8b 55 f0             	mov    -0x10(%ebp),%edx
    30ac:	c1 ea 1f             	shr    $0x1f,%edx
    30af:	74 0a                	je     30bb <_vprintk+0x116>
    30b1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    30b5:	0f 84 cf 01 00 00    	je     328a <_vprintk+0x2e5>
				if (min_width < 0) {
    30bb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    30bf:	79 05                	jns    30c6 <_vprintk+0x121>
					min_width = *fmt - '0';
    30c1:	83 e8 30             	sub    $0x30,%eax
    30c4:	eb 08                	jmp    30ce <_vprintk+0x129>
					min_width = 10 * min_width + *fmt - '0';
    30c6:	6b 55 f0 0a          	imul   $0xa,-0x10(%ebp),%edx
    30ca:	8d 44 10 d0          	lea    -0x30(%eax,%edx,1),%eax
    30ce:	89 45 f0             	mov    %eax,-0x10(%ebp)
				if (padding == PAD_NONE) {
    30d1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    30d5:	0f 85 b6 01 00 00    	jne    3291 <_vprintk+0x2ec>
					padding = PAD_SPACE_BEFORE;
    30db:	c7 45 ec 02 00 00 00 	movl   $0x2,-0x14(%ebp)
    30e2:	e9 aa 01 00 00       	jmp    3291 <_vprintk+0x2ec>
				long_ctr++;
    30e7:	ff 45 e4             	incl   -0x1c(%ebp)
    30ea:	e9 a2 01 00 00       	jmp    3291 <_vprintk+0x2ec>
					d = va_arg(ap, long);
    30ef:	8b 33                	mov    (%ebx),%esi
				if (long_ctr < 2) {
    30f1:	83 7d e4 01          	cmpl   $0x1,-0x1c(%ebp)
    30f5:	7f 05                	jg     30fc <_vprintk+0x157>
					d = va_arg(ap, long);
    30f7:	83 c3 04             	add    $0x4,%ebx
    30fa:	eb 03                	jmp    30ff <_vprintk+0x15a>
					d = (long)va_arg(ap, long long);
    30fc:	83 c3 08             	add    $0x8,%ebx
				if (d < 0) {
    30ff:	85 f6                	test   %esi,%esi
    3101:	79 0e                	jns    3111 <_vprintk+0x16c>
					out((int)'-', ctx);
    3103:	ff 75 0c             	pushl  0xc(%ebp)
    3106:	6a 2d                	push   $0x2d
    3108:	ff d7                	call   *%edi
					min_width--;
    310a:	ff 4d f0             	decl   -0x10(%ebp)
					out((int)'-', ctx);
    310d:	59                   	pop    %ecx
					d = -d;
    310e:	f7 de                	neg    %esi
					out((int)'-', ctx);
    3110:	58                   	pop    %eax
				_printk_dec_ulong(out, ctx, d, padding,
    3111:	ff 75 f0             	pushl  -0x10(%ebp)
    3114:	89 f1                	mov    %esi,%ecx
    3116:	ff 75 ec             	pushl  -0x14(%ebp)
    3119:	eb 16                	jmp    3131 <_vprintk+0x18c>
					u = va_arg(ap, unsigned long);
    311b:	8b 0b                	mov    (%ebx),%ecx
				if (long_ctr < 2) {
    311d:	83 7d e4 01          	cmpl   $0x1,-0x1c(%ebp)
    3121:	7f 05                	jg     3128 <_vprintk+0x183>
					u = va_arg(ap, unsigned long);
    3123:	83 c3 04             	add    $0x4,%ebx
    3126:	eb 03                	jmp    312b <_vprintk+0x186>
					u = (unsigned long)va_arg(ap,
    3128:	83 c3 08             	add    $0x8,%ebx
				_printk_dec_ulong(out, ctx, u, padding,
    312b:	ff 75 f0             	pushl  -0x10(%ebp)
    312e:	ff 75 ec             	pushl  -0x14(%ebp)
    3131:	8b 55 0c             	mov    0xc(%ebp),%edx
    3134:	89 f8                	mov    %edi,%eax
    3136:	e8 6a fd ff ff       	call   2ea5 <_printk_dec_ulong>
    313b:	e9 21 01 00 00       	jmp    3261 <_vprintk+0x2bc>
				  out('0', ctx);
    3140:	ff 75 0c             	pushl  0xc(%ebp)
    3143:	6a 30                	push   $0x30
    3145:	ff d7                	call   *%edi
    3147:	59                   	pop    %ecx
    3148:	5e                   	pop    %esi
				  out('x', ctx);
    3149:	ff 75 0c             	pushl  0xc(%ebp)
    314c:	6a 78                	push   $0x78
    314e:	ff d7                	call   *%edi
    3150:	58                   	pop    %eax
				  min_width = 8;
    3151:	c7 45 f0 08 00 00 00 	movl   $0x8,-0x10(%ebp)
				  out('x', ctx);
    3158:	5a                   	pop    %edx
				  padding = PAD_ZERO_BEFORE;
    3159:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
					x = va_arg(ap, unsigned long);
    3160:	8b 03                	mov    (%ebx),%eax
				if (long_ctr < 2) {
    3162:	83 7d e4 01          	cmpl   $0x1,-0x1c(%ebp)
					x = va_arg(ap, unsigned long);
    3166:	89 45 dc             	mov    %eax,-0x24(%ebp)
				if (long_ctr < 2) {
    3169:	7f 05                	jg     3170 <_vprintk+0x1cb>
					x = va_arg(ap, unsigned long);
    316b:	83 c3 04             	add    $0x4,%ebx
    316e:	eb 03                	jmp    3173 <_vprintk+0x1ce>
					x = (unsigned long)va_arg(ap,
    3170:	83 c3 08             	add    $0x8,%ebx
	int remaining = 8; /* 8 digits max */
    3173:	ba 08 00 00 00       	mov    $0x8,%edx
	int digits = 0;
    3178:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
	int found_largest_digit = 0;
    317f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	int size = sizeof(num) * 2;
    3186:	be 08 00 00 00       	mov    $0x8,%esi
		char nibble = (num >> ((size - 1) << 2) & 0xf);
    318b:	4e                   	dec    %esi
    318c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    318f:	8d 0c b5 00 00 00 00 	lea    0x0(,%esi,4),%ecx
    3196:	d3 e8                	shr    %cl,%eax
		if (nibble || found_largest_digit || size == 1) {
    3198:	24 0f                	and    $0xf,%al
    319a:	75 0e                	jne    31aa <_vprintk+0x205>
    319c:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
    31a0:	75 08                	jne    31aa <_vprintk+0x205>
    31a2:	85 f6                	test   %esi,%esi
    31a4:	75 31                	jne    31d7 <_vprintk+0x232>
			nibble += nibble > 9 ? 87 : 48;
    31a6:	b1 30                	mov    $0x30,%cl
    31a8:	eb 0c                	jmp    31b6 <_vprintk+0x211>
    31aa:	3c 09                	cmp    $0x9,%al
    31ac:	0f 9f c1             	setg   %cl
    31af:	49                   	dec    %ecx
    31b0:	83 e1 d9             	and    $0xffffffd9,%ecx
    31b3:	83 c1 57             	add    $0x57,%ecx
			out((int)nibble, ctx);
    31b6:	ff 75 0c             	pushl  0xc(%ebp)
			nibble += nibble > 9 ? 87 : 48;
    31b9:	01 c1                	add    %eax,%ecx
    31bb:	89 55 e0             	mov    %edx,-0x20(%ebp)
			out((int)nibble, ctx);
    31be:	0f b6 c9             	movzbl %cl,%ecx
    31c1:	51                   	push   %ecx
    31c2:	ff d7                	call   *%edi
    31c4:	58                   	pop    %eax
			found_largest_digit = 1;
    31c5:	8b 45 e8             	mov    -0x18(%ebp),%eax
			out((int)nibble, ctx);
    31c8:	5a                   	pop    %edx
			digits++;
    31c9:	8b 55 e0             	mov    -0x20(%ebp),%edx
    31cc:	ff 45 d4             	incl   -0x2c(%ebp)
    31cf:	89 55 d8             	mov    %edx,-0x28(%ebp)
			found_largest_digit = 1;
    31d2:	89 45 e0             	mov    %eax,-0x20(%ebp)
    31d5:	eb 2e                	jmp    3205 <_vprintk+0x260>
		if (remaining-- <= min_width) {
    31d7:	8d 42 ff             	lea    -0x1(%edx),%eax
    31da:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    31e1:	89 45 d8             	mov    %eax,-0x28(%ebp)
    31e4:	39 55 f0             	cmp    %edx,-0x10(%ebp)
    31e7:	7c 1c                	jl     3205 <_vprintk+0x260>
			if (padding == PAD_ZERO_BEFORE) {
    31e9:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
    31ed:	75 07                	jne    31f6 <_vprintk+0x251>
				out('0', ctx);
    31ef:	ff 75 0c             	pushl  0xc(%ebp)
    31f2:	6a 30                	push   $0x30
    31f4:	eb 0b                	jmp    3201 <_vprintk+0x25c>
			} else if (padding == PAD_SPACE_BEFORE) {
    31f6:	83 7d ec 02          	cmpl   $0x2,-0x14(%ebp)
    31fa:	75 09                	jne    3205 <_vprintk+0x260>
				out(' ', ctx);
    31fc:	ff 75 0c             	pushl  0xc(%ebp)
    31ff:	6a 20                	push   $0x20
    3201:	ff d7                	call   *%edi
    3203:	59                   	pop    %ecx
    3204:	58                   	pop    %eax
	for (; size; size--) {
    3205:	85 f6                	test   %esi,%esi
    3207:	74 08                	je     3211 <_vprintk+0x26c>
    3209:	8b 55 d8             	mov    -0x28(%ebp),%edx
    320c:	e9 7a ff ff ff       	jmp    318b <_vprintk+0x1e6>
			might_format = 0;
    3211:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	if (padding == PAD_SPACE_AFTER) {
    3218:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
    321c:	75 73                	jne    3291 <_vprintk+0x2ec>
		remaining = min_width * 2 - digits;
    321e:	8b 75 f0             	mov    -0x10(%ebp),%esi
    3221:	01 f6                	add    %esi,%esi
    3223:	2b 75 d4             	sub    -0x2c(%ebp),%esi
		while (remaining-- > 0) {
    3226:	85 f6                	test   %esi,%esi
    3228:	7e 39                	jle    3263 <_vprintk+0x2be>
			out(' ', ctx);
    322a:	ff 75 0c             	pushl  0xc(%ebp)
    322d:	4e                   	dec    %esi
    322e:	6a 20                	push   $0x20
    3230:	ff d7                	call   *%edi
    3232:	58                   	pop    %eax
    3233:	5a                   	pop    %edx
    3234:	eb f0                	jmp    3226 <_vprintk+0x281>
				while (*s)
    3236:	0f be 03             	movsbl (%ebx),%eax
    3239:	84 c0                	test   %al,%al
    323b:	74 0b                	je     3248 <_vprintk+0x2a3>
					out((int)(*s++), ctx);
    323d:	ff 75 0c             	pushl  0xc(%ebp)
    3240:	43                   	inc    %ebx
    3241:	50                   	push   %eax
    3242:	ff d7                	call   *%edi
    3244:	59                   	pop    %ecx
    3245:	58                   	pop    %eax
    3246:	eb ee                	jmp    3236 <_vprintk+0x291>
				int c = va_arg(ap, int);
    3248:	89 f3                	mov    %esi,%ebx
    324a:	eb 17                	jmp    3263 <_vprintk+0x2be>
				out((int)'%', ctx);
    324c:	ff 75 0c             	pushl  0xc(%ebp)
    324f:	6a 25                	push   $0x25
    3251:	ff d7                	call   *%edi
    3253:	59                   	pop    %ecx
    3254:	5e                   	pop    %esi
				out((int)*fmt, ctx);
    3255:	ff 75 0c             	pushl  0xc(%ebp)
    3258:	8b 45 10             	mov    0x10(%ebp),%eax
    325b:	0f be 00             	movsbl (%eax),%eax
    325e:	50                   	push   %eax
    325f:	ff d7                	call   *%edi
    3261:	58                   	pop    %eax
    3262:	5a                   	pop    %edx
			might_format = 0;
    3263:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
				break;
    326a:	eb 25                	jmp    3291 <_vprintk+0x2ec>
				long_ctr = 0;
    326c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				min_width = -1;
    3273:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%ebp)
				padding = PAD_NONE;
    327a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
				might_format = 1;
    3281:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
    3288:	eb 07                	jmp    3291 <_vprintk+0x2ec>
					padding = PAD_ZERO_BEFORE;
    328a:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
		++fmt;
    3291:	ff 45 10             	incl   0x10(%ebp)
    3294:	e9 37 fd ff ff       	jmp    2fd0 <_vprintk+0x2b>
}
    3299:	8d 65 f4             	lea    -0xc(%ebp),%esp
    329c:	5b                   	pop    %ebx
    329d:	5e                   	pop    %esi
    329e:	5f                   	pop    %edi
    329f:	5d                   	pop    %ebp
    32a0:	c3                   	ret    

000032a1 <vprintk>:
{
    32a1:	55                   	push   %ebp
    32a2:	89 e5                	mov    %esp,%ebp
    32a4:	50                   	push   %eax
	_vprintk((out_func_t)char_out, &ctx, fmt, ap);
    32a5:	ff 75 0c             	pushl  0xc(%ebp)
    32a8:	ff 75 08             	pushl  0x8(%ebp)
    32ab:	8d 45 fc             	lea    -0x4(%ebp),%eax
	struct out_context ctx = { 0 };
    32ae:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	_vprintk((out_func_t)char_out, &ctx, fmt, ap);
    32b5:	50                   	push   %eax
    32b6:	68 96 2e 00 00       	push   $0x2e96
    32bb:	e8 e5 fc ff ff       	call   2fa5 <_vprintk>
}
    32c0:	8b 45 fc             	mov    -0x4(%ebp),%eax
	_vprintk((out_func_t)char_out, &ctx, fmt, ap);
    32c3:	83 c4 10             	add    $0x10,%esp
}
    32c6:	c9                   	leave  
    32c7:	c3                   	ret    

000032c8 <printk>:
{
    32c8:	55                   	push   %ebp
    32c9:	89 e5                	mov    %esp,%ebp
	va_start(ap, fmt);
    32cb:	8d 45 0c             	lea    0xc(%ebp),%eax
	ret = vprintk(fmt, ap);
    32ce:	50                   	push   %eax
    32cf:	ff 75 08             	pushl  0x8(%ebp)
    32d2:	e8 ca ff ff ff       	call   32a1 <vprintk>
    32d7:	5a                   	pop    %edx
    32d8:	59                   	pop    %ecx
}
    32d9:	c9                   	leave  
    32da:	c3                   	ret    

000032db <_ConfigAbsSyms>:
/* file is auto-generated, do not modify ! */

#include <toolchain.h>

GEN_ABS_SYM_BEGIN (_ConfigAbsSyms)
    32db:	55                   	push   %ebp
    32dc:	89 e5                	mov    %esp,%ebp
GEN_ABSOLUTE_SYM(CONFIG_ISA_IA32, 1);
GEN_ABSOLUTE_SYM(CONFIG_SYS_LOG_SHOW_TAGS, 1);
GEN_ABSOLUTE_SYM(CONFIG_NET_UDP_CHECKSUM, 1);
GEN_ABSOLUTE_SYM(CONFIG_NET_IF_MCAST_IPV4_ADDR_COUNT, 1);

GEN_ABS_SYM_END
    32de:	5d                   	pop    %ebp
    32df:	c3                   	ret    

000032e0 <_mbedtls_init>:
#else
#define init_heap(...)
#endif /* CONFIG_MBEDTLS_ENABLE_HEAP && MBEDTLS_MEMORY_BUFFER_ALLOC_C */

static int _mbedtls_init(struct device *device)
{
    32e0:	55                   	push   %ebp
	ARG_UNUSED(device);

	init_heap();

	return 0;
}
    32e1:	31 c0                	xor    %eax,%eax
{
    32e3:	89 e5                	mov    %esp,%ebp
}
    32e5:	5d                   	pop    %ebp
    32e6:	c3                   	ret    

000032e7 <net_buf_alloc>:
struct net_buf *net_buf_alloc_debug(struct net_buf_pool *pool, s32_t timeout,
				    const char *func, int line)
#else
struct net_buf *net_buf_alloc(struct net_buf_pool *pool, s32_t timeout)
#endif
{
    32e7:	55                   	push   %ebp
    32e8:	89 e5                	mov    %esp,%ebp
    32ea:	57                   	push   %edi
    32eb:	56                   	push   %esi
    32ec:	53                   	push   %ebx
    32ed:	8b 5d 08             	mov    0x8(%ebp),%ebx
	__asm__ volatile (
    32f0:	9c                   	pushf  
    32f1:	fa                   	cli    
    32f2:	5f                   	pop    %edi
	key = irq_lock();

	/* If there are uninitialized buffers we're guaranteed to succeed
	 * with the allocation one way or another.
	 */
	if (pool->uninit_count) {
    32f3:	66 8b 43 12          	mov    0x12(%ebx),%ax
    32f7:	66 85 c0             	test   %ax,%ax
    32fa:	74 67                	je     3363 <net_buf_alloc+0x7c>

		/* If this is not the first access to the pool, we can
		 * be opportunistic and try to fetch a previously used
		 * buffer from the LIFO with K_NO_WAIT.
		 */
		if (pool->uninit_count < pool->buf_count) {
    32fc:	66 3b 43 10          	cmp    0x10(%ebx),%ax
    3300:	73 17                	jae    3319 <net_buf_alloc+0x32>
			buf = k_lifo_get(&pool->free, K_NO_WAIT);
    3302:	6a 00                	push   $0x0
    3304:	53                   	push   %ebx
    3305:	e8 7d 35 00 00       	call   6887 <k_queue_get>
    330a:	5e                   	pop    %esi
			if (buf) {
    330b:	85 c0                	test   %eax,%eax
			buf = k_lifo_get(&pool->free, K_NO_WAIT);
    330d:	5a                   	pop    %edx
			if (buf) {
    330e:	74 09                	je     3319 <net_buf_alloc+0x32>
    3310:	0f ba e7 09          	bt     $0x9,%edi
    3314:	73 63                	jae    3379 <net_buf_alloc+0x92>
	__asm__ volatile (
    3316:	fb                   	sti    
    3317:	eb 60                	jmp    3379 <net_buf_alloc+0x92>
				irq_unlock(key);
				goto success;
			}
		}

		uninit_count = pool->uninit_count--;
    3319:	0f b7 73 12          	movzwl 0x12(%ebx),%esi
    331d:	0f ba e7 09          	bt     $0x9,%edi
    3321:	8d 46 ff             	lea    -0x1(%esi),%eax
    3324:	66 89 43 12          	mov    %ax,0x12(%ebx)
    3328:	73 01                	jae    332b <net_buf_alloc+0x44>
    332a:	fb                   	sti    
	buf = UNINIT_BUF(pool, pool->buf_count - uninit_count);
    332b:	0f b7 43 14          	movzwl 0x14(%ebx),%eax
    332f:	0f b7 53 16          	movzwl 0x16(%ebx),%edx
    3333:	89 c1                	mov    %eax,%ecx
    3335:	83 c2 03             	add    $0x3,%edx
    3338:	83 c0 03             	add    $0x3,%eax
    333b:	83 e2 fc             	and    $0xfffffffc,%edx
    333e:	83 e0 fc             	and    $0xfffffffc,%eax
    3341:	8d 44 02 10          	lea    0x10(%edx,%eax,1),%eax
    3345:	0f b7 53 10          	movzwl 0x10(%ebx),%edx
    3349:	29 f2                	sub    %esi,%edx
    334b:	0f af c2             	imul   %edx,%eax
    334e:	03 43 1c             	add    0x1c(%ebx),%eax
	return pool - _net_buf_pool_list;
    3351:	81 eb 1c 51 40 00    	sub    $0x40511c,%ebx
    3357:	c1 fb 05             	sar    $0x5,%ebx
	buf->pool_id = pool_id(pool);
    335a:	88 58 06             	mov    %bl,0x6(%eax)
	buf->size = pool->buf_size;
    335d:	66 89 48 0e          	mov    %cx,0xe(%eax)
		irq_unlock(key);

		buf = pool_get_uninit(pool, uninit_count);
		goto success;
    3361:	eb 16                	jmp    3379 <net_buf_alloc+0x92>
    3363:	0f ba e7 09          	bt     $0x9,%edi
    3367:	73 01                	jae    336a <net_buf_alloc+0x83>
    3369:	fb                   	sti    
		}
	} else {
		buf = k_lifo_get(&pool->free, timeout);
	}
#else
	buf = k_lifo_get(&pool->free, timeout);
    336a:	ff 75 0c             	pushl  0xc(%ebp)
    336d:	53                   	push   %ebx
    336e:	e8 14 35 00 00       	call   6887 <k_queue_get>
    3373:	5a                   	pop    %edx
#endif
	if (!buf) {
    3374:	85 c0                	test   %eax,%eax
	buf = k_lifo_get(&pool->free, timeout);
    3376:	59                   	pop    %ecx
	if (!buf) {
    3377:	74 1a                	je     3393 <net_buf_alloc+0xac>
	buf->data  = buf->__buf;
    3379:	8d 50 10             	lea    0x10(%eax),%edx
	}

success:
	NET_BUF_DBG("allocated buf %p", buf);

	buf->ref   = 1;
    337c:	c6 40 04 01          	movb   $0x1,0x4(%eax)
	buf->flags = 0;
    3380:	c6 40 05 00          	movb   $0x0,0x5(%eax)
	buf->frags = NULL;
    3384:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	buf->len   = 0;
    338a:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
	buf->data  = buf->__buf;
    3390:	89 50 08             	mov    %edx,0x8(%eax)
	pool->avail_count--;
	NET_BUF_ASSERT(pool->avail_count >= 0);
#endif

	return buf;
}
    3393:	8d 65 f4             	lea    -0xc(%ebp),%esp
    3396:	5b                   	pop    %ebx
    3397:	5e                   	pop    %esi
    3398:	5f                   	pop    %edi
    3399:	5d                   	pop    %ebp
    339a:	c3                   	ret    

0000339b <net_buf_reserve>:

	return buf;
}

void net_buf_reserve(struct net_buf *buf, size_t reserve)
{
    339b:	55                   	push   %ebp
    339c:	89 e5                	mov    %esp,%ebp
    339e:	8b 55 08             	mov    0x8(%ebp),%edx
	NET_BUF_ASSERT(buf);
	NET_BUF_ASSERT(buf->len == 0);
	NET_BUF_DBG("buf %p reserve %zu", buf, reserve);

	buf->data = buf->__buf + reserve;
    33a1:	8d 42 10             	lea    0x10(%edx),%eax
    33a4:	03 45 0c             	add    0xc(%ebp),%eax
    33a7:	89 42 08             	mov    %eax,0x8(%edx)
}
    33aa:	5d                   	pop    %ebp
    33ab:	c3                   	ret    

000033ac <net_buf_unref>:
#if defined(CONFIG_NET_BUF_LOG)
void net_buf_unref_debug(struct net_buf *buf, const char *func, int line)
#else
void net_buf_unref(struct net_buf *buf)
#endif
{
    33ac:	55                   	push   %ebp
    33ad:	89 e5                	mov    %esp,%ebp
    33af:	53                   	push   %ebx
    33b0:	8b 45 08             	mov    0x8(%ebp),%eax
	NET_BUF_ASSERT(buf);

	while (buf) {
    33b3:	85 c0                	test   %eax,%eax
    33b5:	74 3c                	je     33f3 <net_buf_unref+0x47>
		}
#endif
		NET_BUF_DBG("buf %p ref %u pool_id %u frags %p", buf, buf->ref,
			    buf->pool_id, buf->frags);

		if (--buf->ref > 0) {
    33b7:	8a 48 04             	mov    0x4(%eax),%cl
		struct net_buf *frags = buf->frags;
    33ba:	8b 18                	mov    (%eax),%ebx
		if (--buf->ref > 0) {
    33bc:	8d 51 ff             	lea    -0x1(%ecx),%edx
    33bf:	88 50 04             	mov    %dl,0x4(%eax)
    33c2:	84 d2                	test   %dl,%dl
    33c4:	75 2d                	jne    33f3 <net_buf_unref+0x47>
			return;
		}

		buf->frags = NULL;

		pool = net_buf_pool_get(buf->pool_id);
    33c6:	0f b6 50 06          	movzbl 0x6(%eax),%edx
#if defined(CONFIG_NET_BUF_POOL_USAGE)
		pool->avail_count++;
		NET_BUF_ASSERT(pool->avail_count <= pool->buf_count);
#endif

		if (pool->destroy) {
    33ca:	c1 e2 05             	shl    $0x5,%edx
		buf->frags = NULL;
    33cd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		if (pool->destroy) {
    33d3:	81 c2 1c 51 40 00    	add    $0x40511c,%edx
    33d9:	8b 4a 18             	mov    0x18(%edx),%ecx
    33dc:	85 c9                	test   %ecx,%ecx
    33de:	74 06                	je     33e6 <net_buf_unref+0x3a>
			pool->destroy(buf);
    33e0:	50                   	push   %eax
    33e1:	ff d1                	call   *%ecx
    33e3:	59                   	pop    %ecx
    33e4:	eb 09                	jmp    33ef <net_buf_unref+0x43>
 */
static inline void net_buf_destroy(struct net_buf *buf)
{
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);

	k_lifo_put(&pool->free, buf);
    33e6:	50                   	push   %eax
    33e7:	52                   	push   %edx
    33e8:	e8 85 34 00 00       	call   6872 <k_queue_prepend>
    33ed:	58                   	pop    %eax
    33ee:	5a                   	pop    %edx
{
    33ef:	89 d8                	mov    %ebx,%eax
    33f1:	eb c0                	jmp    33b3 <net_buf_unref+0x7>
			net_buf_destroy(buf);
		}

		buf = frags;
	}
}
    33f3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    33f6:	c9                   	leave  
    33f7:	c3                   	ret    

000033f8 <net_buf_frag_last>:

	return clone;
}

struct net_buf *net_buf_frag_last(struct net_buf *buf)
{
    33f8:	55                   	push   %ebp
    33f9:	89 e5                	mov    %esp,%ebp
	NET_BUF_ASSERT(buf);

	while (buf->frags) {
    33fb:	8b 45 08             	mov    0x8(%ebp),%eax
    33fe:	8b 10                	mov    (%eax),%edx
    3400:	85 d2                	test   %edx,%edx
    3402:	74 04                	je     3408 <net_buf_frag_last+0x10>
    3404:	89 d0                	mov    %edx,%eax
    3406:	eb f6                	jmp    33fe <net_buf_frag_last+0x6>
		buf = buf->frags;
	}

	return buf;
}
    3408:	5d                   	pop    %ebp
    3409:	c3                   	ret    

0000340a <net_buf_frag_insert>:

void net_buf_frag_insert(struct net_buf *parent, struct net_buf *frag)
{
    340a:	55                   	push   %ebp
    340b:	89 e5                	mov    %esp,%ebp
    340d:	56                   	push   %esi
    340e:	53                   	push   %ebx
    340f:	8b 55 08             	mov    0x8(%ebp),%edx
    3412:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    3415:	89 c8                	mov    %ecx,%eax
	NET_BUF_ASSERT(parent);
	NET_BUF_ASSERT(frag);

	if (parent->frags) {
    3417:	8b 1a                	mov    (%edx),%ebx
    3419:	85 db                	test   %ebx,%ebx
    341b:	74 0c                	je     3429 <net_buf_frag_insert+0x1f>
	while (buf->frags) {
    341d:	8b 30                	mov    (%eax),%esi
    341f:	85 f6                	test   %esi,%esi
    3421:	74 04                	je     3427 <net_buf_frag_insert+0x1d>
    3423:	89 f0                	mov    %esi,%eax
    3425:	eb f6                	jmp    341d <net_buf_frag_insert+0x13>
		net_buf_frag_last(frag)->frags = parent->frags;
    3427:	89 18                	mov    %ebx,(%eax)
	}
	/* Take ownership of the fragment reference */
	parent->frags = frag;
    3429:	89 0a                	mov    %ecx,(%edx)
}
    342b:	5b                   	pop    %ebx
    342c:	5e                   	pop    %esi
    342d:	5d                   	pop    %ebp
    342e:	c3                   	ret    

0000342f <net_buf_frag_add>:

struct net_buf *net_buf_frag_add(struct net_buf *head, struct net_buf *frag)
{
    342f:	55                   	push   %ebp
    3430:	89 e5                	mov    %esp,%ebp
    3432:	53                   	push   %ebx
    3433:	8b 5d 08             	mov    0x8(%ebp),%ebx
    3436:	8b 45 0c             	mov    0xc(%ebp),%eax
    3439:	89 da                	mov    %ebx,%edx
	NET_BUF_ASSERT(frag);

	if (!head) {
    343b:	85 db                	test   %ebx,%ebx
    343d:	75 05                	jne    3444 <net_buf_frag_add+0x15>
	buf->ref++;
    343f:	fe 40 04             	incb   0x4(%eax)
		return net_buf_ref(frag);
    3442:	eb 15                	jmp    3459 <net_buf_frag_add+0x2a>
	while (buf->frags) {
    3444:	8b 0a                	mov    (%edx),%ecx
    3446:	85 c9                	test   %ecx,%ecx
    3448:	74 04                	je     344e <net_buf_frag_add+0x1f>
    344a:	89 ca                	mov    %ecx,%edx
    344c:	eb f6                	jmp    3444 <net_buf_frag_add+0x15>
	}

	net_buf_frag_insert(net_buf_frag_last(head), frag);
    344e:	50                   	push   %eax
    344f:	52                   	push   %edx
    3450:	e8 b5 ff ff ff       	call   340a <net_buf_frag_insert>
    3455:	58                   	pop    %eax

	return head;
    3456:	89 d8                	mov    %ebx,%eax
	net_buf_frag_insert(net_buf_frag_last(head), frag);
    3458:	5a                   	pop    %edx
}
    3459:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    345c:	c9                   	leave  
    345d:	c3                   	ret    

0000345e <net_buf_frag_del>:
				       struct net_buf *frag,
				       const char *func, int line)
#else
struct net_buf *net_buf_frag_del(struct net_buf *parent, struct net_buf *frag)
#endif
{
    345e:	55                   	push   %ebp
    345f:	89 e5                	mov    %esp,%ebp
    3461:	53                   	push   %ebx
    3462:	8b 45 08             	mov    0x8(%ebp),%eax
    3465:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct net_buf *next_frag;

	NET_BUF_ASSERT(frag);

	if (parent) {
    3468:	85 c0                	test   %eax,%eax
    346a:	74 04                	je     3470 <net_buf_frag_del+0x12>
		NET_BUF_ASSERT(parent->frags);
		NET_BUF_ASSERT(parent->frags == frag);
		parent->frags = frag->frags;
    346c:	8b 0a                	mov    (%edx),%ecx
    346e:	89 08                	mov    %ecx,(%eax)
	}

	next_frag = frag->frags;
    3470:	8b 1a                	mov    (%edx),%ebx

	frag->frags = NULL;
    3472:	c7 02 00 00 00 00    	movl   $0x0,(%edx)

#if defined(CONFIG_NET_BUF_LOG)
	net_buf_unref_debug(frag, func, line);
#else
	net_buf_unref(frag);
    3478:	52                   	push   %edx
    3479:	e8 2e ff ff ff       	call   33ac <net_buf_unref>
    347e:	58                   	pop    %eax
#endif

	return next_frag;
}
    347f:	89 d8                	mov    %ebx,%eax
    3481:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    3484:	c9                   	leave  
    3485:	c3                   	ret    

00003486 <net_buf_simple_add>:
#define NET_BUF_SIMPLE_INFO(fmt, ...)
#define NET_BUF_SIMPLE_ASSERT(cond)
#endif /* CONFIG_NET_BUF_SIMPLE_LOG */

void *net_buf_simple_add(struct net_buf_simple *buf, size_t len)
{
    3486:	55                   	push   %ebp
    3487:	89 e5                	mov    %esp,%ebp
    3489:	8b 4d 08             	mov    0x8(%ebp),%ecx
	return buf->data + buf->len;
    348c:	0f b7 41 04          	movzwl 0x4(%ecx),%eax
    3490:	89 c2                	mov    %eax,%edx
    3492:	03 01                	add    (%ecx),%eax

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	NET_BUF_SIMPLE_ASSERT(net_buf_simple_tailroom(buf) >= len);

	buf->len += len;
    3494:	03 55 0c             	add    0xc(%ebp),%edx
    3497:	66 89 51 04          	mov    %dx,0x4(%ecx)
	return tail;
}
    349b:	5d                   	pop    %ebp
    349c:	c3                   	ret    

0000349d <net_buf_simple_add_u8>:

	return memcpy(net_buf_simple_add(buf, len), mem, len);
}

u8_t *net_buf_simple_add_u8(struct net_buf_simple *buf, u8_t val)
{
    349d:	55                   	push   %ebp
    349e:	89 e5                	mov    %esp,%ebp
    34a0:	8b 4d 08             	mov    0x8(%ebp),%ecx
    34a3:	0f b7 41 04          	movzwl 0x4(%ecx),%eax
    34a7:	89 c2                	mov    %eax,%edx
    34a9:	03 01                	add    (%ecx),%eax
	buf->len += len;
    34ab:	42                   	inc    %edx
    34ac:	66 89 51 04          	mov    %dx,0x4(%ecx)
	u8_t *u8;

	NET_BUF_SIMPLE_DBG("buf %p val 0x%02x", buf, val);

	u8 = net_buf_simple_add(buf, 1);
	*u8 = val;
    34b0:	8b 55 0c             	mov    0xc(%ebp),%edx
    34b3:	88 10                	mov    %dl,(%eax)

	return u8;
}
    34b5:	5d                   	pop    %ebp
    34b6:	c3                   	ret    

000034b7 <net_buf_simple_pull>:

	*data = val;
}

void *net_buf_simple_pull(struct net_buf_simple *buf, size_t len)
{
    34b7:	55                   	push   %ebp
    34b8:	89 e5                	mov    %esp,%ebp
    34ba:	8b 55 08             	mov    0x8(%ebp),%edx
    34bd:	8b 45 0c             	mov    0xc(%ebp),%eax
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	NET_BUF_SIMPLE_ASSERT(buf->len >= len);

	buf->len -= len;
    34c0:	66 29 42 04          	sub    %ax,0x4(%edx)
	return buf->data += len;
    34c4:	03 02                	add    (%edx),%eax
    34c6:	89 02                	mov    %eax,(%edx)
}
    34c8:	5d                   	pop    %ebp
    34c9:	c3                   	ret    

000034ca <net_buf_simple_headroom>:

	return sys_be32_to_cpu(val);
}

size_t net_buf_simple_headroom(struct net_buf_simple *buf)
{
    34ca:	55                   	push   %ebp
    34cb:	89 e5                	mov    %esp,%ebp
    34cd:	8b 45 08             	mov    0x8(%ebp),%eax
	return buf->data - buf->__buf;
}
    34d0:	5d                   	pop    %ebp
	return buf->data - buf->__buf;
    34d1:	8d 50 08             	lea    0x8(%eax),%edx
    34d4:	8b 00                	mov    (%eax),%eax
    34d6:	29 d0                	sub    %edx,%eax
}
    34d8:	c3                   	ret    

000034d9 <net_buf_simple_tailroom>:

size_t net_buf_simple_tailroom(struct net_buf_simple *buf)
{
    34d9:	55                   	push   %ebp
    34da:	89 e5                	mov    %esp,%ebp
    34dc:	8b 55 08             	mov    0x8(%ebp),%edx
	return buf->size - net_buf_simple_headroom(buf) - buf->len;
}
    34df:	5d                   	pop    %ebp
	return buf->data - buf->__buf;
    34e0:	89 d1                	mov    %edx,%ecx
	return buf->size - net_buf_simple_headroom(buf) - buf->len;
    34e2:	0f b7 42 06          	movzwl 0x6(%edx),%eax
	return buf->data - buf->__buf;
    34e6:	2b 0a                	sub    (%edx),%ecx
	return buf->size - net_buf_simple_headroom(buf) - buf->len;
    34e8:	0f b7 52 04          	movzwl 0x4(%edx),%edx
    34ec:	8d 44 01 08          	lea    0x8(%ecx,%eax,1),%eax
    34f0:	29 d0                	sub    %edx,%eax
}
    34f2:	c3                   	ret    

000034f3 <processing_data>:

	return NET_DROP;
}

static void processing_data(struct net_pkt *pkt, bool is_loopback)
{
    34f3:	55                   	push   %ebp
    34f4:	89 e5                	mov    %esp,%ebp
    34f6:	53                   	push   %ebx
	if (!pkt->frags) {
    34f7:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
{
    34fb:	89 c3                	mov    %eax,%ebx
	if (!pkt->frags) {
    34fd:	74 3d                	je     353c <processing_data+0x49>
	if (!is_loopback && !locally_routed) {
    34ff:	84 d2                	test   %dl,%dl
    3501:	74 24                	je     3527 <processing_data+0x34>
    3503:	8b 43 08             	mov    0x8(%ebx),%eax
	switch (NET_IPV6_HDR(pkt)->vtc & 0xf0) {
    3506:	8b 40 08             	mov    0x8(%eax),%eax
    3509:	8a 00                	mov    (%eax),%al
    350b:	83 e0 f0             	and    $0xfffffff0,%eax
    350e:	3c 40                	cmp    $0x40,%al
    3510:	75 2a                	jne    353c <processing_data+0x49>
	pkt->family = family;
    3512:	8a 43 34             	mov    0x34(%ebx),%al
		return net_ipv4_process_pkt(pkt);
    3515:	53                   	push   %ebx
    3516:	83 e0 87             	and    $0xffffff87,%eax
    3519:	83 c8 10             	or     $0x10,%eax
    351c:	88 43 34             	mov    %al,0x34(%ebx)
    351f:	e8 b7 1d 00 00       	call   52db <net_ipv4_process_pkt>
    3524:	5a                   	pop    %edx
    3525:	eb 11                	jmp    3538 <processing_data+0x45>
    3527:	8b 40 14             	mov    0x14(%eax),%eax
	return iface->l2->recv(iface, pkt);
    352a:	8b 50 04             	mov    0x4(%eax),%edx
    352d:	53                   	push   %ebx
    352e:	50                   	push   %eax
    352f:	ff 12                	call   *(%edx)
    3531:	59                   	pop    %ecx
		if (ret != NET_CONTINUE) {
    3532:	83 f8 01             	cmp    $0x1,%eax
    3535:	5a                   	pop    %edx
    3536:	74 cb                	je     3503 <processing_data+0x10>
	switch (process_data(pkt, is_loopback)) {
    3538:	85 c0                	test   %eax,%eax
    353a:	74 07                	je     3543 <processing_data+0x50>
		NET_DBG("Consumed pkt %p", pkt);
		break;
	case NET_DROP:
	default:
		NET_DBG("Dropping pkt %p", pkt);
		net_pkt_unref(pkt);
    353c:	53                   	push   %ebx
    353d:	e8 99 06 00 00       	call   3bdb <net_pkt_unref>
    3542:	58                   	pop    %eax
		break;
	}
}
    3543:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    3546:	c9                   	leave  
    3547:	c3                   	ret    

00003548 <net_init>:

	NET_DBG("Network L2 init done");
}

static int net_init(struct device *unused)
{
    3548:	55                   	push   %ebp
    3549:	89 e5                	mov    %esp,%ebp
	int status = 0;

	NET_DBG("Priority %d", CONFIG_NET_INIT_PRIO);

	net_pkt_init();
    354b:	e8 1c 0c 00 00       	call   416c <net_pkt_init>

	net_context_init();
    3550:	e8 25 05 00 00       	call   3a7a <net_context_init>
	net_arp_init();
    3555:	e8 7f 18 00 00       	call   4dd9 <net_arp_init>
	net_icmpv4_init();
    355a:	e8 58 1d 00 00       	call   52b7 <net_icmpv4_init>
	net_conn_init();
    355f:	e8 aa 23 00 00       	call   590e <net_conn_init>
	net_udp_init();
    3564:	e8 cf 21 00 00       	call   5738 <net_udp_init>

	l2_init();
	l3_init();

	net_mgmt_event_init();
    3569:	e8 c0 1f 00 00       	call   552e <net_mgmt_event_init>
	k_fifo_init(&rx_queue);
    356e:	68 48 52 40 00       	push   $0x405248
    3573:	e8 4b 32 00 00       	call   67c3 <k_queue_init>
	rx_tid = k_thread_create(&rx_thread_data, rx_stack,
    3578:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    357f:	6a 01                	push   $0x1
    3581:	6a f8                	push   $0xfffffff8
    3583:	6a 00                	push   $0x0
    3585:	6a 00                	push   $0x0
    3587:	6a 00                	push   $0x0
    3589:	68 a9 35 00 00       	push   $0x35a9
    358e:	68 dc 05 00 00       	push   $0x5dc
    3593:	68 00 80 40 00       	push   $0x408000
    3598:	68 60 52 40 00       	push   $0x405260
    359d:	e8 35 3c 00 00       	call   71d7 <k_thread_create>
    35a2:	83 c4 28             	add    $0x28,%esp
		return status;
	}
#endif

	return status;
}
    35a5:	31 c0                	xor    %eax,%eax
    35a7:	c9                   	leave  
    35a8:	c3                   	ret    

000035a9 <net_rx_thread>:
{
    35a9:	55                   	push   %ebp
    35aa:	89 e5                	mov    %esp,%ebp
	net_if_init(&startup_sync);
    35ac:	68 ec 50 40 00       	push   $0x4050ec
    35b1:	e8 3b 04 00 00       	call   39f1 <net_if_init>
	k_sem_take(&startup_sync, K_FOREVER);
    35b6:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
    35bd:	68 ec 50 40 00       	push   $0x4050ec
    35c2:	e8 7c 38 00 00       	call   6e43 <k_sem_take>
    35c7:	58                   	pop    %eax
    35c8:	5a                   	pop    %edx
	net_if_post_init();
    35c9:	e8 8a 04 00 00       	call   3a58 <net_if_post_init>
		pkt = k_fifo_get(&rx_queue, K_FOREVER);
    35ce:	6a ff                	push   $0xffffffff
    35d0:	68 48 52 40 00       	push   $0x405248
    35d5:	e8 ad 32 00 00       	call   6887 <k_queue_get>
    35da:	5a                   	pop    %edx
		processing_data(pkt, false);
    35db:	31 d2                	xor    %edx,%edx
		pkt = k_fifo_get(&rx_queue, K_FOREVER);
    35dd:	59                   	pop    %ecx
		processing_data(pkt, false);
    35de:	e8 10 ff ff ff       	call   34f3 <processing_data>
		k_yield();
    35e3:	e8 69 36 00 00       	call   6c51 <k_yield>
    35e8:	eb e4                	jmp    35ce <net_rx_thread+0x25>

000035ea <net_send_data>:
{
    35ea:	55                   	push   %ebp
		return -ENODATA;
    35eb:	b8 b2 ff ff ff       	mov    $0xffffffb2,%eax
{
    35f0:	89 e5                	mov    %esp,%ebp
    35f2:	53                   	push   %ebx
    35f3:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!pkt || !pkt->frags) {
    35f6:	85 db                	test   %ebx,%ebx
    35f8:	0f 84 9c 00 00 00    	je     369a <net_send_data+0xb0>
    35fe:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
    3602:	0f 84 92 00 00 00    	je     369a <net_send_data+0xb0>
		return -EINVAL;
    3608:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	if (!net_pkt_iface(pkt)) {
    360d:	83 7b 14 00          	cmpl   $0x0,0x14(%ebx)
    3611:	0f 84 83 00 00 00    	je     369a <net_send_data+0xb0>
	return pkt->family;
    3617:	8a 43 34             	mov    0x34(%ebx),%al
    361a:	c0 e8 03             	shr    $0x3,%al
    361d:	83 e0 0f             	and    $0xf,%eax
	if (net_pkt_family(pkt) == AF_INET) {
    3620:	3c 02                	cmp    $0x2,%al
    3622:	75 5e                	jne    3682 <net_send_data+0x98>
		if (net_ipv4_addr_cmp(&NET_IPV4_HDR(pkt)->dst,
    3624:	e8 9e 1c 00 00       	call   52c7 <net_ipv4_unspecified_address>
	return pkt->frags->data;
    3629:	8b 53 08             	mov    0x8(%ebx),%edx
    362c:	8b 52 08             	mov    0x8(%edx),%edx
    362f:	8b 00                	mov    (%eax),%eax
    3631:	39 42 10             	cmp    %eax,0x10(%edx)
    3634:	75 07                	jne    363d <net_send_data+0x53>
		return -EINVAL;
    3636:	b8 cf ff ff ff       	mov    $0xffffffcf,%eax
    363b:	eb 5d                	jmp    369a <net_send_data+0xb0>
		if (net_is_ipv4_addr_loopback(&NET_IPV4_HDR(pkt)->dst) ||
    363d:	80 7a 10 7f          	cmpb   $0x7f,0x10(%edx)
    3641:	75 22                	jne    3665 <net_send_data+0x7b>
    3643:	8b 43 08             	mov    0x8(%ebx),%eax
    3646:	8b 40 08             	mov    0x8(%eax),%eax
			net_ipaddr_copy(&addr, &NET_IPV4_HDR(pkt)->src);
    3649:	8b 50 0c             	mov    0xc(%eax),%edx
			net_ipaddr_copy(&NET_IPV4_HDR(pkt)->src,
    364c:	8b 48 10             	mov    0x10(%eax),%ecx
    364f:	89 48 0c             	mov    %ecx,0xc(%eax)
			net_ipaddr_copy(&NET_IPV4_HDR(pkt)->dst, &addr);
    3652:	89 50 10             	mov    %edx,0x10(%eax)
		processing_data(pkt, true);
    3655:	89 d8                	mov    %ebx,%eax
    3657:	ba 01 00 00 00       	mov    $0x1,%edx
    365c:	e8 92 fe ff ff       	call   34f3 <processing_data>
		return 0;
    3661:	31 c0                	xor    %eax,%eax
    3663:	eb 35                	jmp    369a <net_send_data+0xb0>
		    net_is_my_ipv4_addr(&NET_IPV4_HDR(pkt)->dst)) {
    3665:	83 c2 10             	add    $0x10,%edx
 * @return True if IPv4 address is found in one of the network interfaces,
 * False otherwise.
 */
static inline bool net_is_my_ipv4_addr(const struct in_addr *addr)
{
	return net_if_ipv4_addr_lookup(addr, NULL) != NULL;
    3668:	6a 00                	push   $0x0
    366a:	52                   	push   %edx
    366b:	e8 bf 00 00 00       	call   372f <net_if_ipv4_addr_lookup>
    3670:	5a                   	pop    %edx
		if (net_is_ipv4_addr_loopback(&NET_IPV4_HDR(pkt)->dst) ||
    3671:	85 c0                	test   %eax,%eax
    3673:	59                   	pop    %ecx
    3674:	75 cd                	jne    3643 <net_send_data+0x59>
    3676:	8b 43 08             	mov    0x8(%ebx),%eax
		if (net_is_ipv4_addr_loopback(&NET_IPV4_HDR(pkt)->src)) {
    3679:	8b 40 08             	mov    0x8(%eax),%eax
    367c:	80 78 0c 7f          	cmpb   $0x7f,0xc(%eax)
    3680:	74 b4                	je     3636 <net_send_data+0x4c>
	if (net_if_send_data(net_pkt_iface(pkt), pkt) == NET_DROP) {
    3682:	53                   	push   %ebx
    3683:	ff 73 14             	pushl  0x14(%ebx)
    3686:	e8 65 01 00 00       	call   37f0 <net_if_send_data>
    368b:	5a                   	pop    %edx
	return 0;
    368c:	83 f8 02             	cmp    $0x2,%eax
	if (net_if_send_data(net_pkt_iface(pkt), pkt) == NET_DROP) {
    368f:	59                   	pop    %ecx
	return 0;
    3690:	0f 95 c0             	setne  %al
    3693:	0f b6 c0             	movzbl %al,%eax
    3696:	8d 44 80 fb          	lea    -0x5(%eax,%eax,4),%eax
}
    369a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    369d:	c9                   	leave  
    369e:	c3                   	ret    

0000369f <net_recv_data>:
{
    369f:	55                   	push   %ebp
		return -ENODATA;
    36a0:	b8 b2 ff ff ff       	mov    $0xffffffb2,%eax
{
    36a5:	89 e5                	mov    %esp,%ebp
    36a7:	53                   	push   %ebx
    36a8:	8b 55 0c             	mov    0xc(%ebp),%edx
    36ab:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if (!pkt->frags) {
    36ae:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
    36b2:	74 28                	je     36dc <net_recv_data+0x3d>
    36b4:	8b 59 0c             	mov    0xc(%ecx),%ebx
		return -ENETDOWN;
    36b7:	b8 c2 ff ff ff       	mov    $0xffffffc2,%eax
	if (!atomic_test_bit(iface->flags, NET_IF_UP)) {
    36bc:	80 e3 01             	and    $0x1,%bl
    36bf:	74 1b                	je     36dc <net_recv_data+0x3d>
	pkt->iface = iface;
    36c1:	89 4a 14             	mov    %ecx,0x14(%edx)
	pkt->lladdr_src.type = iface->link_addr.type;
    36c4:	8a 41 15             	mov    0x15(%ecx),%al
    36c7:	88 42 25             	mov    %al,0x25(%edx)
	pkt->lladdr_dst.type = iface->link_addr.type;
    36ca:	88 42 2d             	mov    %al,0x2d(%edx)
	k_fifo_put(&rx_queue, pkt);
    36cd:	52                   	push   %edx
    36ce:	68 48 52 40 00       	push   $0x405248
    36d3:	e8 83 31 00 00       	call   685b <k_queue_append>
    36d8:	58                   	pop    %eax
	return 0;
    36d9:	31 c0                	xor    %eax,%eax
	k_fifo_put(&rx_queue, pkt);
    36db:	5a                   	pop    %edx
}
    36dc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    36df:	c9                   	leave  
    36e0:	c3                   	ret    

000036e1 <net_if_get_default>:
	return NULL;
}

struct net_if *net_if_get_default(void)
{
	if (__net_if_start == __net_if_end) {
    36e1:	ba 60 51 40 00       	mov    $0x405160,%edx
{
    36e6:	55                   	push   %ebp
    36e7:	89 e5                	mov    %esp,%ebp
		return NULL;
	}

	return __net_if_start;
    36e9:	89 d0                	mov    %edx,%eax
	if (__net_if_start == __net_if_end) {
    36eb:	81 fa e0 51 40 00    	cmp    $0x4051e0,%edx
    36f1:	75 02                	jne    36f5 <net_if_get_default+0x14>
    36f3:	31 c0                	xor    %eax,%eax
}
    36f5:	5d                   	pop    %ebp
    36f6:	c3                   	ret    

000036f7 <net_if_ipv4_addr_mask_cmp>:
	return NULL;
}

bool net_if_ipv4_addr_mask_cmp(struct net_if *iface,
			       struct in_addr *addr)
{
    36f7:	55                   	push   %ebp
    36f8:	89 e5                	mov    %esp,%ebp
    36fa:	53                   	push   %ebx
    36fb:	8b 45 0c             	mov    0xc(%ebp),%eax
    36fe:	8b 4d 08             	mov    0x8(%ebp),%ecx
    3701:	8b 00                	mov    (%eax),%eax
    3703:	8b 51 78             	mov    0x78(%ecx),%edx
    3706:	0f c8                	bswap  %eax
    3708:	89 c3                	mov    %eax,%ebx
	u32_t subnet = ntohl(addr->s_addr) &
			ntohl(iface->ipv4.netmask.s_addr);
	int i;

	for (i = 0; i < NET_IF_MAX_IPV4_ADDR; i++) {
		if (!iface->ipv4.unicast[i].is_used ||
    370a:	8a 41 65             	mov    0x65(%ecx),%al
    370d:	84 c0                	test   %al,%al
    370f:	74 1b                	je     372c <net_if_ipv4_addr_mask_cmp+0x35>
		     ntohl(iface->ipv4.netmask.s_addr)) == subnet) {
			return true;
		}
	}

	return false;
    3711:	31 c0                	xor    %eax,%eax
		if (!iface->ipv4.unicast[i].is_used ||
    3713:	66 83 79 2c 02       	cmpw   $0x2,0x2c(%ecx)
    3718:	75 12                	jne    372c <net_if_ipv4_addr_mask_cmp+0x35>
    371a:	8b 49 30             	mov    0x30(%ecx),%ecx
	u32_t subnet = ntohl(addr->s_addr) &
    371d:	89 d8                	mov    %ebx,%eax
    371f:	0f ca                	bswap  %edx
    3721:	0f c9                	bswap  %ecx
    3723:	21 d0                	and    %edx,%eax
		if ((ntohl(iface->ipv4.unicast[i].address.in_addr.s_addr) &
    3725:	21 ca                	and    %ecx,%edx
    3727:	39 d0                	cmp    %edx,%eax
    3729:	0f 94 c0             	sete   %al
}
    372c:	5b                   	pop    %ebx
    372d:	5d                   	pop    %ebp
    372e:	c3                   	ret    

0000372f <net_if_ipv4_addr_lookup>:

struct net_if_addr *net_if_ipv4_addr_lookup(const struct in_addr *addr,
					    struct net_if **ret)
{
    372f:	55                   	push   %ebp
	struct net_if *iface;

	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    3730:	b8 60 51 40 00       	mov    $0x405160,%eax
{
    3735:	89 e5                	mov    %esp,%ebp
    3737:	53                   	push   %ebx
    3738:	8b 4d 08             	mov    0x8(%ebp),%ecx
    373b:	8b 55 0c             	mov    0xc(%ebp),%edx
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    373e:	3d e0 51 40 00       	cmp    $0x4051e0,%eax
    3743:	74 24                	je     3769 <net_if_ipv4_addr_lookup+0x3a>
		int i;

		for (i = 0; i < NET_IF_MAX_IPV4_ADDR; i++) {
			if (!iface->ipv4.unicast[i].is_used ||
    3745:	80 78 65 00          	cmpb   $0x0,0x65(%eax)
    3749:	75 05                	jne    3750 <net_if_ipv4_addr_lookup+0x21>
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    374b:	83 e8 80             	sub    $0xffffff80,%eax
    374e:	eb ee                	jmp    373e <net_if_ipv4_addr_lookup+0xf>
			if (!iface->ipv4.unicast[i].is_used ||
    3750:	66 83 78 2c 02       	cmpw   $0x2,0x2c(%eax)
    3755:	75 f4                	jne    374b <net_if_ipv4_addr_lookup+0x1c>
			    iface->ipv4.unicast[i].address.family != AF_INET) {
				continue;
			}

			if (UNALIGNED_GET(&addr->s4_addr32[0]) ==
    3757:	8b 58 30             	mov    0x30(%eax),%ebx
    375a:	39 19                	cmp    %ebx,(%ecx)
    375c:	75 ed                	jne    374b <net_if_ipv4_addr_lookup+0x1c>
			    iface->ipv4.unicast[i].address.in_addr.s_addr) {

				if (ret) {
    375e:	85 d2                	test   %edx,%edx
    3760:	74 02                	je     3764 <net_if_ipv4_addr_lookup+0x35>
					*ret = iface;
    3762:	89 02                	mov    %eax,(%edx)
				}

				return &iface->ipv4.unicast[i];
    3764:	83 c0 2c             	add    $0x2c,%eax
    3767:	eb 02                	jmp    376b <net_if_ipv4_addr_lookup+0x3c>
			}
		}
	}

	return NULL;
    3769:	31 c0                	xor    %eax,%eax
}
    376b:	5b                   	pop    %ebx
    376c:	5d                   	pop    %ebp
    376d:	c3                   	ret    

0000376e <net_if_ipv4_addr_add>:

struct net_if_addr *net_if_ipv4_addr_add(struct net_if *iface,
					 struct in_addr *addr,
					 enum net_addr_type addr_type,
					 u32_t vlifetime)
{
    376e:	55                   	push   %ebp
    376f:	89 e5                	mov    %esp,%ebp
    3771:	53                   	push   %ebx
    3772:	8b 5d 08             	mov    0x8(%ebp),%ebx
    3775:	8b 55 0c             	mov    0xc(%ebp),%edx
		if (!iface->ipv4.unicast[i].is_used) {
    3778:	80 7b 65 00          	cmpb   $0x0,0x65(%ebx)
    377c:	74 0b                	je     3789 <net_if_ipv4_addr_add+0x1b>
		if (net_ipv4_addr_cmp(addr,
    377e:	8b 4b 30             	mov    0x30(%ebx),%ecx
		net_mgmt_event_notify(NET_EVENT_IPV4_ADDR_ADD, iface);

		return &iface->ipv4.unicast[i];
	}

	return NULL;
    3781:	31 c0                	xor    %eax,%eax
		if (net_ipv4_addr_cmp(addr,
    3783:	39 0a                	cmp    %ecx,(%edx)
    3785:	75 36                	jne    37bd <net_if_ipv4_addr_add+0x4f>
    3787:	eb 31                	jmp    37ba <net_if_ipv4_addr_add+0x4c>
		iface->ipv4.unicast[i].is_used = true;
    3789:	c6 43 65 01          	movb   $0x1,0x65(%ebx)
		iface->ipv4.unicast[i].address.family = AF_INET;
    378d:	66 c7 43 2c 02 00    	movw   $0x2,0x2c(%ebx)
						addr->s4_addr32[0];
    3793:	8b 02                	mov    (%edx),%eax
		iface->ipv4.unicast[i].addr_state = NET_ADDR_PREFERRED;
    3795:	c7 43 60 01 00 00 00 	movl   $0x1,0x60(%ebx)
		iface->ipv4.unicast[i].address.in_addr.s4_addr32[0] =
    379c:	89 43 30             	mov    %eax,0x30(%ebx)
		iface->ipv4.unicast[i].addr_type = addr_type;
    379f:	8b 45 10             	mov    0x10(%ebp),%eax
    37a2:	89 43 5c             	mov    %eax,0x5c(%ebx)
			iface->ipv4.unicast[i].is_infinite = false;
    37a5:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    37a9:	0f 94 43 64          	sete   0x64(%ebx)
		net_mgmt_event_notify(NET_EVENT_IPV4_ADDR_ADD, iface);
    37ad:	53                   	push   %ebx
    37ae:	68 00 00 04 f0       	push   $0xf0040000
    37b3:	e8 f6 1c 00 00       	call   54ae <net_mgmt_event_notify>
    37b8:	58                   	pop    %eax
    37b9:	5a                   	pop    %edx
		return &iface->ipv4.unicast[i];
    37ba:	8d 43 2c             	lea    0x2c(%ebx),%eax
}
    37bd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    37c0:	c9                   	leave  
    37c1:	c3                   	ret    

000037c2 <net_if_call_link_cb>:
	sys_slist_find_and_remove(&link_callbacks, &link->node);
}

void net_if_call_link_cb(struct net_if *iface, struct net_linkaddr *lladdr,
			 int status)
{
    37c2:	a1 d8 52 40 00       	mov    0x4052d8,%eax
	struct net_if_link_cb *link, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&link_callbacks, link, tmp, node) {
    37c7:	85 c0                	test   %eax,%eax
    37c9:	75 01                	jne    37cc <net_if_call_link_cb+0xa>
    37cb:	c3                   	ret    
{
    37cc:	55                   	push   %ebp
    37cd:	89 e5                	mov    %esp,%ebp
    37cf:	53                   	push   %ebx
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next_no_check(sys_snode_t *node)
{
	return node->next;
    37d0:	8b 18                	mov    (%eax),%ebx
		link->cb(iface, lladdr, status);
    37d2:	ff 75 10             	pushl  0x10(%ebp)
    37d5:	ff 75 0c             	pushl  0xc(%ebp)
    37d8:	ff 75 08             	pushl  0x8(%ebp)
    37db:	ff 50 04             	call   *0x4(%eax)
    37de:	83 c4 0c             	add    $0xc,%esp
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&link_callbacks, link, tmp, node) {
    37e1:	85 db                	test   %ebx,%ebx
    37e3:	74 06                	je     37eb <net_if_call_link_cb+0x29>
    37e5:	89 d8                	mov    %ebx,%eax
    37e7:	8b 1b                	mov    (%ebx),%ebx
    37e9:	eb e7                	jmp    37d2 <net_if_call_link_cb+0x10>
	}
}
    37eb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    37ee:	c9                   	leave  
    37ef:	c3                   	ret    

000037f0 <net_if_send_data>:
{
    37f0:	55                   	push   %ebp
    37f1:	89 e5                	mov    %esp,%ebp
    37f3:	57                   	push   %edi
    37f4:	56                   	push   %esi
    37f5:	53                   	push   %ebx
    37f6:	83 ec 08             	sub    $0x8,%esp
    37f9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    37fc:	8b 75 08             	mov    0x8(%ebp),%esi
    37ff:	8b 43 10             	mov    0x10(%ebx),%eax
    3802:	8b 53 0c             	mov    0xc(%ebx),%edx
    3805:	89 45 f0             	mov    %eax,-0x10(%ebp)
    3808:	8b 46 0c             	mov    0xc(%esi),%eax
	if (!atomic_test_bit(iface->flags, NET_IF_UP)) {
    380b:	a8 01                	test   $0x1,%al
    380d:	74 35                	je     3844 <net_if_send_data+0x54>
    380f:	8b 46 0c             	mov    0xc(%esi),%eax
	if (!atomic_test_bit(iface->flags, NET_IF_POINTOPOINT) &&
    3812:	a8 02                	test   $0x2,%al
    3814:	75 15                	jne    382b <net_if_send_data+0x3b>
    3816:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
    381a:	75 0f                	jne    382b <net_if_send_data+0x3b>
    381c:	8b 43 14             	mov    0x14(%ebx),%eax
		net_pkt_ll_src(pkt)->addr = net_pkt_ll_if(pkt)->addr;
    381f:	8b 48 10             	mov    0x10(%eax),%ecx
    3822:	89 4b 20             	mov    %ecx,0x20(%ebx)
		net_pkt_ll_src(pkt)->len = net_pkt_ll_if(pkt)->len;
    3825:	8a 40 14             	mov    0x14(%eax),%al
    3828:	88 43 24             	mov    %al,0x24(%ebx)
	verdict = iface->l2->send(iface, pkt);
    382b:	8b 46 04             	mov    0x4(%esi),%eax
    382e:	89 55 ec             	mov    %edx,-0x14(%ebp)
    3831:	53                   	push   %ebx
    3832:	56                   	push   %esi
    3833:	ff 50 04             	call   *0x4(%eax)
    3836:	5a                   	pop    %edx
    3837:	89 c7                	mov    %eax,%edi
    3839:	59                   	pop    %ecx
	int status = -EIO;
    383a:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    383f:	8b 55 ec             	mov    -0x14(%ebp),%edx
    3842:	eb 0a                	jmp    384e <net_if_send_data+0x5e>
		status = -ENETDOWN;
    3844:	b8 c2 ff ff ff       	mov    $0xffffffc2,%eax
		verdict = NET_DROP;
    3849:	bf 02 00 00 00       	mov    $0x2,%edi
	if (context && verdict == NET_DROP) {
    384e:	85 d2                	test   %edx,%edx
    3850:	74 20                	je     3872 <net_if_send_data+0x82>
    3852:	83 ff 02             	cmp    $0x2,%edi
    3855:	75 1b                	jne    3872 <net_if_send_data+0x82>
	if (context->send_cb) {
    3857:	8b 4a 20             	mov    0x20(%edx),%ecx
    385a:	85 c9                	test   %ecx,%ecx
    385c:	74 19                	je     3877 <net_if_send_data+0x87>
		context->send_cb(context, status, token, context->user_data);
    385e:	ff 32                	pushl  (%edx)
    3860:	ff 75 f0             	pushl  -0x10(%ebp)
    3863:	50                   	push   %eax
    3864:	52                   	push   %edx
    3865:	89 45 f0             	mov    %eax,-0x10(%ebp)
    3868:	ff d1                	call   *%ecx
    386a:	83 c4 10             	add    $0x10,%esp
    386d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3870:	eb 05                	jmp    3877 <net_if_send_data+0x87>
	if (verdict == NET_DROP && dst->addr) {
    3872:	83 ff 02             	cmp    $0x2,%edi
    3875:	75 14                	jne    388b <net_if_send_data+0x9b>
    3877:	83 7b 28 00          	cmpl   $0x0,0x28(%ebx)
    387b:	74 0e                	je     388b <net_if_send_data+0x9b>
	return &pkt->lladdr_src;
}

static inline struct net_linkaddr *net_pkt_ll_dst(struct net_pkt *pkt)
{
	return &pkt->lladdr_dst;
    387d:	83 c3 28             	add    $0x28,%ebx
		net_if_call_link_cb(iface, dst, status);
    3880:	50                   	push   %eax
    3881:	53                   	push   %ebx
    3882:	56                   	push   %esi
    3883:	e8 3a ff ff ff       	call   37c2 <net_if_call_link_cb>
    3888:	83 c4 0c             	add    $0xc,%esp
}
    388b:	8d 65 f4             	lea    -0xc(%ebp),%esp
    388e:	89 f8                	mov    %edi,%eax
    3890:	5b                   	pop    %ebx
    3891:	5e                   	pop    %esi
    3892:	5f                   	pop    %edi
    3893:	5d                   	pop    %ebp
    3894:	c3                   	ret    

00003895 <net_if_tx>:
{
    3895:	55                   	push   %ebp
    3896:	89 e5                	mov    %esp,%ebp
    3898:	57                   	push   %edi
    3899:	56                   	push   %esi
    389a:	53                   	push   %ebx
    389b:	83 ec 0c             	sub    $0xc,%esp
    389e:	89 c6                	mov    %eax,%esi
	const struct net_if_api *api = iface->dev->driver_api;
    38a0:	8b 00                	mov    (%eax),%eax
    38a2:	8b 48 04             	mov    0x4(%eax),%ecx
	pkt = k_fifo_get(&iface->tx_queue, K_NO_WAIT);
    38a5:	8d 46 18             	lea    0x18(%esi),%eax
    38a8:	6a 00                	push   $0x0
	const struct net_if_api *api = iface->dev->driver_api;
    38aa:	89 4d e8             	mov    %ecx,-0x18(%ebp)
	pkt = k_fifo_get(&iface->tx_queue, K_NO_WAIT);
    38ad:	50                   	push   %eax
    38ae:	e8 d4 2f 00 00       	call   6887 <k_queue_get>
    38b3:	5b                   	pop    %ebx
	if (!pkt) {
    38b4:	85 c0                	test   %eax,%eax
	pkt = k_fifo_get(&iface->tx_queue, K_NO_WAIT);
    38b6:	5f                   	pop    %edi
	if (!pkt) {
    38b7:	74 70                	je     3929 <net_if_tx+0x94>
    38b9:	89 c3                	mov    %eax,%ebx
    38bb:	8d 40 28             	lea    0x28(%eax),%eax
    38be:	89 45 f0             	mov    %eax,-0x10(%ebp)
		status = -ENETDOWN;
    38c1:	bf c2 ff ff ff       	mov    $0xffffffc2,%edi
    38c6:	8b 43 10             	mov    0x10(%ebx),%eax
    38c9:	8b 53 0c             	mov    0xc(%ebx),%edx
    38cc:	89 45 ec             	mov    %eax,-0x14(%ebp)
    38cf:	8b 46 0c             	mov    0xc(%esi),%eax
	if (atomic_test_bit(iface->flags, NET_IF_UP)) {
    38d2:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    38d5:	a8 01                	test   $0x1,%al
    38d7:	74 13                	je     38ec <net_if_tx+0x57>
		status = api->send(iface, pkt);
    38d9:	53                   	push   %ebx
    38da:	89 55 e8             	mov    %edx,-0x18(%ebp)
    38dd:	56                   	push   %esi
    38de:	ff 51 04             	call   *0x4(%ecx)
    38e1:	5a                   	pop    %edx
    38e2:	89 c7                	mov    %eax,%edi
    38e4:	59                   	pop    %ecx
	if (status < 0) {
    38e5:	85 c0                	test   %eax,%eax
    38e7:	8b 55 e8             	mov    -0x18(%ebp),%edx
    38ea:	79 0d                	jns    38f9 <net_if_tx+0x64>
    38ec:	89 55 e8             	mov    %edx,-0x18(%ebp)
		net_pkt_unref(pkt);
    38ef:	53                   	push   %ebx
    38f0:	e8 e6 02 00 00       	call   3bdb <net_pkt_unref>
    38f5:	58                   	pop    %eax
    38f6:	8b 55 e8             	mov    -0x18(%ebp),%edx
	if (context) {
    38f9:	85 d2                	test   %edx,%edx
    38fb:	74 13                	je     3910 <net_if_tx+0x7b>
	if (context->send_cb) {
    38fd:	8b 42 20             	mov    0x20(%edx),%eax
    3900:	85 c0                	test   %eax,%eax
    3902:	74 0c                	je     3910 <net_if_tx+0x7b>
		context->send_cb(context, status, token, context->user_data);
    3904:	ff 32                	pushl  (%edx)
    3906:	ff 75 ec             	pushl  -0x14(%ebp)
    3909:	57                   	push   %edi
    390a:	52                   	push   %edx
    390b:	ff d0                	call   *%eax
    390d:	83 c4 10             	add    $0x10,%esp
	return true;
    3910:	b0 01                	mov    $0x1,%al
	if (dst->addr) {
    3912:	83 7b 28 00          	cmpl   $0x0,0x28(%ebx)
    3916:	74 13                	je     392b <net_if_tx+0x96>
		net_if_call_link_cb(iface, dst, status);
    3918:	57                   	push   %edi
    3919:	ff 75 f0             	pushl  -0x10(%ebp)
    391c:	56                   	push   %esi
    391d:	e8 a0 fe ff ff       	call   37c2 <net_if_call_link_cb>
    3922:	83 c4 0c             	add    $0xc,%esp
	return true;
    3925:	b0 01                	mov    $0x1,%al
    3927:	eb 02                	jmp    392b <net_if_tx+0x96>
		return false;
    3929:	31 c0                	xor    %eax,%eax
}
    392b:	8d 65 f4             	lea    -0xc(%ebp),%esp
    392e:	5b                   	pop    %ebx
    392f:	5e                   	pop    %esi
    3930:	5f                   	pop    %edi
    3931:	5d                   	pop    %ebp
    3932:	c3                   	ret    

00003933 <net_if_tx_thread>:
{
    3933:	55                   	push   %ebp
    3934:	89 e5                	mov    %esp,%ebp
    3936:	57                   	push   %edi
    3937:	56                   	push   %esi
    3938:	53                   	push   %ebx
	k_sem_give(startup_sync);
    3939:	ff 75 08             	pushl  0x8(%ebp)
    393c:	e8 69 34 00 00       	call   6daa <k_sem_give>
    3941:	58                   	pop    %eax
    3942:	bf e0 51 40 00       	mov    $0x4051e0,%edi
	int ev_count = 0;
    3947:	31 db                	xor    %ebx,%ebx
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    3949:	be 60 51 40 00       	mov    $0x405160,%esi
    394e:	81 fe e0 51 40 00    	cmp    $0x4051e0,%esi
    3954:	74 1a                	je     3970 <net_if_tx_thread+0x3d>
		k_poll_event_init(&__net_if_event_start[ev_count],
    3956:	8d 46 18             	lea    0x18(%esi),%eax
		ev_count++;
    3959:	43                   	inc    %ebx
		k_poll_event_init(&__net_if_event_start[ev_count],
    395a:	50                   	push   %eax
    395b:	6a 00                	push   $0x0
    395d:	6a 04                	push   $0x4
    395f:	57                   	push   %edi
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    3960:	83 ee 80             	sub    $0xffffff80,%esi
		k_poll_event_init(&__net_if_event_start[ev_count],
    3963:	e8 6f 2c 00 00       	call   65d7 <k_poll_event_init>
    3968:	83 c7 14             	add    $0x14,%edi
    396b:	83 c4 10             	add    $0x10,%esp
    396e:	eb de                	jmp    394e <net_if_tx_thread+0x1b>
		ret = k_poll(__net_if_event_start, ev_count, K_FOREVER);
    3970:	6a ff                	push   $0xffffffff
    3972:	53                   	push   %ebx
    3973:	68 e0 51 40 00       	push   $0x4051e0
    3978:	be e0 51 40 00       	mov    $0x4051e0,%esi
    397d:	e8 89 2c 00 00       	call   660b <k_poll>
    3982:	83 c4 0c             	add    $0xc,%esp
	for (; ev_count; event++, ev_count--) {
    3985:	85 db                	test   %ebx,%ebx
    3987:	74 1b                	je     39a4 <net_if_tx_thread+0x71>
		switch (event->state) {
    3989:	8a 46 0d             	mov    0xd(%esi),%al
    398c:	c0 e8 04             	shr    $0x4,%al
    398f:	3c 04                	cmp    $0x4,%al
    3991:	75 0b                	jne    399e <net_if_tx_thread+0x6b>
			iface = CONTAINER_OF(event->fifo, struct net_if,
    3993:	8b 46 10             	mov    0x10(%esi),%eax
    3996:	83 e8 18             	sub    $0x18,%eax
			net_if_tx(iface);
    3999:	e8 f7 fe ff ff       	call   3895 <net_if_tx>
	for (; ev_count; event++, ev_count--) {
    399e:	83 c6 14             	add    $0x14,%esi
    39a1:	4b                   	dec    %ebx
    39a2:	eb e1                	jmp    3985 <net_if_tx_thread+0x52>
		k_yield();
    39a4:	e8 a8 32 00 00       	call   6c51 <k_yield>
    39a9:	eb 97                	jmp    3942 <net_if_tx_thread+0xf>

000039ab <net_if_up>:
		cb(iface, user_data);
	}
}

int net_if_up(struct net_if *iface)
{
    39ab:	55                   	push   %ebp
	int status;

	NET_DBG("iface %p", iface);

	if (atomic_test_bit(iface->flags, NET_IF_UP)) {
		return 0;
    39ac:	31 c0                	xor    %eax,%eax
{
    39ae:	89 e5                	mov    %esp,%ebp
    39b0:	56                   	push   %esi
    39b1:	53                   	push   %ebx
    39b2:	8b 5d 08             	mov    0x8(%ebp),%ebx
    39b5:	8b 53 0c             	mov    0xc(%ebx),%edx
	if (atomic_test_bit(iface->flags, NET_IF_UP)) {
    39b8:	80 e2 01             	and    $0x1,%dl
    39bb:	75 2d                	jne    39ea <net_if_up+0x3f>
	}

	/* If the L2 does not support enable just set the flag */
	if (!iface->l2->enable) {
    39bd:	8b 43 04             	mov    0x4(%ebx),%eax
    39c0:	8d 73 0c             	lea    0xc(%ebx),%esi
    39c3:	8b 40 0c             	mov    0xc(%eax),%eax
    39c6:	85 c0                	test   %eax,%eax
    39c8:	75 15                	jne    39df <net_if_up+0x34>
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_or(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    39ca:	f0 83 0e 01          	lock orl $0x1,(%esi)
#if defined(CONFIG_NET_IPV6_ND)
	NET_DBG("Starting ND/RS for iface %p", iface);
	net_if_start_rs(iface);
#endif

	net_mgmt_event_notify(NET_EVENT_IF_UP, iface);
    39ce:	53                   	push   %ebx
    39cf:	68 01 00 01 d0       	push   $0xd0010001
    39d4:	e8 d5 1a 00 00       	call   54ae <net_mgmt_event_notify>
    39d9:	5b                   	pop    %ebx

	return 0;
    39da:	31 c0                	xor    %eax,%eax
	net_mgmt_event_notify(NET_EVENT_IF_UP, iface);
    39dc:	5e                   	pop    %esi
	return 0;
    39dd:	eb 0b                	jmp    39ea <net_if_up+0x3f>
	status = iface->l2->enable(iface, true);
    39df:	6a 01                	push   $0x1
    39e1:	53                   	push   %ebx
    39e2:	ff d0                	call   *%eax
    39e4:	5a                   	pop    %edx
	if (status < 0) {
    39e5:	85 c0                	test   %eax,%eax
	status = iface->l2->enable(iface, true);
    39e7:	59                   	pop    %ecx
	if (status < 0) {
    39e8:	79 e0                	jns    39ca <net_if_up+0x1f>
}
    39ea:	8d 65 f8             	lea    -0x8(%ebp),%esp
    39ed:	5b                   	pop    %ebx
    39ee:	5e                   	pop    %esi
    39ef:	5d                   	pop    %ebp
    39f0:	c3                   	ret    

000039f1 <net_if_init>:

	return 0;
}

void net_if_init(struct k_sem *startup_sync)
{
    39f1:	55                   	push   %ebp
    39f2:	89 e5                	mov    %esp,%ebp
    39f4:	56                   	push   %esi
    39f5:	53                   	push   %ebx
	struct net_if *iface;

	NET_DBG("");

	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    39f6:	bb 60 51 40 00       	mov    $0x405160,%ebx
    39fb:	81 fb e0 51 40 00    	cmp    $0x4051e0,%ebx
    3a01:	74 1d                	je     3a20 <net_if_init+0x2f>
	const struct net_if_api *api = iface->dev->driver_api;
    3a03:	8b 03                	mov    (%ebx),%eax
    3a05:	8b 70 04             	mov    0x4(%eax),%esi
	k_fifo_init(&iface->tx_queue);
    3a08:	8d 43 18             	lea    0x18(%ebx),%eax
    3a0b:	50                   	push   %eax
    3a0c:	e8 b2 2d 00 00       	call   67c3 <k_queue_init>
	api->init(iface);
    3a11:	89 1c 24             	mov    %ebx,(%esp)
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    3a14:	83 eb 80             	sub    $0xffffff80,%ebx
	api->init(iface);
    3a17:	ff 16                	call   *(%esi)
		init_iface(iface);

#if defined(CONFIG_NET_IPV4)
		iface->ipv4.ttl = CONFIG_NET_INITIAL_TTL;
    3a19:	c6 43 fc 40          	movb   $0x40,-0x4(%ebx)
	api->init(iface);
    3a1d:	58                   	pop    %eax
    3a1e:	eb db                	jmp    39fb <net_if_init+0xa>
		k_delayed_work_init(&iface->ipv6.rs_timer, rs_timeout);
#endif
#endif
	}

	if (iface == __net_if_start) {
    3a20:	81 fb 60 51 40 00    	cmp    $0x405160,%ebx
    3a26:	74 29                	je     3a51 <net_if_init+0x60>
		NET_WARN("There is no network interface to work with!");
		return;
	}

	k_thread_create(&tx_thread_data, tx_stack,
    3a28:	6a 00                	push   $0x0
    3a2a:	6a 01                	push   $0x1
    3a2c:	6a f7                	push   $0xfffffff7
    3a2e:	6a 00                	push   $0x0
    3a30:	6a 00                	push   $0x0
    3a32:	ff 75 08             	pushl  0x8(%ebp)
    3a35:	68 33 39 00 00       	push   $0x3933
    3a3a:	68 b0 04 00 00       	push   $0x4b0
    3a3f:	68 00 a0 40 00       	push   $0x40a000
    3a44:	68 a0 52 40 00       	push   $0x4052a0
    3a49:	e8 89 37 00 00       	call   71d7 <k_thread_create>
    3a4e:	83 c4 28             	add    $0x28,%esp
			K_THREAD_STACK_SIZEOF(tx_stack),
			(k_thread_entry_t)net_if_tx_thread,
			startup_sync, NULL, NULL, K_PRIO_COOP(7),
			K_ESSENTIAL, K_NO_WAIT);
}
    3a51:	8d 65 f8             	lea    -0x8(%ebp),%esp
    3a54:	5b                   	pop    %ebx
    3a55:	5e                   	pop    %esi
    3a56:	5d                   	pop    %ebp
    3a57:	c3                   	ret    

00003a58 <net_if_post_init>:

void net_if_post_init(void)
{
    3a58:	55                   	push   %ebp
    3a59:	89 e5                	mov    %esp,%ebp
    3a5b:	53                   	push   %ebx
	struct net_if *iface;

	NET_DBG("");

	/* After TX is running, attempt to bring the interface up */
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    3a5c:	bb 60 51 40 00       	mov    $0x405160,%ebx
    3a61:	81 fb e0 51 40 00    	cmp    $0x4051e0,%ebx
    3a67:	74 0c                	je     3a75 <net_if_post_init+0x1d>
		net_if_up(iface);
    3a69:	53                   	push   %ebx
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    3a6a:	83 eb 80             	sub    $0xffffff80,%ebx
		net_if_up(iface);
    3a6d:	e8 39 ff ff ff       	call   39ab <net_if_up>
    3a72:	58                   	pop    %eax
    3a73:	eb ec                	jmp    3a61 <net_if_post_init+0x9>

	/* RPL init must be done after the network interface is up
	 * as the RPL code wants to add multicast address to interface.
	 */
	net_rpl_init();
}
    3a75:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    3a78:	c9                   	leave  
    3a79:	c3                   	ret    

00003a7a <net_context_init>:

	k_sem_give(&contexts_lock);
}

void net_context_init(void)
{
    3a7a:	55                   	push   %ebp
    3a7b:	89 e5                	mov    %esp,%ebp
	k_sem_init(&contexts_lock, 1, UINT_MAX);
    3a7d:	6a ff                	push   $0xffffffff
    3a7f:	6a 01                	push   $0x1
    3a81:	68 e0 52 40 00       	push   $0x4052e0
    3a86:	e8 fd 32 00 00       	call   6d88 <k_sem_init>
    3a8b:	83 c4 0c             	add    $0xc,%esp
}
    3a8e:	c9                   	leave  
    3a8f:	c3                   	ret    

00003a90 <net_pkt_get_reserve>:
#else /* CONFIG_NET_DEBUG_NET_PKT */
struct net_pkt *net_pkt_get_reserve(struct k_mem_slab *slab,
				    u16_t reserve_head,
				    s32_t timeout)
#endif /* CONFIG_NET_DEBUG_NET_PKT */
{
    3a90:	55                   	push   %ebp
    3a91:	89 e5                	mov    %esp,%ebp
    3a93:	56                   	push   %esi
    3a94:	53                   	push   %ebx
    3a95:	50                   	push   %eax
    3a96:	8b 5d 08             	mov    0x8(%ebp),%ebx
    3a99:	8b 75 0c             	mov    0xc(%ebp),%esi
	struct net_pkt *pkt;
	int ret;

	if (k_is_in_isr()) {
    3a9c:	e8 03 36 00 00       	call   70a4 <k_is_in_isr>
    3aa1:	85 c0                	test   %eax,%eax
    3aa3:	8d 45 f4             	lea    -0xc(%ebp),%eax
    3aa6:	74 04                	je     3aac <net_pkt_get_reserve+0x1c>
		ret = k_mem_slab_alloc(slab, (void **)&pkt, K_NO_WAIT);
    3aa8:	6a 00                	push   $0x0
    3aaa:	eb 03                	jmp    3aaf <net_pkt_get_reserve+0x1f>
	} else {
		ret = k_mem_slab_alloc(slab, (void **)&pkt, timeout);
    3aac:	ff 75 10             	pushl  0x10(%ebp)
    3aaf:	50                   	push   %eax
    3ab0:	53                   	push   %ebx
    3ab1:	e8 04 28 00 00       	call   62ba <k_mem_slab_alloc>
    3ab6:	83 c4 0c             	add    $0xc,%esp
	}

	if (ret) {
		return NULL;
    3ab9:	31 d2                	xor    %edx,%edx
	if (ret) {
    3abb:	85 c0                	test   %eax,%eax
    3abd:	75 1e                	jne    3add <net_pkt_get_reserve+0x4d>
	}

	memset(pkt, 0, sizeof(struct net_pkt));
    3abf:	6a 38                	push   $0x38
    3ac1:	6a 00                	push   $0x0
    3ac3:	ff 75 f4             	pushl  -0xc(%ebp)
    3ac6:	e8 78 e6 ff ff       	call   2143 <memset>

	net_pkt_set_ll_reserve(pkt, reserve_head);
    3acb:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3ace:	89 f0                	mov    %esi,%eax
	memset(pkt, 0, sizeof(struct net_pkt));
    3ad0:	83 c4 0c             	add    $0xc,%esp
	net_pkt_set_ll_reserve(pkt, reserve_head);
    3ad3:	88 42 32             	mov    %al,0x32(%edx)

	pkt->ref = 1;
    3ad6:	c6 42 36 01          	movb   $0x1,0x36(%edx)
	pkt->slab = slab;
    3ada:	89 5a 04             	mov    %ebx,0x4(%edx)
	NET_DBG("%s [%u] pkt %p reserve %u ref %d (%s():%d)",
		slab2str(slab), k_mem_slab_num_free_get(slab),
		pkt, reserve_head, pkt->ref, caller, line);
#endif
	return pkt;
}
    3add:	8d 65 f8             	lea    -0x8(%ebp),%esp
    3ae0:	89 d0                	mov    %edx,%eax
    3ae2:	5b                   	pop    %ebx
    3ae3:	5e                   	pop    %esi
    3ae4:	5d                   	pop    %ebp
    3ae5:	c3                   	ret    

00003ae6 <net_pkt_get_reserve_data>:
#else /* CONFIG_NET_DEBUG_NET_PKT */
struct net_buf *net_pkt_get_reserve_data(struct net_buf_pool *pool,
					 u16_t reserve_head,
					 s32_t timeout)
#endif /* CONFIG_NET_DEBUG_NET_PKT */
{
    3ae6:	55                   	push   %ebp
    3ae7:	89 e5                	mov    %esp,%ebp
    3ae9:	56                   	push   %esi
    3aea:	53                   	push   %ebx
    3aeb:	50                   	push   %eax
    3aec:	8b 75 08             	mov    0x8(%ebp),%esi
    3aef:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	/*
	 * The reserve_head variable in the function will tell
	 * the size of the link layer headers if there are any.
	 */

	if (k_is_in_isr()) {
    3af2:	e8 ad 35 00 00       	call   70a4 <k_is_in_isr>
    3af7:	85 c0                	test   %eax,%eax
    3af9:	74 04                	je     3aff <net_pkt_get_reserve_data+0x19>
		frag = net_buf_alloc(pool, K_NO_WAIT);
    3afb:	6a 00                	push   $0x0
    3afd:	eb 03                	jmp    3b02 <net_pkt_get_reserve_data+0x1c>
	} else {
		frag = net_buf_alloc(pool, timeout);
    3aff:	ff 75 10             	pushl  0x10(%ebp)
    3b02:	56                   	push   %esi
    3b03:	e8 df f7 ff ff       	call   32e7 <net_buf_alloc>
    3b08:	59                   	pop    %ecx
	}

	if (!frag) {
    3b09:	85 c0                	test   %eax,%eax
		frag = net_buf_alloc(pool, timeout);
    3b0b:	5e                   	pop    %esi
	if (!frag) {
    3b0c:	74 12                	je     3b20 <net_pkt_get_reserve_data+0x3a>
		return NULL;
	}

	net_buf_reserve(frag, reserve_head);
    3b0e:	0f b7 db             	movzwl %bx,%ebx
    3b11:	53                   	push   %ebx
    3b12:	89 45 f4             	mov    %eax,-0xc(%ebp)
    3b15:	50                   	push   %eax
    3b16:	e8 80 f8 ff ff       	call   339b <net_buf_reserve>
    3b1b:	58                   	pop    %eax
    3b1c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3b1f:	5a                   	pop    %edx
		pool2str(pool), pool->name, get_frees(pool),
		frag, reserve_head, frag->ref, caller, line);
#endif

	return frag;
}
    3b20:	8d 65 f8             	lea    -0x8(%ebp),%esp
    3b23:	5b                   	pop    %ebx
    3b24:	5e                   	pop    %esi
    3b25:	5d                   	pop    %ebp
    3b26:	c3                   	ret    

00003b27 <net_pkt_get_reserve_rx>:

#else /* CONFIG_NET_DEBUG_NET_PKT */

struct net_pkt *net_pkt_get_reserve_rx(u16_t reserve_head,
				       s32_t timeout)
{
    3b27:	55                   	push   %ebp
    3b28:	89 e5                	mov    %esp,%ebp
	return net_pkt_get_reserve(&rx_pkts, reserve_head, timeout);
    3b2a:	ff 75 0c             	pushl  0xc(%ebp)
    3b2d:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
    3b31:	50                   	push   %eax
    3b32:	68 9c 50 40 00       	push   $0x40509c
    3b37:	e8 54 ff ff ff       	call   3a90 <net_pkt_get_reserve>
    3b3c:	83 c4 0c             	add    $0xc,%esp
}
    3b3f:	c9                   	leave  
    3b40:	c3                   	ret    

00003b41 <net_pkt_get_reserve_tx>:

struct net_pkt *net_pkt_get_reserve_tx(u16_t reserve_head,
				       s32_t timeout)
{
    3b41:	55                   	push   %ebp
    3b42:	89 e5                	mov    %esp,%ebp
	return net_pkt_get_reserve(&tx_pkts, reserve_head, timeout);
    3b44:	ff 75 0c             	pushl  0xc(%ebp)
    3b47:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
    3b4b:	50                   	push   %eax
    3b4c:	68 b8 50 40 00       	push   $0x4050b8
    3b51:	e8 3a ff ff ff       	call   3a90 <net_pkt_get_reserve>
    3b56:	83 c4 0c             	add    $0xc,%esp
}
    3b59:	c9                   	leave  
    3b5a:	c3                   	ret    

00003b5b <net_pkt_get_reserve_rx_data>:

struct net_buf *net_pkt_get_reserve_rx_data(u16_t reserve_head,
					    s32_t timeout)
{
    3b5b:	55                   	push   %ebp
    3b5c:	89 e5                	mov    %esp,%ebp
	return net_pkt_get_reserve_data(&rx_bufs, reserve_head, timeout);
    3b5e:	ff 75 0c             	pushl  0xc(%ebp)
    3b61:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
    3b65:	50                   	push   %eax
    3b66:	68 1c 51 40 00       	push   $0x40511c
    3b6b:	e8 76 ff ff ff       	call   3ae6 <net_pkt_get_reserve_data>
    3b70:	83 c4 0c             	add    $0xc,%esp
}
    3b73:	c9                   	leave  
    3b74:	c3                   	ret    

00003b75 <net_pkt_get_reserve_tx_data>:

struct net_buf *net_pkt_get_reserve_tx_data(u16_t reserve_head,
					    s32_t timeout)
{
    3b75:	55                   	push   %ebp
    3b76:	89 e5                	mov    %esp,%ebp
	return net_pkt_get_reserve_data(&tx_bufs, reserve_head, timeout);
    3b78:	ff 75 0c             	pushl  0xc(%ebp)
    3b7b:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
    3b7f:	50                   	push   %eax
    3b80:	68 3c 51 40 00       	push   $0x40513c
    3b85:	e8 5c ff ff ff       	call   3ae6 <net_pkt_get_reserve_data>
    3b8a:	83 c4 0c             	add    $0xc,%esp
}
    3b8d:	c9                   	leave  
    3b8e:	c3                   	ret    

00003b8f <net_pkt_get_frag>:
{
    3b8f:	55                   	push   %ebp
    3b90:	89 e5                	mov    %esp,%ebp
    3b92:	8b 45 08             	mov    0x8(%ebp),%eax
    3b95:	8b 55 0c             	mov    0xc(%ebp),%edx
	if (pkt->slab == &rx_pkts) {
    3b98:	81 78 04 9c 50 40 00 	cmpl   $0x40509c,0x4(%eax)
    3b9f:	0f b6 40 32          	movzbl 0x32(%eax),%eax
    3ba3:	75 09                	jne    3bae <net_pkt_get_frag+0x1f>
		return net_pkt_get_reserve_rx_data(net_pkt_ll_reserve(pkt),
    3ba5:	89 45 08             	mov    %eax,0x8(%ebp)
}
    3ba8:	5d                   	pop    %ebp
		return net_pkt_get_reserve_rx_data(net_pkt_ll_reserve(pkt),
    3ba9:	e9 ad ff ff ff       	jmp    3b5b <net_pkt_get_reserve_rx_data>
	return net_pkt_get_reserve_tx_data(net_pkt_ll_reserve(pkt),
    3bae:	89 55 0c             	mov    %edx,0xc(%ebp)
    3bb1:	89 45 08             	mov    %eax,0x8(%ebp)
}
    3bb4:	5d                   	pop    %ebp
	return net_pkt_get_reserve_tx_data(net_pkt_ll_reserve(pkt),
    3bb5:	e9 bb ff ff ff       	jmp    3b75 <net_pkt_get_reserve_tx_data>

00003bba <net_pkt_ref>:
struct net_pkt *net_pkt_ref_debug(struct net_pkt *pkt, const char *caller,
				  int line)
#else
struct net_pkt *net_pkt_ref(struct net_pkt *pkt)
#endif /* CONFIG_NET_DEBUG_NET_PKT */
{
    3bba:	55                   	push   %ebp
    3bbb:	89 e5                	mov    %esp,%ebp
    3bbd:	8b 45 08             	mov    0x8(%ebp),%eax
	if (!pkt) {
    3bc0:	85 c0                	test   %eax,%eax
    3bc2:	74 03                	je     3bc7 <net_pkt_ref+0xd>
	NET_DBG("%s [%d] pkt %p ref %d (%s():%d)",
		slab2str(pkt->slab), k_mem_slab_num_free_get(pkt->slab),
		pkt, pkt->ref + 1, caller, line);
#endif

	pkt->ref++;
    3bc4:	fe 40 36             	incb   0x36(%eax)

	return pkt;
}
    3bc7:	5d                   	pop    %ebp
    3bc8:	c3                   	ret    

00003bc9 <net_pkt_frag_unref>:
void net_pkt_frag_unref_debug(struct net_buf *frag,
			      const char *caller, int line)
#else
void net_pkt_frag_unref(struct net_buf *frag)
#endif /* CONFIG_NET_DEBUG_NET_PKT */
{
    3bc9:	55                   	push   %ebp
    3bca:	89 e5                	mov    %esp,%ebp
    3bcc:	8b 45 08             	mov    0x8(%ebp),%eax
	if (!frag) {
    3bcf:	85 c0                	test   %eax,%eax
    3bd1:	74 06                	je     3bd9 <net_pkt_frag_unref+0x10>
	if (frag->ref == 1) {
		net_pkt_alloc_del(frag, caller, line);
	}
#endif
	net_buf_unref(frag);
}
    3bd3:	5d                   	pop    %ebp
	net_buf_unref(frag);
    3bd4:	e9 d3 f7 ff ff       	jmp    33ac <net_buf_unref>
}
    3bd9:	5d                   	pop    %ebp
    3bda:	c3                   	ret    

00003bdb <net_pkt_unref>:
{
    3bdb:	55                   	push   %ebp
    3bdc:	89 e5                	mov    %esp,%ebp
	if (!pkt) {
    3bde:	8b 55 08             	mov    0x8(%ebp),%edx
    3be1:	85 d2                	test   %edx,%edx
    3be3:	74 2e                	je     3c13 <net_pkt_unref+0x38>
	if (!pkt->ref) {
    3be5:	8a 42 36             	mov    0x36(%edx),%al
    3be8:	84 c0                	test   %al,%al
    3bea:	74 27                	je     3c13 <net_pkt_unref+0x38>
	if (--pkt->ref > 0) {
    3bec:	48                   	dec    %eax
    3bed:	88 42 36             	mov    %al,0x36(%edx)
    3bf0:	84 c0                	test   %al,%al
    3bf2:	75 1f                	jne    3c13 <net_pkt_unref+0x38>
	if (pkt->frags) {
    3bf4:	8b 42 08             	mov    0x8(%edx),%eax
    3bf7:	85 c0                	test   %eax,%eax
    3bf9:	74 07                	je     3c02 <net_pkt_unref+0x27>
		net_pkt_frag_unref(pkt->frags);
    3bfb:	50                   	push   %eax
    3bfc:	e8 c8 ff ff ff       	call   3bc9 <net_pkt_frag_unref>
    3c01:	59                   	pop    %ecx
	k_mem_slab_free(pkt->slab, (void **)&pkt);
    3c02:	8d 45 08             	lea    0x8(%ebp),%eax
    3c05:	50                   	push   %eax
    3c06:	8b 45 08             	mov    0x8(%ebp),%eax
    3c09:	ff 70 04             	pushl  0x4(%eax)
    3c0c:	e8 17 27 00 00       	call   6328 <k_mem_slab_free>
    3c11:	58                   	pop    %eax
    3c12:	5a                   	pop    %edx
}
    3c13:	c9                   	leave  
    3c14:	c3                   	ret    

00003c15 <net_pkt_frag_del>:
#else
struct net_buf *net_pkt_frag_del(struct net_pkt *pkt,
				 struct net_buf *parent,
				 struct net_buf *frag)
#endif
{
    3c15:	55                   	push   %ebp
    3c16:	89 e5                	mov    %esp,%ebp
    3c18:	53                   	push   %ebx
    3c19:	8b 5d 08             	mov    0x8(%ebp),%ebx
    3c1c:	8b 45 10             	mov    0x10(%ebp),%eax
    3c1f:	8b 55 0c             	mov    0xc(%ebp),%edx
	if (frag->ref == 1) {
		net_pkt_alloc_del(frag, caller, line);
	}
#endif

	if (pkt->frags == frag && !parent) {
    3c22:	39 43 08             	cmp    %eax,0x8(%ebx)
    3c25:	75 04                	jne    3c2b <net_pkt_frag_del+0x16>
    3c27:	85 d2                	test   %edx,%edx
    3c29:	74 0f                	je     3c3a <net_pkt_frag_del+0x25>

		return tmp;
	}

	return net_buf_frag_del(parent, frag);
}
    3c2b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	return net_buf_frag_del(parent, frag);
    3c2e:	89 45 0c             	mov    %eax,0xc(%ebp)
    3c31:	89 55 08             	mov    %edx,0x8(%ebp)
}
    3c34:	c9                   	leave  
	return net_buf_frag_del(parent, frag);
    3c35:	e9 24 f8 ff ff       	jmp    345e <net_buf_frag_del>
		tmp = net_buf_frag_del(NULL, frag);
    3c3a:	50                   	push   %eax
    3c3b:	6a 00                	push   $0x0
    3c3d:	e8 1c f8 ff ff       	call   345e <net_buf_frag_del>
    3c42:	5a                   	pop    %edx
    3c43:	59                   	pop    %ecx
		pkt->frags = tmp;
    3c44:	89 43 08             	mov    %eax,0x8(%ebx)
}
    3c47:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    3c4a:	c9                   	leave  
    3c4b:	c3                   	ret    

00003c4c <net_pkt_frag_add>:
void net_pkt_frag_add_debug(struct net_pkt *pkt, struct net_buf *frag,
			    const char *caller, int line)
#else
void net_pkt_frag_add(struct net_pkt *pkt, struct net_buf *frag)
#endif
{
    3c4c:	55                   	push   %ebp
    3c4d:	89 e5                	mov    %esp,%ebp
    3c4f:	53                   	push   %ebx
    3c50:	8b 55 08             	mov    0x8(%ebp),%edx
    3c53:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	NET_DBG("pkt %p frag %p (%s:%d)", pkt, frag, caller, line);

	/* We do not use net_buf_frag_add() as this one will refcount
	 * the frag once more if !pkt->frags
	 */
	if (!pkt->frags) {
    3c56:	8b 42 08             	mov    0x8(%edx),%eax
    3c59:	85 c0                	test   %eax,%eax
    3c5b:	75 08                	jne    3c65 <net_pkt_frag_add+0x19>
		pkt->frags = frag;
    3c5d:	89 5a 08             	mov    %ebx,0x8(%edx)
		return;
	}

	net_buf_frag_insert(net_buf_frag_last(pkt->frags), frag);
}
    3c60:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    3c63:	c9                   	leave  
    3c64:	c3                   	ret    
	net_buf_frag_insert(net_buf_frag_last(pkt->frags), frag);
    3c65:	50                   	push   %eax
    3c66:	e8 8d f7 ff ff       	call   33f8 <net_buf_frag_last>
    3c6b:	89 5d 0c             	mov    %ebx,0xc(%ebp)
}
    3c6e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	net_buf_frag_insert(net_buf_frag_last(pkt->frags), frag);
    3c71:	5a                   	pop    %edx
    3c72:	89 45 08             	mov    %eax,0x8(%ebp)
}
    3c75:	c9                   	leave  
	net_buf_frag_insert(net_buf_frag_last(pkt->frags), frag);
    3c76:	e9 8f f7 ff ff       	jmp    340a <net_buf_frag_insert>

00003c7b <check_and_create_data.part.10>:
	*value = v32[0] << 24 | v32[1] << 16 | v32[2] << 8 | v32[3];

	return ret_frag;
}

static inline struct net_buf *check_and_create_data(struct net_pkt *pkt,
    3c7b:	55                   	push   %ebp
    3c7c:	89 e5                	mov    %esp,%ebp
    3c7e:	53                   	push   %ebx
    3c7f:	89 c3                	mov    %eax,%ebx
    3c81:	51                   	push   %ecx

	if (data) {
		return data;
	}

	frag = net_pkt_get_frag(pkt, timeout);
    3c82:	52                   	push   %edx
    3c83:	50                   	push   %eax
    3c84:	e8 06 ff ff ff       	call   3b8f <net_pkt_get_frag>
    3c89:	5a                   	pop    %edx
	if (!frag) {
    3c8a:	85 c0                	test   %eax,%eax
	frag = net_pkt_get_frag(pkt, timeout);
    3c8c:	59                   	pop    %ecx
	if (!frag) {
    3c8d:	74 0f                	je     3c9e <check_and_create_data.part.10+0x23>
		return NULL;
	}

	net_pkt_frag_add(pkt, frag);
    3c8f:	50                   	push   %eax
    3c90:	89 45 f8             	mov    %eax,-0x8(%ebp)
    3c93:	53                   	push   %ebx
    3c94:	e8 b3 ff ff ff       	call   3c4c <net_pkt_frag_add>
    3c99:	58                   	pop    %eax
    3c9a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3c9d:	5a                   	pop    %edx

	return frag;
}
    3c9e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    3ca1:	c9                   	leave  
    3ca2:	c3                   	ret    

00003ca3 <net_pkt_frag_insert>:
{
    3ca3:	55                   	push   %ebp
    3ca4:	89 e5                	mov    %esp,%ebp
    3ca6:	56                   	push   %esi
    3ca7:	53                   	push   %ebx
    3ca8:	8b 75 0c             	mov    0xc(%ebp),%esi
    3cab:	8b 5d 08             	mov    0x8(%ebp),%ebx
	net_buf_frag_last(frag)->frags = pkt->frags;
    3cae:	56                   	push   %esi
    3caf:	e8 44 f7 ff ff       	call   33f8 <net_buf_frag_last>
    3cb4:	5a                   	pop    %edx
    3cb5:	8b 53 08             	mov    0x8(%ebx),%edx
    3cb8:	89 10                	mov    %edx,(%eax)
	pkt->frags = frag;
    3cba:	89 73 08             	mov    %esi,0x8(%ebx)
}
    3cbd:	8d 65 f8             	lea    -0x8(%ebp),%esp
    3cc0:	5b                   	pop    %ebx
    3cc1:	5e                   	pop    %esi
    3cc2:	5d                   	pop    %ebp
    3cc3:	c3                   	ret    

00003cc4 <net_pkt_copy>:
{
    3cc4:	55                   	push   %ebp
    3cc5:	89 e5                	mov    %esp,%ebp
    3cc7:	57                   	push   %edi
    3cc8:	56                   	push   %esi
    3cc9:	53                   	push   %ebx
    3cca:	83 ec 10             	sub    $0x10,%esp
	orig = pkt->frags;
    3ccd:	8b 45 08             	mov    0x8(%ebp),%eax
    3cd0:	8b 70 08             	mov    0x8(%eax),%esi
	frag = net_pkt_get_frag(pkt, timeout);
    3cd3:	ff 75 14             	pushl  0x14(%ebp)
    3cd6:	50                   	push   %eax
    3cd7:	e8 b3 fe ff ff       	call   3b8f <net_pkt_get_frag>
    3cdc:	59                   	pop    %ecx
	if (!frag) {
    3cdd:	85 c0                	test   %eax,%eax
	frag = net_pkt_get_frag(pkt, timeout);
    3cdf:	5b                   	pop    %ebx
    3ce0:	89 c3                	mov    %eax,%ebx
	if (!frag) {
    3ce2:	0f 84 07 01 00 00    	je     3def <net_pkt_copy+0x12b>
	if (reserve > net_buf_tailroom(frag)) {
    3ce8:	8d 78 08             	lea    0x8(%eax),%edi
    3ceb:	57                   	push   %edi
    3cec:	e8 e8 f7 ff ff       	call   34d9 <net_buf_simple_tailroom>
    3cf1:	5a                   	pop    %edx
    3cf2:	3b 45 10             	cmp    0x10(%ebp),%eax
    3cf5:	72 26                	jb     3d1d <net_pkt_copy+0x59>
	net_buf_add(frag, reserve);
    3cf7:	ff 75 10             	pushl  0x10(%ebp)
    3cfa:	57                   	push   %edi
    3cfb:	e8 86 f7 ff ff       	call   3486 <net_buf_simple_add>
    3d00:	5f                   	pop    %edi
    3d01:	58                   	pop    %eax
	if (!orig->len) {
    3d02:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
    3d06:	66 85 c0             	test   %ax,%ax
    3d09:	0f 84 e0 00 00 00    	je     3def <net_pkt_copy+0x12b>
	orig_len = orig->len;
    3d0f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	orig_data = orig->data;
    3d12:	8b 46 08             	mov    0x8(%esi),%eax
    3d15:	89 45 f0             	mov    %eax,-0x10(%ebp)
	while (orig && amount) {
    3d18:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    3d1b:	eb 6d                	jmp    3d8a <net_pkt_copy+0xc6>
					net_pkt_frag_unref(first);
    3d1d:	53                   	push   %ebx
					return NULL;
    3d1e:	31 db                	xor    %ebx,%ebx
					net_pkt_frag_unref(first);
    3d20:	e8 a4 fe ff ff       	call   3bc9 <net_pkt_frag_unref>
    3d25:	59                   	pop    %ecx
					return NULL;
    3d26:	e9 c4 00 00 00       	jmp    3def <net_pkt_copy+0x12b>
	while (orig && amount) {
    3d2b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    3d2f:	0f 84 ba 00 00 00    	je     3def <net_pkt_copy+0x12b>
		int left_len = net_buf_tailroom(frag);
    3d35:	8b 45 e8             	mov    -0x18(%ebp),%eax
    3d38:	8d 48 08             	lea    0x8(%eax),%ecx
    3d3b:	51                   	push   %ecx
    3d3c:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    3d3f:	e8 95 f7 ff ff       	call   34d9 <net_buf_simple_tailroom>
			copy_len = amount;
    3d44:	8b 55 0c             	mov    0xc(%ebp),%edx
		int left_len = net_buf_tailroom(frag);
    3d47:	89 c7                	mov    %eax,%edi
		if (amount > orig_len) {
    3d49:	8b 45 ec             	mov    -0x14(%ebp),%eax
		int left_len = net_buf_tailroom(frag);
    3d4c:	59                   	pop    %ecx
		if (amount > orig_len) {
    3d4d:	39 c2                	cmp    %eax,%edx
    3d4f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    3d52:	76 02                	jbe    3d56 <net_pkt_copy+0x92>
			copy_len = orig_len;
    3d54:	89 c2                	mov    %eax,%edx
		if ((copy_len - left_len) >= 0) {
    3d56:	39 fa                	cmp    %edi,%edx
    3d58:	78 61                	js     3dbb <net_pkt_copy+0xf7>
			memcpy(net_buf_add(frag, left_len), orig_data,
    3d5a:	57                   	push   %edi
			amount -= left_len;
    3d5b:	29 7d 0c             	sub    %edi,0xc(%ebp)
			memcpy(net_buf_add(frag, left_len), orig_data,
    3d5e:	51                   	push   %ecx
    3d5f:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    3d62:	e8 1f f7 ff ff       	call   3486 <net_buf_simple_add>
    3d67:	5a                   	pop    %edx
    3d68:	59                   	pop    %ecx
    3d69:	57                   	push   %edi
    3d6a:	ff 75 f0             	pushl  -0x10(%ebp)
    3d6d:	50                   	push   %eax
    3d6e:	e8 65 e3 ff ff       	call   20d8 <memcpy>
    3d73:	83 c4 0c             	add    $0xc,%esp
			if (!net_buf_tailroom(frag)) {
    3d76:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    3d79:	51                   	push   %ecx
    3d7a:	e8 5a f7 ff ff       	call   34d9 <net_buf_simple_tailroom>
    3d7f:	5a                   	pop    %edx
    3d80:	85 c0                	test   %eax,%eax
    3d82:	74 0c                	je     3d90 <net_pkt_copy+0xcc>
			orig_len -= left_len;
    3d84:	29 7d ec             	sub    %edi,-0x14(%ebp)
			orig_data += left_len;
    3d87:	01 7d f0             	add    %edi,-0x10(%ebp)
	while (orig && amount) {
    3d8a:	85 f6                	test   %esi,%esi
    3d8c:	75 9d                	jne    3d2b <net_pkt_copy+0x67>
    3d8e:	eb 5f                	jmp    3def <net_pkt_copy+0x12b>
				struct net_buf *new_frag =
    3d90:	ff 75 14             	pushl  0x14(%ebp)
    3d93:	ff 75 08             	pushl  0x8(%ebp)
    3d96:	e8 f4 fd ff ff       	call   3b8f <net_pkt_get_frag>
    3d9b:	5a                   	pop    %edx
				if (!new_frag) {
    3d9c:	85 c0                	test   %eax,%eax
				struct net_buf *new_frag =
    3d9e:	59                   	pop    %ecx
				if (!new_frag) {
    3d9f:	0f 84 78 ff ff ff    	je     3d1d <net_pkt_copy+0x59>
				net_buf_frag_add(frag, new_frag);
    3da5:	50                   	push   %eax
    3da6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    3da9:	ff 75 e8             	pushl  -0x18(%ebp)
    3dac:	e8 7e f6 ff ff       	call   342f <net_buf_frag_add>
    3db1:	58                   	pop    %eax
    3db2:	5a                   	pop    %edx
    3db3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    3db6:	89 55 e8             	mov    %edx,-0x18(%ebp)
    3db9:	eb c9                	jmp    3d84 <net_pkt_copy+0xc0>
			memcpy(net_buf_add(frag, copy_len), orig_data,
    3dbb:	52                   	push   %edx
			amount -= copy_len;
    3dbc:	29 55 0c             	sub    %edx,0xc(%ebp)
			memcpy(net_buf_add(frag, copy_len), orig_data,
    3dbf:	51                   	push   %ecx
    3dc0:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    3dc3:	e8 be f6 ff ff       	call   3486 <net_buf_simple_add>
    3dc8:	5a                   	pop    %edx
    3dc9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    3dcc:	59                   	pop    %ecx
    3dcd:	52                   	push   %edx
    3dce:	ff 75 f0             	pushl  -0x10(%ebp)
    3dd1:	50                   	push   %eax
    3dd2:	e8 01 e3 ff ff       	call   20d8 <memcpy>
		orig = orig->frags;
    3dd7:	8b 36                	mov    (%esi),%esi
			memcpy(net_buf_add(frag, copy_len), orig_data,
    3dd9:	83 c4 0c             	add    $0xc,%esp
		if (orig) {
    3ddc:	85 f6                	test   %esi,%esi
    3dde:	74 aa                	je     3d8a <net_pkt_copy+0xc6>
			orig_len = orig->len;
    3de0:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
    3de4:	89 45 ec             	mov    %eax,-0x14(%ebp)
			orig_data = orig->data;
    3de7:	8b 46 08             	mov    0x8(%esi),%eax
    3dea:	89 45 f0             	mov    %eax,-0x10(%ebp)
    3ded:	eb 9b                	jmp    3d8a <net_pkt_copy+0xc6>
}
    3def:	8d 65 f4             	lea    -0xc(%ebp),%esp
    3df2:	89 d8                	mov    %ebx,%eax
    3df4:	5b                   	pop    %ebx
    3df5:	5e                   	pop    %esi
    3df6:	5f                   	pop    %edi
    3df7:	5d                   	pop    %ebp
    3df8:	c3                   	ret    

00003df9 <net_pkt_compact>:
{
    3df9:	55                   	push   %ebp
    3dfa:	89 e5                	mov    %esp,%ebp
    3dfc:	57                   	push   %edi
    3dfd:	56                   	push   %esi
    3dfe:	53                   	push   %ebx
    3dff:	51                   	push   %ecx
	prev = NULL;
    3e00:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	frag = pkt->frags;
    3e07:	8b 45 08             	mov    0x8(%ebp),%eax
    3e0a:	8b 78 08             	mov    0x8(%eax),%edi
	while (frag) {
    3e0d:	85 ff                	test   %edi,%edi
    3e0f:	0f 84 9f 00 00 00    	je     3eb4 <net_pkt_compact+0xbb>
		if (frag->frags) {
    3e15:	8b 07                	mov    (%edi),%eax
    3e17:	85 c0                	test   %eax,%eax
    3e19:	74 77                	je     3e92 <net_pkt_compact+0x99>
			if (copy_len > net_buf_tailroom(frag)) {
    3e1b:	8d 77 08             	lea    0x8(%edi),%esi
			copy_len = frag->frags->len;
    3e1e:	0f b7 58 0c          	movzwl 0xc(%eax),%ebx
			if (copy_len > net_buf_tailroom(frag)) {
    3e22:	56                   	push   %esi
    3e23:	e8 b1 f6 ff ff       	call   34d9 <net_buf_simple_tailroom>
    3e28:	5a                   	pop    %edx
    3e29:	39 c3                	cmp    %eax,%ebx
    3e2b:	76 09                	jbe    3e36 <net_pkt_compact+0x3d>
				copy_len = net_buf_tailroom(frag);
    3e2d:	56                   	push   %esi
    3e2e:	e8 a6 f6 ff ff       	call   34d9 <net_buf_simple_tailroom>
    3e33:	5b                   	pop    %ebx
    3e34:	89 c3                	mov    %eax,%ebx
			memcpy(net_buf_tail(frag), frag->frags->data, copy_len);
    3e36:	53                   	push   %ebx
    3e37:	8b 07                	mov    (%edi),%eax
    3e39:	ff 70 08             	pushl  0x8(%eax)
    3e3c:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
    3e40:	03 47 08             	add    0x8(%edi),%eax
    3e43:	50                   	push   %eax
    3e44:	e8 8f e2 ff ff       	call   20d8 <memcpy>
    3e49:	83 c4 0c             	add    $0xc,%esp
			net_buf_add(frag, copy_len);
    3e4c:	53                   	push   %ebx
    3e4d:	56                   	push   %esi
    3e4e:	e8 33 f6 ff ff       	call   3486 <net_buf_simple_add>
    3e53:	58                   	pop    %eax
				frag->frags->len - copy_len);
    3e54:	8b 07                	mov    (%edi),%eax
			net_buf_add(frag, copy_len);
    3e56:	5a                   	pop    %edx
				frag->frags->data + copy_len,
    3e57:	8b 48 08             	mov    0x8(%eax),%ecx
				frag->frags->len - copy_len);
    3e5a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
			memmove(frag->frags->data,
    3e5e:	29 d8                	sub    %ebx,%eax
    3e60:	50                   	push   %eax
				frag->frags->data + copy_len,
    3e61:	8d 04 19             	lea    (%ecx,%ebx,1),%eax
			memmove(frag->frags->data,
    3e64:	50                   	push   %eax
    3e65:	51                   	push   %ecx
    3e66:	e8 35 e2 ff ff       	call   20a0 <memmove>
			frag->frags->len -= copy_len;
    3e6b:	8b 07                	mov    (%edi),%eax
    3e6d:	66 29 58 0c          	sub    %bx,0xc(%eax)
			memmove(frag->frags->data,
    3e71:	83 c4 0c             	add    $0xc,%esp
			if (net_buf_tailroom(frag)) {
    3e74:	56                   	push   %esi
    3e75:	e8 5f f6 ff ff       	call   34d9 <net_buf_simple_tailroom>
    3e7a:	59                   	pop    %ecx
    3e7b:	85 c0                	test   %eax,%eax
    3e7d:	74 2b                	je     3eaa <net_pkt_compact+0xb1>
				net_pkt_frag_del(pkt, frag, frag->frags);
    3e7f:	ff 37                	pushl  (%edi)
    3e81:	57                   	push   %edi
    3e82:	ff 75 08             	pushl  0x8(%ebp)
    3e85:	e8 8b fd ff ff       	call   3c15 <net_pkt_frag_del>
    3e8a:	83 c4 0c             	add    $0xc,%esp
				continue;
    3e8d:	e9 7b ff ff ff       	jmp    3e0d <net_pkt_compact+0x14>
			if (!frag->len) {
    3e92:	66 83 7f 0c 00       	cmpw   $0x0,0xc(%edi)
    3e97:	75 11                	jne    3eaa <net_pkt_compact+0xb1>
				net_pkt_frag_del(pkt, prev, frag);
    3e99:	57                   	push   %edi
    3e9a:	ff 75 f0             	pushl  -0x10(%ebp)
    3e9d:	ff 75 08             	pushl  0x8(%ebp)
    3ea0:	e8 70 fd ff ff       	call   3c15 <net_pkt_frag_del>
    3ea5:	83 c4 0c             	add    $0xc,%esp
				break;
    3ea8:	eb 0a                	jmp    3eb4 <net_pkt_compact+0xbb>
		frag = frag->frags;
    3eaa:	89 7d f0             	mov    %edi,-0x10(%ebp)
    3ead:	8b 3f                	mov    (%edi),%edi
    3eaf:	e9 59 ff ff ff       	jmp    3e0d <net_pkt_compact+0x14>
}
    3eb4:	8d 65 f4             	lea    -0xc(%ebp),%esp
    3eb7:	b0 01                	mov    $0x1,%al
    3eb9:	5b                   	pop    %ebx
    3eba:	5e                   	pop    %esi
    3ebb:	5f                   	pop    %edi
    3ebc:	5d                   	pop    %ebp
    3ebd:	c3                   	ret    

00003ebe <net_frag_read>:
{
    3ebe:	55                   	push   %ebp
    3ebf:	89 e5                	mov    %esp,%ebp
    3ec1:	57                   	push   %edi
    3ec2:	56                   	push   %esi
    3ec3:	53                   	push   %ebx
    3ec4:	83 ec 08             	sub    $0x8,%esp
    3ec7:	8b 45 08             	mov    0x8(%ebp),%eax
    3eca:	8b 55 10             	mov    0x10(%ebp),%edx
    3ecd:	8b 7d 14             	mov    0x14(%ebp),%edi
    3ed0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	if (!frag) {
    3ed3:	85 c0                	test   %eax,%eax
    3ed5:	0f 84 80 00 00 00    	je     3f5b <net_frag_read+0x9d>
		if (offset == frag->len) {
    3edb:	8b 58 0c             	mov    0xc(%eax),%ebx
    3ede:	66 39 cb             	cmp    %cx,%bx
    3ee1:	75 0d                	jne    3ef0 <net_frag_read+0x32>
			*pos = 0;
    3ee3:	66 c7 02 00 00       	movw   $0x0,(%edx)
			return frag->frags;
    3ee8:	8b 00                	mov    (%eax),%eax
	if (!frag) {
    3eea:	85 c0                	test   %eax,%eax
    3eec:	75 0f                	jne    3efd <net_frag_read+0x3f>
    3eee:	eb 6b                	jmp    3f5b <net_frag_read+0x9d>
		} else if (offset < frag->len) {
    3ef0:	76 05                	jbe    3ef7 <net_frag_read+0x39>
			*pos = offset;
    3ef2:	66 89 0a             	mov    %cx,(%edx)
    3ef5:	eb 06                	jmp    3efd <net_frag_read+0x3f>
		offset -= frag->len;
    3ef7:	29 d9                	sub    %ebx,%ecx
		frag = frag->frags;
    3ef9:	8b 00                	mov    (%eax),%eax
    3efb:	eb d6                	jmp    3ed3 <net_frag_read+0x15>
    3efd:	4f                   	dec    %edi
						  pos, data + copy++);
    3efe:	31 f6                	xor    %esi,%esi
	while (len-- > 0 && frag) {
    3f00:	66 83 ff ff          	cmp    $0xffff,%di
    3f04:	74 5c                	je     3f62 <net_frag_read+0xa4>
    3f06:	85 c0                	test   %eax,%eax
    3f08:	74 58                	je     3f62 <net_frag_read+0xa4>
		if (data) {
    3f0a:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
    3f0e:	66 8b 0a             	mov    (%edx),%cx
    3f11:	74 27                	je     3f3a <net_frag_read+0x7c>
						  pos, data + copy++);
    3f13:	8d 5e 01             	lea    0x1(%esi),%ebx
	if (data) {
    3f16:	03 75 18             	add    0x18(%ebp),%esi
						  pos, data + copy++);
    3f19:	66 89 5d f2          	mov    %bx,-0xe(%ebp)
	if (data) {
    3f1d:	89 75 ec             	mov    %esi,-0x14(%ebp)
    3f20:	74 0e                	je     3f30 <net_frag_read+0x72>
		*data = frag->data[offset];
    3f22:	8b 70 08             	mov    0x8(%eax),%esi
    3f25:	0f b7 d9             	movzwl %cx,%ebx
    3f28:	8a 1c 1e             	mov    (%esi,%ebx,1),%bl
    3f2b:	8b 75 ec             	mov    -0x14(%ebp),%esi
    3f2e:	88 1e                	mov    %bl,(%esi)
	*pos = offset + 1;
    3f30:	41                   	inc    %ecx
    3f31:	66 89 0a             	mov    %cx,(%edx)
						  pos, data + copy++);
    3f34:	0f b7 75 f2          	movzwl -0xe(%ebp),%esi
    3f38:	eb 04                	jmp    3f3e <net_frag_read+0x80>
	*pos = offset + 1;
    3f3a:	41                   	inc    %ecx
    3f3b:	66 89 0a             	mov    %cx,(%edx)
	if (*pos >= frag->len) {
    3f3e:	66 3b 48 0c          	cmp    0xc(%eax),%cx
    3f42:	72 07                	jb     3f4b <net_frag_read+0x8d>
		*pos = 0;
    3f44:	66 c7 02 00 00       	movw   $0x0,(%edx)
		return frag->frags;
    3f49:	8b 00                	mov    (%eax),%eax
		if (!frag && len) {
    3f4b:	85 c0                	test   %eax,%eax
    3f4d:	0f 94 c3             	sete   %bl
    3f50:	66 85 ff             	test   %di,%di
    3f53:	0f 95 c1             	setne  %cl
    3f56:	4f                   	dec    %edi
    3f57:	84 cb                	test   %cl,%bl
    3f59:	74 a5                	je     3f00 <net_frag_read+0x42>
	*pos = 0xffff;
    3f5b:	66 c7 02 ff ff       	movw   $0xffff,(%edx)
	return NULL;
    3f60:	31 c0                	xor    %eax,%eax
}
    3f62:	5a                   	pop    %edx
    3f63:	59                   	pop    %ecx
    3f64:	5b                   	pop    %ebx
    3f65:	5e                   	pop    %esi
    3f66:	5f                   	pop    %edi
    3f67:	5d                   	pop    %ebp
    3f68:	c3                   	ret    

00003f69 <net_pkt_write>:

struct net_buf *net_pkt_write(struct net_pkt *pkt, struct net_buf *frag,
			      u16_t offset, u16_t *pos,
			      u16_t len, u8_t *data,
			      s32_t timeout)
{
    3f69:	55                   	push   %ebp
    3f6a:	89 e5                	mov    %esp,%ebp
    3f6c:	57                   	push   %edi
    3f6d:	56                   	push   %esi
    3f6e:	53                   	push   %ebx
    3f6f:	83 ec 10             	sub    $0x10,%esp
    3f72:	8b 45 18             	mov    0x18(%ebp),%eax
    3f75:	8b 5d 10             	mov    0x10(%ebp),%ebx
    3f78:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
	if (!pkt) {
    3f7c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    3f80:	0f 84 5f 01 00 00    	je     40e5 <_binary_mmu_tables_bin_size+0xe5>
    3f86:	8b 7d 0c             	mov    0xc(%ebp),%edi
	if (data) {
    3f89:	85 ff                	test   %edi,%edi
    3f8b:	75 15                	jne    3fa2 <net_pkt_write+0x39>
    3f8d:	8b 55 20             	mov    0x20(%ebp),%edx
    3f90:	8b 45 08             	mov    0x8(%ebp),%eax
    3f93:	e8 e3 fc ff ff       	call   3c7b <check_and_create_data.part.10>
    3f98:	89 c7                	mov    %eax,%edi
		if (!frag) {
    3f9a:	85 c0                	test   %eax,%eax
    3f9c:	0f 84 43 01 00 00    	je     40e5 <_binary_mmu_tables_bin_size+0xe5>
		if (offset < frag->len) {
    3fa2:	8b 47 0c             	mov    0xc(%edi),%eax
    3fa5:	66 39 d8             	cmp    %bx,%ax
    3fa8:	0f 87 ac 00 00 00    	ja     405a <_binary_mmu_tables_bin_size+0x5a>
		if (offset == frag->len) {
    3fae:	75 14                	jne    3fc4 <net_pkt_write+0x5b>
			if (net_buf_tailroom(frag)) {
    3fb0:	8d 47 08             	lea    0x8(%edi),%eax
    3fb3:	50                   	push   %eax
    3fb4:	e8 20 f5 ff ff       	call   34d9 <net_buf_simple_tailroom>
    3fb9:	59                   	pop    %ecx
    3fba:	85 c0                	test   %eax,%eax
    3fbc:	0f 85 98 00 00 00    	jne    405a <_binary_mmu_tables_bin_size+0x5a>
    3fc2:	eb 3a                	jmp    3ffe <net_pkt_write+0x95>
		if (offset > frag->len) {
    3fc4:	73 c3                	jae    3f89 <net_pkt_write+0x20>
			tailroom = net_buf_tailroom(frag);
    3fc6:	8d 57 08             	lea    0x8(%edi),%edx
			offset -= frag->len;
    3fc9:	29 c3                	sub    %eax,%ebx
			tailroom = net_buf_tailroom(frag);
    3fcb:	52                   	push   %edx
    3fcc:	89 55 f0             	mov    %edx,-0x10(%ebp)
    3fcf:	e8 05 f5 ff ff       	call   34d9 <net_buf_simple_tailroom>
    3fd4:	5a                   	pop    %edx
    3fd5:	89 c6                	mov    %eax,%esi
			if (offset < tailroom) {
    3fd7:	8b 55 f0             	mov    -0x10(%ebp),%edx
    3fda:	66 39 c3             	cmp    %ax,%bx
    3fdd:	73 11                	jae    3ff0 <net_pkt_write+0x87>
				net_buf_add(frag, offset);
    3fdf:	0f b7 db             	movzwl %bx,%ebx
    3fe2:	53                   	push   %ebx
    3fe3:	52                   	push   %edx
    3fe4:	e8 9d f4 ff ff       	call   3486 <net_buf_simple_add>
    3fe9:	5e                   	pop    %esi
				*pos = frag->len;
    3fea:	8b 5f 0c             	mov    0xc(%edi),%ebx
				net_buf_add(frag, offset);
    3fed:	58                   	pop    %eax
    3fee:	eb 6a                	jmp    405a <_binary_mmu_tables_bin_size+0x5a>
			if (offset == tailroom) {
    3ff0:	75 2a                	jne    401c <_binary_mmu_tables_bin_size+0x1c>
				net_buf_add(frag, tailroom);
    3ff2:	0f b7 f0             	movzwl %ax,%esi
    3ff5:	56                   	push   %esi
    3ff6:	52                   	push   %edx
    3ff7:	e8 8a f4 ff ff       	call   3486 <net_buf_simple_add>
    3ffc:	59                   	pop    %ecx
    3ffd:	5b                   	pop    %ebx
				return check_and_create_data(pkt,
    3ffe:	8b 3f                	mov    (%edi),%edi
				*pos = 0;
    4000:	31 db                	xor    %ebx,%ebx
	if (data) {
    4002:	85 ff                	test   %edi,%edi
    4004:	75 54                	jne    405a <_binary_mmu_tables_bin_size+0x5a>
    4006:	8b 55 20             	mov    0x20(%ebp),%edx
    4009:	8b 45 08             	mov    0x8(%ebp),%eax
    400c:	e8 6a fc ff ff       	call   3c7b <check_and_create_data.part.10>
    4011:	89 c7                	mov    %eax,%edi
		NET_ERR("Invalid packet");
		goto error;
	}

	frag = adjust_write_offset(pkt, frag, offset, &offset, timeout);
	if (!frag) {
    4013:	85 c0                	test   %eax,%eax
    4015:	75 41                	jne    4058 <_binary_mmu_tables_bin_size+0x58>
    4017:	e9 c9 00 00 00       	jmp    40e5 <_binary_mmu_tables_bin_size+0xe5>
			if (offset > tailroom) {
    401c:	0f 86 67 ff ff ff    	jbe    3f89 <net_pkt_write+0x20>
				net_buf_add(frag, tailroom);
    4022:	0f b7 c0             	movzwl %ax,%eax
    4025:	50                   	push   %eax
    4026:	52                   	push   %edx
    4027:	e8 5a f4 ff ff       	call   3486 <net_buf_simple_add>
				frag = check_and_create_data(pkt,
    402c:	8b 3f                	mov    (%edi),%edi
				net_buf_add(frag, tailroom);
    402e:	58                   	pop    %eax
				offset -= tailroom;
    402f:	29 f3                	sub    %esi,%ebx
				net_buf_add(frag, tailroom);
    4031:	5a                   	pop    %edx
	if (data) {
    4032:	85 ff                	test   %edi,%edi
    4034:	0f 85 4f ff ff ff    	jne    3f89 <net_pkt_write+0x20>
    403a:	8b 55 20             	mov    0x20(%ebp),%edx
    403d:	8b 45 08             	mov    0x8(%ebp),%eax
    4040:	e8 36 fc ff ff       	call   3c7b <check_and_create_data.part.10>
    4045:	89 c7                	mov    %eax,%edi
    4047:	e9 3d ff ff ff       	jmp    3f89 <net_pkt_write+0x20>
			*pos = offset + count;

			return frag;
		}

		data += count;
    404c:	8b 45 f0             	mov    -0x10(%ebp),%eax
		offset = 0;
		frag = frag->frags;
    404f:	8b 3f                	mov    (%edi),%edi
		data += count;
    4051:	01 45 1c             	add    %eax,0x1c(%ebp)

		if (!frag) {
    4054:	85 ff                	test   %edi,%edi
    4056:	74 6a                	je     40c2 <_binary_mmu_tables_bin_size+0xc2>
    4058:	31 db                	xor    %ebx,%ebx
		u16_t space = frag->size - net_buf_headroom(frag) - offset;
    405a:	8d 47 08             	lea    0x8(%edi),%eax
    405d:	66 8b 77 0e          	mov    0xe(%edi),%si
    4061:	89 45 e8             	mov    %eax,-0x18(%ebp)
    4064:	50                   	push   %eax
    4065:	e8 60 f4 ff ff       	call   34ca <net_buf_simple_headroom>
    406a:	59                   	pop    %ecx
    406b:	29 c6                	sub    %eax,%esi
		u16_t count = min(len, space);
    406d:	29 de                	sub    %ebx,%esi
    406f:	66 3b 75 ee          	cmp    -0x12(%ebp),%si
    4073:	76 04                	jbe    4079 <_binary_mmu_tables_bin_size+0x79>
    4075:	66 8b 75 ee          	mov    -0x12(%ebp),%si
		memcpy(frag->data + offset, data, count);
    4079:	0f b7 c6             	movzwl %si,%eax
    407c:	50                   	push   %eax
    407d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    4080:	ff 75 1c             	pushl  0x1c(%ebp)
    4083:	0f b7 cb             	movzwl %bx,%ecx
    4086:	89 c8                	mov    %ecx,%eax
    4088:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    408b:	03 47 08             	add    0x8(%edi),%eax
    408e:	50                   	push   %eax
    408f:	e8 44 e0 ff ff       	call   20d8 <memcpy>
		size_to_add = offset + count - frag->len;
    4094:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
		memcpy(frag->data + offset, data, count);
    4097:	83 c4 0c             	add    $0xc,%esp
		size_to_add = offset + count - frag->len;
    409a:	03 4d f0             	add    -0x10(%ebp),%ecx
    409d:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
    40a1:	29 c1                	sub    %eax,%ecx
		if (size_to_add > 0) {
    40a3:	85 c9                	test   %ecx,%ecx
    40a5:	7e 0b                	jle    40b2 <_binary_mmu_tables_bin_size+0xb2>
			net_buf_add(frag, size_to_add);
    40a7:	51                   	push   %ecx
    40a8:	ff 75 e8             	pushl  -0x18(%ebp)
    40ab:	e8 d6 f3 ff ff       	call   3486 <net_buf_simple_add>
    40b0:	58                   	pop    %eax
    40b1:	5a                   	pop    %edx
		if (len == 0) {
    40b2:	66 29 75 ee          	sub    %si,-0x12(%ebp)
    40b6:	75 94                	jne    404c <_binary_mmu_tables_bin_size+0x4c>
			*pos = offset + count;
    40b8:	8b 45 14             	mov    0x14(%ebp),%eax
    40bb:	01 f3                	add    %esi,%ebx
    40bd:	66 89 18             	mov    %bx,(%eax)
			return frag;
    40c0:	eb 2d                	jmp    40ef <_binary_mmu_tables_bin_size+0xef>
			frag = net_pkt_get_frag(pkt, timeout);
    40c2:	ff 75 20             	pushl  0x20(%ebp)
    40c5:	ff 75 08             	pushl  0x8(%ebp)
    40c8:	e8 c2 fa ff ff       	call   3b8f <net_pkt_get_frag>
    40cd:	59                   	pop    %ecx
    40ce:	89 c7                	mov    %eax,%edi
    40d0:	5b                   	pop    %ebx
			if (!frag) {
    40d1:	85 c0                	test   %eax,%eax
    40d3:	74 10                	je     40e5 <_binary_mmu_tables_bin_size+0xe5>
				goto error;
			}

			net_pkt_frag_add(pkt, frag);
    40d5:	50                   	push   %eax
    40d6:	ff 75 08             	pushl  0x8(%ebp)
    40d9:	e8 6e fb ff ff       	call   3c4c <net_pkt_frag_add>
    40de:	58                   	pop    %eax
    40df:	5a                   	pop    %edx
    40e0:	e9 73 ff ff ff       	jmp    4058 <_binary_mmu_tables_bin_size+0x58>
		}
	} while (1);

error:
	*pos = 0xffff;
    40e5:	8b 45 14             	mov    0x14(%ebp),%eax

	return NULL;
    40e8:	31 ff                	xor    %edi,%edi
	*pos = 0xffff;
    40ea:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
}
    40ef:	8d 65 f4             	lea    -0xc(%ebp),%esp
    40f2:	89 f8                	mov    %edi,%eax
    40f4:	5b                   	pop    %ebx
    40f5:	5e                   	pop    %esi
    40f6:	5f                   	pop    %edi
    40f7:	5d                   	pop    %ebp
    40f8:	c3                   	ret    

000040f9 <net_frag_get_pos>:
#endif /* CONFIG_NET_DEBUG_NET_PKT */

struct net_buf *net_frag_get_pos(struct net_pkt *pkt,
				 u16_t offset,
				 u16_t *pos)
{
    40f9:	55                   	push   %ebp
    40fa:	89 e5                	mov    %esp,%ebp
 */
static inline struct net_buf *net_frag_skip(struct net_buf *frag,
					    u16_t offset,
					    u16_t *pos, u16_t len)
{
	return net_frag_read(frag, offset, pos, len, NULL);
    40fc:	6a 00                	push   $0x0
    40fe:	6a 00                	push   $0x0
    4100:	ff 75 10             	pushl  0x10(%ebp)
	struct net_buf *frag;

	frag = net_frag_skip(pkt->frags, offset, pos, 0);
    4103:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
    4107:	50                   	push   %eax
    4108:	8b 45 08             	mov    0x8(%ebp),%eax
    410b:	ff 70 08             	pushl  0x8(%eax)
    410e:	e8 ab fd ff ff       	call   3ebe <net_frag_read>
    4113:	83 c4 14             	add    $0x14,%esp
	if (!frag) {
		return NULL;
	}

	return frag;
}
    4116:	c9                   	leave  
    4117:	c3                   	ret    

00004118 <net_pkt_icmp_data>:
#else
#define too_short_msg(...)
#endif

struct net_icmp_hdr *net_pkt_icmp_data(struct net_pkt *pkt)
{
    4118:	55                   	push   %ebp
    4119:	89 e5                	mov    %esp,%ebp
    411b:	50                   	push   %eax
    411c:	8b 45 08             	mov    0x8(%ebp),%eax
	struct net_buf *frag;
	u16_t offset;

	frag = net_frag_get_pos(pkt,
    411f:	8d 55 fe             	lea    -0x2(%ebp),%edx
    4122:	52                   	push   %edx
    4123:	0f b6 50 33          	movzbl 0x33(%eax),%edx
    4127:	52                   	push   %edx
    4128:	50                   	push   %eax
    4129:	e8 cb ff ff ff       	call   40f9 <net_frag_get_pos>
    412e:	83 c4 0c             	add    $0xc,%esp
    4131:	31 d2                	xor    %edx,%edx
				net_pkt_ip_hdr_len(pkt) +
				net_pkt_ipv6_ext_len(pkt),
				&offset);
	if (!frag) {
    4133:	85 c0                	test   %eax,%eax
    4135:	74 07                	je     413e <net_pkt_icmp_data+0x26>
		/* We tried to read past the end of the data */
		too_short_msg("icmp data", pkt, offset, 0);
		return NULL;
	}

	return (struct net_icmp_hdr *)(frag->data + offset);
    4137:	0f b7 55 fe          	movzwl -0x2(%ebp),%edx
    413b:	03 50 08             	add    0x8(%eax),%edx
}
    413e:	89 d0                	mov    %edx,%eax
    4140:	c9                   	leave  
    4141:	c3                   	ret    

00004142 <net_pkt_udp_data>:

	return frag->data + offset;
}

struct net_udp_hdr *net_pkt_udp_data(struct net_pkt *pkt)
{
    4142:	55                   	push   %ebp
    4143:	89 e5                	mov    %esp,%ebp
    4145:	50                   	push   %eax
    4146:	8b 45 08             	mov    0x8(%ebp),%eax
	struct net_buf *frag;
	u16_t offset;

	frag = net_frag_get_pos(pkt,
    4149:	8d 55 fe             	lea    -0x2(%ebp),%edx
    414c:	52                   	push   %edx
    414d:	0f b6 50 33          	movzbl 0x33(%eax),%edx
    4151:	52                   	push   %edx
    4152:	50                   	push   %eax
    4153:	e8 a1 ff ff ff       	call   40f9 <net_frag_get_pos>
    4158:	83 c4 0c             	add    $0xc,%esp
    415b:	31 d2                	xor    %edx,%edx
				net_pkt_ip_hdr_len(pkt) +
				net_pkt_ipv6_ext_len(pkt),
				&offset);
	if (!frag) {
    415d:	85 c0                	test   %eax,%eax
    415f:	74 07                	je     4168 <net_pkt_udp_data+0x26>
		/* We tried to read past the end of the data */
		too_short_msg("udp data", pkt, offset, 0);
		return NULL;
	}

	return (struct net_udp_hdr *)(frag->data + offset);
    4161:	0f b7 55 fe          	movzwl -0x2(%ebp),%edx
    4165:	03 50 08             	add    0x8(%eax),%edx
}
    4168:	89 d0                	mov    %edx,%eax
    416a:	c9                   	leave  
    416b:	c3                   	ret    

0000416c <net_pkt_init>:

	return clone;
}

void net_pkt_init(void)
{
    416c:	55                   	push   %ebp
    416d:	89 e5                	mov    %esp,%ebp
		k_mem_slab_num_free_get(&tx_pkts),
		(size_t)(k_mem_slab_num_free_get(&tx_pkts) *
			 sizeof(struct net_pkt)),
		get_frees(&rx_bufs), rx_bufs.pool_size,
		get_frees(&tx_bufs), tx_bufs.pool_size);
}
    416f:	5d                   	pop    %ebp
    4170:	c3                   	ret    

00004171 <calc_chksum>:
static u16_t calc_chksum(u16_t sum, const u8_t *ptr, u16_t len)
{
	u16_t tmp;
	const u8_t *end;

	end = ptr + len - 1;
    4171:	0f b7 c9             	movzwl %cx,%ecx
{
    4174:	55                   	push   %ebp
    4175:	89 e5                	mov    %esp,%ebp
    4177:	56                   	push   %esi
    4178:	53                   	push   %ebx
	end = ptr + len - 1;
    4179:	8d 5c 0a ff          	lea    -0x1(%edx,%ecx,1),%ebx

	while (ptr < end) {
    417d:	39 da                	cmp    %ebx,%edx
    417f:	73 25                	jae    41a6 <calc_chksum+0x35>
		tmp = (ptr[0] << 8) + ptr[1];
    4181:	0f b6 0a             	movzbl (%edx),%ecx
    4184:	0f b6 72 01          	movzbl 0x1(%edx),%esi
    4188:	c1 e1 08             	shl    $0x8,%ecx
    418b:	01 f1                	add    %esi,%ecx
    418d:	31 f6                	xor    %esi,%esi
    418f:	66 01 c8             	add    %cx,%ax
    4192:	73 05                	jae    4199 <calc_chksum+0x28>
    4194:	be 01 00 00 00       	mov    $0x1,%esi
		sum += tmp;
		if (sum < tmp) {
			sum++;
    4199:	66 83 fe 01          	cmp    $0x1,%si
    419d:	66 83 d8 ff          	sbb    $0xffff,%ax
		}
		ptr += 2;
    41a1:	83 c2 02             	add    $0x2,%edx
    41a4:	eb d7                	jmp    417d <calc_chksum+0xc>
	}

	if (ptr == end) {
    41a6:	75 1a                	jne    41c2 <calc_chksum+0x51>
		tmp = ptr[0] << 8;
    41a8:	0f b6 12             	movzbl (%edx),%edx
    41ab:	c1 e2 08             	shl    $0x8,%edx
    41ae:	31 c9                	xor    %ecx,%ecx
    41b0:	66 01 d0             	add    %dx,%ax
    41b3:	73 05                	jae    41ba <calc_chksum+0x49>
    41b5:	b9 01 00 00 00       	mov    $0x1,%ecx
		sum += tmp;
		if (sum < tmp) {
			sum++;
    41ba:	66 83 f9 01          	cmp    $0x1,%cx
    41be:	66 83 d8 ff          	sbb    $0xffff,%ax
		}
	}

	return sum;
}
    41c2:	5b                   	pop    %ebx
    41c3:	5e                   	pop    %esi
    41c4:	5d                   	pop    %ebp
    41c5:	c3                   	ret    

000041c6 <net_addr_pton>:
{
    41c6:	55                   	push   %ebp
    41c7:	89 e5                	mov    %esp,%ebp
    41c9:	57                   	push   %edi
    41ca:	56                   	push   %esi
    41cb:	53                   	push   %ebx
    41cc:	83 ec 10             	sub    $0x10,%esp
    41cf:	8b 45 08             	mov    0x8(%ebp),%eax
    41d2:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	if (family == AF_INET) {
    41d5:	66 83 f8 02          	cmp    $0x2,%ax
    41d9:	75 66                	jne    4241 <net_addr_pton+0x7b>
		len = strlen(src);
    41db:	53                   	push   %ebx
    41dc:	e8 5c de ff ff       	call   203d <strlen>
    41e1:	59                   	pop    %ecx
    41e2:	89 c7                	mov    %eax,%edi
		for (i = 0; i < len; i++) {
    41e4:	31 d2                	xor    %edx,%edx
    41e6:	39 fa                	cmp    %edi,%edx
    41e8:	74 1e                	je     4208 <net_addr_pton+0x42>
			if (!(src[i] >= '0' && src[i] <= '9') &&
    41ea:	8a 0c 13             	mov    (%ebx,%edx,1),%cl
    41ed:	8d 71 d0             	lea    -0x30(%ecx),%esi
    41f0:	89 f0                	mov    %esi,%eax
    41f2:	3c 09                	cmp    $0x9,%al
    41f4:	76 0f                	jbe    4205 <net_addr_pton+0x3f>
    41f6:	80 f9 2e             	cmp    $0x2e,%cl
    41f9:	74 0a                	je     4205 <net_addr_pton+0x3f>
				return -EINVAL;
    41fb:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    4200:	e9 c0 01 00 00       	jmp    43c5 <net_addr_pton+0x1ff>
		for (i = 0; i < len; i++) {
    4205:	42                   	inc    %edx
    4206:	eb de                	jmp    41e6 <net_addr_pton+0x20>
		memset(addr, 0, sizeof(struct in_addr));
    4208:	6a 04                	push   $0x4
    420a:	6a 00                	push   $0x0
    420c:	ff 75 10             	pushl  0x10(%ebp)
		for (i = 0; i < sizeof(struct in_addr); i++) {
    420f:	31 f6                	xor    %esi,%esi
		memset(addr, 0, sizeof(struct in_addr));
    4211:	e8 2d df ff ff       	call   2143 <memset>
			addr->s4_addr[i] = strtol(src, &endptr, 10);
    4216:	8d 7d f0             	lea    -0x10(%ebp),%edi
		memset(addr, 0, sizeof(struct in_addr));
    4219:	83 c4 0c             	add    $0xc,%esp
			addr->s4_addr[i] = strtol(src, &endptr, 10);
    421c:	6a 0a                	push   $0xa
    421e:	57                   	push   %edi
    421f:	53                   	push   %ebx
    4220:	e8 81 df ff ff       	call   21a6 <strtol>
    4225:	8b 55 10             	mov    0x10(%ebp),%edx
    4228:	83 c4 0c             	add    $0xc,%esp
    422b:	88 04 32             	mov    %al,(%edx,%esi,1)
			src = ++endptr;
    422e:	8b 45 f0             	mov    -0x10(%ebp),%eax
		for (i = 0; i < sizeof(struct in_addr); i++) {
    4231:	46                   	inc    %esi
			src = ++endptr;
    4232:	8d 58 01             	lea    0x1(%eax),%ebx
		for (i = 0; i < sizeof(struct in_addr); i++) {
    4235:	83 fe 04             	cmp    $0x4,%esi
    4238:	75 e2                	jne    421c <net_addr_pton+0x56>
	return 0;
    423a:	31 c0                	xor    %eax,%eax
    423c:	e9 84 01 00 00       	jmp    43c5 <net_addr_pton+0x1ff>
	} else if (family == AF_INET6) {
    4241:	66 83 f8 0a          	cmp    $0xa,%ax
    4245:	75 b4                	jne    41fb <net_addr_pton+0x35>
		int expected_groups = strchr(src, '.') ? 6 : 8;
    4247:	6a 2e                	push   $0x2e
    4249:	53                   	push   %ebx
    424a:	e8 b4 dd ff ff       	call   2003 <strchr>
    424f:	5e                   	pop    %esi
    4250:	83 f8 01             	cmp    $0x1,%eax
    4253:	5f                   	pop    %edi
    4254:	19 c0                	sbb    %eax,%eax
    4256:	89 45 ec             	mov    %eax,-0x14(%ebp)
			src++;
    4259:	31 c0                	xor    %eax,%eax
		int expected_groups = strchr(src, '.') ? 6 : 8;
    425b:	83 65 ec 02          	andl   $0x2,-0x14(%ebp)
    425f:	83 45 ec 06          	addl   $0x6,-0x14(%ebp)
			src++;
    4263:	80 3b 3a             	cmpb   $0x3a,(%ebx)
    4266:	0f 94 c0             	sete   %al
    4269:	01 c3                	add    %eax,%ebx
		len = strlen(src);
    426b:	53                   	push   %ebx
    426c:	e8 cc dd ff ff       	call   203d <strlen>
    4271:	5a                   	pop    %edx
    4272:	89 c6                	mov    %eax,%esi
		for (i = 0; i < len; i++) {
    4274:	31 c9                	xor    %ecx,%ecx
    4276:	39 ce                	cmp    %ecx,%esi
    4278:	7e 26                	jle    42a0 <net_addr_pton+0xda>
			if (!(src[i] >= '0' && src[i] <= '9') &&
    427a:	8a 14 0b             	mov    (%ebx,%ecx,1),%dl
    427d:	89 d7                	mov    %edx,%edi
    427f:	83 e7 df             	and    $0xffffffdf,%edi
    4282:	83 ef 41             	sub    $0x41,%edi
    4285:	89 f8                	mov    %edi,%eax
    4287:	3c 05                	cmp    $0x5,%al
    4289:	76 12                	jbe    429d <net_addr_pton+0xd7>
    428b:	8d 7a d0             	lea    -0x30(%edx),%edi
    428e:	89 f8                	mov    %edi,%eax
    4290:	3c 0a                	cmp    $0xa,%al
    4292:	76 09                	jbe    429d <net_addr_pton+0xd7>
			    src[i] != '.' && src[i] != ':')
    4294:	80 fa 2e             	cmp    $0x2e,%dl
    4297:	0f 85 5e ff ff ff    	jne    41fb <net_addr_pton+0x35>
		for (i = 0; i < len; i++) {
    429d:	41                   	inc    %ecx
    429e:	eb d6                	jmp    4276 <net_addr_pton+0xb0>
				if (!src && i < expected_groups - 1) {
    42a0:	8b 45 ec             	mov    -0x14(%ebp),%eax
		for (i = 0; i < len; i++) {
    42a3:	31 f6                	xor    %esi,%esi
				if (!src && i < expected_groups - 1) {
    42a5:	48                   	dec    %eax
    42a6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			if (!src || *src == '\0') {
    42a9:	85 db                	test   %ebx,%ebx
    42ab:	0f 84 4a ff ff ff    	je     41fb <net_addr_pton+0x35>
    42b1:	8a 03                	mov    (%ebx),%al
    42b3:	84 c0                	test   %al,%al
    42b5:	0f 84 40 ff ff ff    	je     41fb <net_addr_pton+0x35>
			if (*src != ':') {
    42bb:	3c 3a                	cmp    $0x3a,%al
    42bd:	74 50                	je     430f <net_addr_pton+0x149>
				UNALIGNED_PUT(htons(strtol(src, NULL, 16)),
    42bf:	8d 04 36             	lea    (%esi,%esi,1),%eax
    42c2:	6a 10                	push   $0x10
    42c4:	03 45 10             	add    0x10(%ebp),%eax
    42c7:	6a 00                	push   $0x0
    42c9:	89 45 e8             	mov    %eax,-0x18(%ebp)
    42cc:	53                   	push   %ebx
    42cd:	e8 d4 de ff ff       	call   21a6 <strtol>
    42d2:	83 c4 0c             	add    $0xc,%esp
    42d5:	89 c7                	mov    %eax,%edi
    42d7:	6a 10                	push   $0x10
    42d9:	66 c1 ef 08          	shr    $0x8,%di
    42dd:	6a 00                	push   $0x0
    42df:	53                   	push   %ebx
    42e0:	e8 c1 de ff ff       	call   21a6 <strtol>
    42e5:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    42e8:	83 c4 0c             	add    $0xc,%esp
    42eb:	c1 e0 08             	shl    $0x8,%eax
    42ee:	09 f8                	or     %edi,%eax
    42f0:	66 89 01             	mov    %ax,(%ecx)
				src = strchr(src, ':');
    42f3:	6a 3a                	push   $0x3a
    42f5:	53                   	push   %ebx
    42f6:	e8 08 dd ff ff       	call   2003 <strchr>
    42fb:	5a                   	pop    %edx
				if (!src && i < expected_groups - 1) {
    42fc:	85 c0                	test   %eax,%eax
				src = strchr(src, ':');
    42fe:	59                   	pop    %ecx
				if (!src && i < expected_groups - 1) {
    42ff:	75 09                	jne    430a <net_addr_pton+0x144>
    4301:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
    4304:	0f 8f f1 fe ff ff    	jg     41fb <net_addr_pton+0x35>
				src++;
    430a:	8d 58 01             	lea    0x1(%eax),%ebx
    430d:	eb 56                	jmp    4365 <net_addr_pton+0x19f>
			for (; i < expected_groups; i++) {
    430f:	39 75 ec             	cmp    %esi,-0x14(%ebp)
    4312:	7e 0c                	jle    4320 <net_addr_pton+0x15a>
				UNALIGNED_PUT(0, &addr->s6_addr16[i]);
    4314:	8b 45 10             	mov    0x10(%ebp),%eax
    4317:	66 c7 04 70 00 00    	movw   $0x0,(%eax,%esi,2)
			for (; i < expected_groups; i++) {
    431d:	46                   	inc    %esi
    431e:	eb ef                	jmp    430f <net_addr_pton+0x149>
			tmp = strrchr(src, ':');
    4320:	6a 3a                	push   $0x3a
    4322:	53                   	push   %ebx
    4323:	e8 fd dc ff ff       	call   2025 <strrchr>
    4328:	5e                   	pop    %esi
			if (src == tmp && (expected_groups == 6 || !src[1])) {
    4329:	39 d8                	cmp    %ebx,%eax
			tmp = strrchr(src, ':');
    432b:	5f                   	pop    %edi
			if (src == tmp && (expected_groups == 6 || !src[1])) {
    432c:	75 11                	jne    433f <net_addr_pton+0x179>
    432e:	83 7d ec 06          	cmpl   $0x6,-0x14(%ebp)
    4332:	74 06                	je     433a <net_addr_pton+0x174>
    4334:	80 7b 01 00          	cmpb   $0x0,0x1(%ebx)
    4338:	75 10                	jne    434a <net_addr_pton+0x184>
				src++;
    433a:	8d 58 01             	lea    0x1(%eax),%ebx
    433d:	eb 30                	jmp    436f <net_addr_pton+0x1a9>
				tmp--;
    433f:	31 c9                	xor    %ecx,%ecx
    4341:	83 7d ec 06          	cmpl   $0x6,-0x14(%ebp)
    4345:	0f 94 c1             	sete   %cl
    4348:	29 c8                	sub    %ecx,%eax
			i = expected_groups - 1;
    434a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    434d:	8d 71 ff             	lea    -0x1(%ecx),%esi
    4350:	8d 4b ff             	lea    -0x1(%ebx),%ecx
					i--;
    4353:	31 d2                	xor    %edx,%edx
    4355:	80 38 3a             	cmpb   $0x3a,(%eax)
    4358:	0f 94 c2             	sete   %dl
    435b:	89 d7                	mov    %edx,%edi
			} while (tmp-- != src);
    435d:	48                   	dec    %eax
					i--;
    435e:	29 fe                	sub    %edi,%esi
			} while (tmp-- != src);
    4360:	39 c8                	cmp    %ecx,%eax
    4362:	75 ef                	jne    4353 <net_addr_pton+0x18d>
			src++;
    4364:	43                   	inc    %ebx
		for (i = 0; i < expected_groups; i++) {
    4365:	46                   	inc    %esi
    4366:	39 75 ec             	cmp    %esi,-0x14(%ebp)
    4369:	0f 8f 3a ff ff ff    	jg     42a9 <net_addr_pton+0xe3>
		if (expected_groups == 6) {
    436f:	83 7d ec 06          	cmpl   $0x6,-0x14(%ebp)
    4373:	0f 85 c1 fe ff ff    	jne    423a <net_addr_pton+0x74>
    4379:	31 f6                	xor    %esi,%esi
				if (!src || !*src) {
    437b:	85 db                	test   %ebx,%ebx
    437d:	0f 84 78 fe ff ff    	je     41fb <net_addr_pton+0x35>
    4383:	80 3b 00             	cmpb   $0x0,(%ebx)
    4386:	0f 84 6f fe ff ff    	je     41fb <net_addr_pton+0x35>
				addr->s6_addr[12 + i] = strtol(src, NULL, 10);
    438c:	6a 0a                	push   $0xa
    438e:	6a 00                	push   $0x0
    4390:	53                   	push   %ebx
    4391:	e8 10 de ff ff       	call   21a6 <strtol>
    4396:	8b 55 10             	mov    0x10(%ebp),%edx
    4399:	83 c4 0c             	add    $0xc,%esp
    439c:	88 44 32 0c          	mov    %al,0xc(%edx,%esi,1)
				src = strchr(src, '.');
    43a0:	6a 2e                	push   $0x2e
    43a2:	53                   	push   %ebx
    43a3:	e8 5b dc ff ff       	call   2003 <strchr>
    43a8:	5a                   	pop    %edx
				if (!src && i < 3) {
    43a9:	85 c0                	test   %eax,%eax
				src = strchr(src, '.');
    43ab:	59                   	pop    %ecx
				if (!src && i < 3) {
    43ac:	75 09                	jne    43b7 <net_addr_pton+0x1f1>
    43ae:	83 fe 02             	cmp    $0x2,%esi
    43b1:	0f 8e 44 fe ff ff    	jle    41fb <net_addr_pton+0x35>
			for (i = 0; i < 4; i++) {
    43b7:	46                   	inc    %esi
				src++;
    43b8:	8d 58 01             	lea    0x1(%eax),%ebx
			for (i = 0; i < 4; i++) {
    43bb:	83 fe 04             	cmp    $0x4,%esi
    43be:	75 bb                	jne    437b <net_addr_pton+0x1b5>
    43c0:	e9 75 fe ff ff       	jmp    423a <net_addr_pton+0x74>
}
    43c5:	8d 65 f4             	lea    -0xc(%ebp),%esp
    43c8:	5b                   	pop    %ebx
    43c9:	5e                   	pop    %esi
    43ca:	5f                   	pop    %edi
    43cb:	5d                   	pop    %ebp
    43cc:	c3                   	ret    

000043cd <net_calc_chksum>:

	return sum;
}

u16_t net_calc_chksum(struct net_pkt *pkt, u8_t proto)
{
    43cd:	55                   	push   %ebp
    43ce:	89 e5                	mov    %esp,%ebp
    43d0:	57                   	push   %edi
    43d1:	56                   	push   %esi
    43d2:	53                   	push   %ebx
    43d3:	83 ec 08             	sub    $0x8,%esp
    43d6:	8b 4d 08             	mov    0x8(%ebp),%ecx
    43d9:	8b 45 0c             	mov    0xc(%ebp),%eax
	return pkt->family;
    43dc:	8a 51 34             	mov    0x34(%ecx),%dl
    43df:	c0 ea 03             	shr    $0x3,%dl
    43e2:	83 e2 0f             	and    $0xf,%edx
	u16_t upper_layer_len;
	u16_t sum = 0;

	switch (net_pkt_family(pkt)) {
    43e5:	80 fa 02             	cmp    $0x2,%dl
    43e8:	0f 85 b3 00 00 00    	jne    44a1 <net_calc_chksum+0xd4>
	u16_t sum = 0;
    43ee:	31 ff                	xor    %edi,%edi
    43f0:	8b 71 08             	mov    0x8(%ecx),%esi
    43f3:	0f b6 59 33          	movzbl 0x33(%ecx),%ebx
		upper_layer_len = (NET_IPV4_HDR(pkt)->len[0] << 8) +
			NET_IPV4_HDR(pkt)->len[1] -
			net_pkt_ipv6_ext_len(pkt) -
			net_pkt_ip_hdr_len(pkt);

		if (proto != IPPROTO_ICMP) {
    43f7:	3c 01                	cmp    $0x1,%al
    43f9:	74 36                	je     4431 <net_calc_chksum+0x64>
	return pkt->frags->data;
    43fb:	8b 4e 08             	mov    0x8(%esi),%ecx
			sum = calc_chksum(upper_layer_len + proto,
    43fe:	0f b6 c0             	movzbl %al,%eax
					  (u8_t *)&NET_IPV4_HDR(pkt)->src,
    4401:	8d 79 0c             	lea    0xc(%ecx),%edi
			sum = calc_chksum(upper_layer_len + proto,
    4404:	89 c2                	mov    %eax,%edx
			net_pkt_ip_hdr_len(pkt);
    4406:	0f b6 c3             	movzbl %bl,%eax
					  (u8_t *)&NET_IPV4_HDR(pkt)->src,
    4409:	89 7d ec             	mov    %edi,-0x14(%ebp)
			sum = calc_chksum(upper_layer_len + proto,
    440c:	29 c2                	sub    %eax,%edx
			NET_IPV4_HDR(pkt)->len[1] -
    440e:	0f b6 79 03          	movzbl 0x3(%ecx),%edi
			sum = calc_chksum(upper_layer_len + proto,
    4412:	89 d0                	mov    %edx,%eax
    4414:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4417:	01 c7                	add    %eax,%edi
		upper_layer_len = (NET_IPV4_HDR(pkt)->len[0] << 8) +
    4419:	0f b6 41 02          	movzbl 0x2(%ecx),%eax
    441d:	c1 e0 08             	shl    $0x8,%eax
			sum = calc_chksum(upper_layer_len + proto,
    4420:	b9 08 00 00 00       	mov    $0x8,%ecx
    4425:	01 f8                	add    %edi,%eax
    4427:	0f b7 c0             	movzwl %ax,%eax
    442a:	e8 42 fd ff ff       	call   4171 <calc_chksum>
    442f:	89 c7                	mov    %eax,%edi
	return net_frag_read(frag, offset, pos, len, NULL);
    4431:	8d 45 f2             	lea    -0xe(%ebp),%eax
    4434:	6a 00                	push   $0x0
    4436:	6a 00                	push   $0x0
    4438:	50                   	push   %eax
    4439:	53                   	push   %ebx
    443a:	56                   	push   %esi
    443b:	e8 7e fa ff ff       	call   3ebe <net_frag_read>
    4440:	83 c4 14             	add    $0x14,%esp
    4443:	89 c6                	mov    %eax,%esi
		return 0;
	}

	sum = calc_chksum_pkt(sum, pkt, upper_layer_len);

	sum = (sum == 0) ? 0xffff : htons(sum);
    4445:	83 c8 ff             	or     $0xffffffff,%eax
	if (!frag) {
    4448:	85 f6                	test   %esi,%esi
    444a:	74 57                	je     44a3 <net_calc_chksum+0xd6>
	ptr = frag->data + offset;
    444c:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
	len = frag->len - offset;
    4450:	8b 5e 0c             	mov    0xc(%esi),%ebx
	ptr = frag->data + offset;
    4453:	89 d0                	mov    %edx,%eax
    4455:	03 56 08             	add    0x8(%esi),%edx
	len = frag->len - offset;
    4458:	29 c3                	sub    %eax,%ebx
		sum = calc_chksum(sum, ptr, len);
    445a:	0f b7 c7             	movzwl %di,%eax
    445d:	0f b7 cb             	movzwl %bx,%ecx
    4460:	e8 0c fd ff ff       	call   4171 <calc_chksum>
		frag = frag->frags;
    4465:	8b 36                	mov    (%esi),%esi
		sum = calc_chksum(sum, ptr, len);
    4467:	89 c7                	mov    %eax,%edi
		if (!frag) {
    4469:	85 f6                	test   %esi,%esi
    446b:	74 26                	je     4493 <net_calc_chksum+0xc6>
		if (len % 2) {
    446d:	80 e3 01             	and    $0x1,%bl
		ptr = frag->data;
    4470:	8b 56 08             	mov    0x8(%esi),%edx
    4473:	8b 5e 0c             	mov    0xc(%esi),%ebx
		if (len % 2) {
    4476:	74 e2                	je     445a <net_calc_chksum+0x8d>
			u16_t tmp = *ptr;
    4478:	0f b6 02             	movzbl (%edx),%eax
    447b:	31 c9                	xor    %ecx,%ecx
    447d:	66 01 c7             	add    %ax,%di
    4480:	73 05                	jae    4487 <net_calc_chksum+0xba>
    4482:	b9 01 00 00 00       	mov    $0x1,%ecx
				sum++;
    4487:	66 83 f9 01          	cmp    $0x1,%cx
    448b:	66 83 df ff          	sbb    $0xffff,%di
			len = frag->len - 1;
    448f:	4b                   	dec    %ebx
			ptr++;
    4490:	42                   	inc    %edx
    4491:	eb c7                	jmp    445a <net_calc_chksum+0x8d>
	sum = (sum == 0) ? 0xffff : htons(sum);
    4493:	83 c8 ff             	or     $0xffffffff,%eax
    4496:	66 85 ff             	test   %di,%di
    4499:	74 08                	je     44a3 <net_calc_chksum+0xd6>
    449b:	89 f8                	mov    %edi,%eax
    449d:	86 e0                	xchg   %ah,%al
    449f:	eb 02                	jmp    44a3 <net_calc_chksum+0xd6>
		return 0;
    44a1:	31 c0                	xor    %eax,%eax

	return sum;
}
    44a3:	8d 65 f4             	lea    -0xc(%ebp),%esp
    44a6:	5b                   	pop    %ebx
    44a7:	5e                   	pop    %esi
    44a8:	5f                   	pop    %edi
    44a9:	5d                   	pop    %ebp
    44aa:	c3                   	ret    

000044ab <net_calc_chksum_ipv4>:

#if defined(CONFIG_NET_IPV4)
u16_t net_calc_chksum_ipv4(struct net_pkt *pkt)
{
    44ab:	55                   	push   %ebp
	u16_t sum;

	sum = calc_chksum(0, (u8_t *)NET_IPV4_HDR(pkt), NET_IPV4H_LEN);
    44ac:	b9 14 00 00 00       	mov    $0x14,%ecx
{
    44b1:	89 e5                	mov    %esp,%ebp
	return pkt->frags->data;
    44b3:	8b 45 08             	mov    0x8(%ebp),%eax
    44b6:	8b 40 08             	mov    0x8(%eax),%eax
	sum = calc_chksum(0, (u8_t *)NET_IPV4_HDR(pkt), NET_IPV4H_LEN);
    44b9:	8b 50 08             	mov    0x8(%eax),%edx
    44bc:	31 c0                	xor    %eax,%eax
    44be:	e8 ae fc ff ff       	call   4171 <calc_chksum>
    44c3:	83 ca ff             	or     $0xffffffff,%edx

	sum = (sum == 0) ? 0xffff : htons(sum);
    44c6:	66 85 c0             	test   %ax,%ax
    44c9:	74 04                	je     44cf <net_calc_chksum_ipv4+0x24>
    44cb:	86 e0                	xchg   %ah,%al
    44cd:	89 c2                	mov    %eax,%edx

	return sum;
}
    44cf:	89 d0                	mov    %edx,%eax
    44d1:	5d                   	pop    %ebp
    44d2:	c3                   	ret    

000044d3 <net_header_fits>:
 * memory area. The start of the said area must be inside the first
 * fragment. This helper is used when checking whether various protocol
 * headers are split between two fragments.
 */
bool net_header_fits(struct net_pkt *pkt, u8_t *hdr, size_t hdr_size)
{
    44d3:	55                   	push   %ebp
	if (hdr && hdr > pkt->frags->data &&
	    (hdr + hdr_size) <= (pkt->frags->data + pkt->frags->len)) {
		return true;
	}

	return false;
    44d4:	31 c0                	xor    %eax,%eax
{
    44d6:	89 e5                	mov    %esp,%ebp
    44d8:	53                   	push   %ebx
    44d9:	8b 55 0c             	mov    0xc(%ebp),%edx
	if (hdr && hdr > pkt->frags->data &&
    44dc:	85 d2                	test   %edx,%edx
    44de:	74 1d                	je     44fd <net_header_fits+0x2a>
    44e0:	8b 45 08             	mov    0x8(%ebp),%eax
    44e3:	8b 58 08             	mov    0x8(%eax),%ebx
	return false;
    44e6:	31 c0                	xor    %eax,%eax
	if (hdr && hdr > pkt->frags->data &&
    44e8:	8b 4b 08             	mov    0x8(%ebx),%ecx
    44eb:	39 ca                	cmp    %ecx,%edx
    44ed:	76 0e                	jbe    44fd <net_header_fits+0x2a>
	    (hdr + hdr_size) <= (pkt->frags->data + pkt->frags->len)) {
    44ef:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
    44f3:	03 55 10             	add    0x10(%ebp),%edx
    44f6:	01 c1                	add    %eax,%ecx
	if (hdr && hdr > pkt->frags->data &&
    44f8:	39 ca                	cmp    %ecx,%edx
    44fa:	0f 96 c0             	setbe  %al
}
    44fd:	5b                   	pop    %ebx
    44fe:	5d                   	pop    %ebp
    44ff:	c3                   	ret    

00004500 <net_eth_is_addr_broadcast>:
	struct net_eth_addr src;
	u16_t type;
} __packed;

static inline bool net_eth_is_addr_broadcast(struct net_eth_addr *addr)
{
    4500:	55                   	push   %ebp
    4501:	89 e5                	mov    %esp,%ebp
	if (addr->addr[0] == 0xff &&
    4503:	80 38 ff             	cmpb   $0xff,(%eax)
    4506:	75 25                	jne    452d <net_eth_is_addr_broadcast+0x2d>
    4508:	89 c2                	mov    %eax,%edx
	    addr->addr[4] == 0xff &&
	    addr->addr[5] == 0xff) {
		return true;
	}

	return false;
    450a:	31 c0                	xor    %eax,%eax
	if (addr->addr[0] == 0xff &&
    450c:	80 7a 01 ff          	cmpb   $0xff,0x1(%edx)
    4510:	75 1d                	jne    452f <net_eth_is_addr_broadcast+0x2f>
	    addr->addr[1] == 0xff &&
    4512:	80 7a 02 ff          	cmpb   $0xff,0x2(%edx)
    4516:	75 17                	jne    452f <net_eth_is_addr_broadcast+0x2f>
	    addr->addr[2] == 0xff &&
    4518:	80 7a 03 ff          	cmpb   $0xff,0x3(%edx)
    451c:	75 11                	jne    452f <net_eth_is_addr_broadcast+0x2f>
	    addr->addr[3] == 0xff &&
    451e:	80 7a 04 ff          	cmpb   $0xff,0x4(%edx)
    4522:	75 0b                	jne    452f <net_eth_is_addr_broadcast+0x2f>
	    addr->addr[4] == 0xff &&
    4524:	80 7a 05 ff          	cmpb   $0xff,0x5(%edx)
    4528:	0f 94 c0             	sete   %al
    452b:	eb 02                	jmp    452f <net_eth_is_addr_broadcast+0x2f>
	return false;
    452d:	31 c0                	xor    %eax,%eax
}
    452f:	5d                   	pop    %ebp
    4530:	c3                   	ret    

00004531 <ethernet_reserve>:

	return NET_OK;
}

static inline u16_t ethernet_reserve(struct net_if *iface, void *unused)
{
    4531:	55                   	push   %ebp
	ARG_UNUSED(iface);
	ARG_UNUSED(unused);

	return sizeof(struct net_eth_hdr);
}
    4532:	b8 0e 00 00 00       	mov    $0xe,%eax
{
    4537:	89 e5                	mov    %esp,%ebp
}
    4539:	5d                   	pop    %ebp
    453a:	c3                   	ret    

0000453b <ethernet_enable>:

static inline int ethernet_enable(struct net_if *iface, bool state)
{
    453b:	55                   	push   %ebp
    453c:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(iface);

	if (!state) {
    453e:	80 7d 0c 00          	cmpb   $0x0,0xc(%ebp)
    4542:	75 05                	jne    4549 <ethernet_enable+0xe>
		net_arp_clear_cache();
    4544:	e8 5a 08 00 00       	call   4da3 <net_arp_clear_cache>
	}

	return 0;
}
    4549:	31 c0                	xor    %eax,%eax
    454b:	5d                   	pop    %ebp
    454c:	c3                   	ret    

0000454d <ethernet_recv>:
{
    454d:	55                   	push   %ebp
    454e:	89 e5                	mov    %esp,%ebp
    4550:	57                   	push   %edi
    4551:	56                   	push   %esi
    4552:	53                   	push   %ebx
    4553:	51                   	push   %ecx
    4554:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    4557:	8b 45 08             	mov    0x8(%ebp),%eax
    455a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    455d:	8b 53 08             	mov    0x8(%ebx),%edx
	return net_pkt_ip_data(pkt) - net_pkt_ll_reserve(pkt);
    4560:	0f b6 43 32          	movzbl 0x32(%ebx),%eax
    4564:	8b 72 08             	mov    0x8(%edx),%esi
    4567:	29 c6                	sub    %eax,%esi
	switch (ntohs(hdr->type)) {
    4569:	66 8b 46 0c          	mov    0xc(%esi),%ax
    456d:	86 e0                	xchg   %ah,%al
    456f:	66 3d 06 08          	cmp    $0x806,%ax
    4573:	74 10                	je     4585 <ethernet_recv+0x38>
    4575:	66 3d dd 86          	cmp    $0x86dd,%ax
    4579:	74 1d                	je     4598 <ethernet_recv+0x4b>
    457b:	66 3d 00 08          	cmp    $0x800,%ax
    457f:	0f 85 f5 00 00 00    	jne    467a <ethernet_recv+0x12d>
	pkt->family = family;
    4585:	8a 43 34             	mov    0x34(%ebx),%al
		family = AF_INET;
    4588:	bf 02 00 00 00       	mov    $0x2,%edi
    458d:	83 e0 87             	and    $0xffffff87,%eax
    4590:	83 c8 10             	or     $0x10,%eax
    4593:	88 43 34             	mov    %al,0x34(%ebx)
		break;
    4596:	eb 11                	jmp    45a9 <ethernet_recv+0x5c>
    4598:	8a 43 34             	mov    0x34(%ebx),%al
		family = AF_INET6;
    459b:	bf 0a 00 00 00       	mov    $0xa,%edi
    45a0:	83 e0 87             	and    $0xffffff87,%eax
    45a3:	83 c8 50             	or     $0x50,%eax
    45a6:	88 43 34             	mov    %al,0x34(%ebx)
	lladdr->addr = ((struct net_eth_hdr *)net_pkt_ll(pkt))->src.addr;
    45a9:	8d 46 06             	lea    0x6(%esi),%eax
	lladdr->len = sizeof(struct net_eth_addr);
    45ac:	c6 43 24 06          	movb   $0x6,0x24(%ebx)
	lladdr->addr = ((struct net_eth_hdr *)net_pkt_ll(pkt))->src.addr;
    45b0:	89 43 20             	mov    %eax,0x20(%ebx)
	lladdr->type = NET_LINK_ETHERNET;
    45b3:	c6 43 25 03          	movb   $0x3,0x25(%ebx)
	lladdr->addr = ((struct net_eth_hdr *)net_pkt_ll(pkt))->dst.addr;
    45b7:	89 73 28             	mov    %esi,0x28(%ebx)
	lladdr->len = sizeof(struct net_eth_addr);
    45ba:	c6 43 2c 06          	movb   $0x6,0x2c(%ebx)
	lladdr->type = NET_LINK_ETHERNET;
    45be:	c6 43 2d 03          	movb   $0x3,0x2d(%ebx)
	if (!net_eth_is_addr_broadcast((struct net_eth_addr *)lladdr->addr) &&
    45c2:	89 f0                	mov    %esi,%eax
    45c4:	e8 37 ff ff ff       	call   4500 <net_eth_is_addr_broadcast>
    45c9:	84 c0                	test   %al,%al
    45cb:	74 1c                	je     45e9 <ethernet_recv+0x9c>
	pkt->ll_reserve = len;
    45cd:	c6 43 32 0e          	movb   $0xe,0x32(%ebx)
	net_buf_pull(pkt->frags, net_pkt_ll_reserve(pkt));
    45d1:	6a 0e                	push   $0xe
    45d3:	8b 43 08             	mov    0x8(%ebx),%eax
    45d6:	83 c0 08             	add    $0x8,%eax
    45d9:	50                   	push   %eax
    45da:	e8 d8 ee ff ff       	call   34b7 <net_buf_simple_pull>
	if (family == AF_INET && hdr->type == htons(NET_ETH_PTYPE_ARP)) {
    45df:	66 83 ff 02          	cmp    $0x2,%di
	net_buf_pull(pkt->frags, net_pkt_ll_reserve(pkt));
    45e3:	58                   	pop    %eax
    45e4:	5a                   	pop    %edx
	if (family == AF_INET && hdr->type == htons(NET_ETH_PTYPE_ARP)) {
    45e5:	75 26                	jne    460d <ethernet_recv+0xc0>
    45e7:	eb 0d                	jmp    45f6 <ethernet_recv+0xa9>

static inline bool net_eth_is_addr_multicast(struct net_eth_addr *addr)
{
	if (addr->addr[0] == 0x33 &&
    45e9:	80 3e 33             	cmpb   $0x33,(%esi)
    45ec:	75 7d                	jne    466b <ethernet_recv+0x11e>
    45ee:	80 7e 01 33          	cmpb   $0x33,0x1(%esi)
    45f2:	75 77                	jne    466b <ethernet_recv+0x11e>
    45f4:	eb d7                	jmp    45cd <ethernet_recv+0x80>
    45f6:	66 81 7e 0c 08 06    	cmpw   $0x608,0xc(%esi)
    45fc:	75 0f                	jne    460d <ethernet_recv+0xc0>
		return net_arp_input(pkt);
    45fe:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
    4601:	8d 65 f4             	lea    -0xc(%ebp),%esp
    4604:	5b                   	pop    %ebx
    4605:	5e                   	pop    %esi
    4606:	5f                   	pop    %edi
    4607:	5d                   	pop    %ebp
		return net_arp_input(pkt);
    4608:	e9 4c 05 00 00       	jmp    4b59 <net_arp_input>
	return pkt->family;
    460d:	8a 43 34             	mov    0x34(%ebx),%al
    4610:	c0 e8 03             	shr    $0x3,%al
    4613:	83 e0 0f             	and    $0xf,%eax
	if (net_pkt_family(pkt) == AF_INET) {
    4616:	3c 02                	cmp    $0x2,%al
    4618:	8b 43 08             	mov    0x8(%ebx),%eax
    461b:	75 12                	jne    462f <ethernet_recv+0xe2>
	return pkt->frags->data;
    461d:	8b 50 08             	mov    0x8(%eax),%edx
		len = ((NET_IPV4_HDR(pkt)->len[0] << 8) +
    4620:	0f b6 42 02          	movzbl 0x2(%edx),%eax
		       NET_IPV4_HDR(pkt)->len[1]);
    4624:	0f b6 52 03          	movzbl 0x3(%edx),%edx
		len = ((NET_IPV4_HDR(pkt)->len[0] << 8) +
    4628:	c1 e0 08             	shl    $0x8,%eax
    462b:	01 d0                	add    %edx,%eax
    462d:	eb 12                	jmp    4641 <ethernet_recv+0xf4>
    462f:	8b 40 08             	mov    0x8(%eax),%eax
		       NET_IPV6_HDR(pkt)->len[1]) +
    4632:	0f b6 50 05          	movzbl 0x5(%eax),%edx
		len = ((NET_IPV6_HDR(pkt)->len[0] << 8) +
    4636:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    463a:	c1 e0 08             	shl    $0x8,%eax
    463d:	8d 44 02 28          	lea    0x28(%edx,%eax,1),%eax
	if (len < NET_ETH_MINIMAL_FRAME_SIZE - sizeof(struct net_eth_hdr)) {
    4641:	66 83 f8 2d          	cmp    $0x2d,%ax
    4645:	76 07                	jbe    464e <ethernet_recv+0x101>
	return NET_CONTINUE;
    4647:	b8 01 00 00 00       	mov    $0x1,%eax
    464c:	eb 4e                	jmp    469c <ethernet_recv+0x14f>
		for (frag = pkt->frags; frag; frag = frag->frags) {
    464e:	8b 53 08             	mov    0x8(%ebx),%edx
    4651:	85 d2                	test   %edx,%edx
    4653:	74 f2                	je     4647 <ethernet_recv+0xfa>
			if (frag->len < len) {
    4655:	8b 4a 0c             	mov    0xc(%edx),%ecx
    4658:	66 39 c1             	cmp    %ax,%cx
    465b:	73 04                	jae    4661 <ethernet_recv+0x114>
				len -= frag->len;
    465d:	29 c8                	sub    %ecx,%eax
    465f:	eb 06                	jmp    4667 <ethernet_recv+0x11a>
				frag->len = len;
    4661:	66 89 42 0c          	mov    %ax,0xc(%edx)
				len = 0;
    4665:	31 c0                	xor    %eax,%eax
		for (frag = pkt->frags; frag; frag = frag->frags) {
    4667:	8b 12                	mov    (%edx),%edx
    4669:	eb e6                	jmp    4651 <ethernet_recv+0x104>
 * @return True if the addresses are the same, false otherwise.
 */
static inline bool net_linkaddr_cmp(struct net_linkaddr *lladdr1,
				    struct net_linkaddr *lladdr2)
{
	if (!lladdr1 || !lladdr2) {
    466b:	83 7d f0 f0          	cmpl   $0xfffffff0,-0x10(%ebp)
    466f:	74 09                	je     467a <ethernet_recv+0x12d>
		return false;
	}

	if (lladdr1->len != lladdr2->len) {
    4671:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4674:	80 78 14 06          	cmpb   $0x6,0x14(%eax)
    4678:	74 07                	je     4681 <ethernet_recv+0x134>
		return NET_DROP;
    467a:	b8 02 00 00 00       	mov    $0x2,%eax
    467f:	eb 1b                	jmp    469c <ethernet_recv+0x14f>
		return false;
	}

	return !memcmp(lladdr1->addr, lladdr2->addr, lladdr1->len);
    4681:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4684:	6a 06                	push   $0x6
    4686:	56                   	push   %esi
    4687:	ff 70 10             	pushl  0x10(%eax)
    468a:	e8 e4 d9 ff ff       	call   2073 <memcmp>
    468f:	83 c4 0c             	add    $0xc,%esp
	    !net_eth_is_addr_multicast((struct net_eth_addr *)lladdr->addr) &&
    4692:	85 c0                	test   %eax,%eax
    4694:	0f 84 33 ff ff ff    	je     45cd <ethernet_recv+0x80>
    469a:	eb de                	jmp    467a <ethernet_recv+0x12d>
}
    469c:	8d 65 f4             	lea    -0xc(%ebp),%esp
    469f:	5b                   	pop    %ebx
    46a0:	5e                   	pop    %esi
    46a1:	5f                   	pop    %edi
    46a2:	5d                   	pop    %ebp
    46a3:	c3                   	ret    

000046a4 <ethernet_send>:
{
    46a4:	55                   	push   %ebp
    46a5:	89 e5                	mov    %esp,%ebp
    46a7:	57                   	push   %edi
    46a8:	56                   	push   %esi
    46a9:	53                   	push   %ebx
    46aa:	56                   	push   %esi
    46ab:	8b 7d 0c             	mov    0xc(%ebp),%edi
	return pkt->family;
    46ae:	8a 47 34             	mov    0x34(%edi),%al
    46b1:	c0 e8 03             	shr    $0x3,%al
    46b4:	83 e0 0f             	and    $0xf,%eax
	if (net_pkt_family(pkt) == AF_INET) {
    46b7:	3c 02                	cmp    $0x2,%al
    46b9:	75 61                	jne    471c <ethernet_send+0x78>
	return pkt->frags->data;
    46bb:	8b 47 08             	mov    0x8(%edi),%eax
    46be:	0f b6 5f 32          	movzbl 0x32(%edi),%ebx
    46c2:	8b 70 08             	mov    0x8(%eax),%esi
	if (net_ipv4_addr_cmp(&NET_IPV4_HDR(pkt)->dst,
    46c5:	e8 07 0c 00 00       	call   52d1 <net_ipv4_broadcast_address>
    46ca:	8b 4f 08             	mov    0x8(%edi),%ecx
    46cd:	8b 00                	mov    (%eax),%eax
    46cf:	8b 49 08             	mov    0x8(%ecx),%ecx
    46d2:	39 41 10             	cmp    %eax,0x10(%ecx)
    46d5:	75 09                	jne    46e0 <ethernet_send+0x3c>
		net_pkt_ll_dst(pkt)->addr = (u8_t *)broadcast_eth_addr.addr;
    46d7:	c7 47 28 74 77 00 00 	movl   $0x7774,0x28(%edi)
    46de:	eb 29                	jmp    4709 <ethernet_send+0x65>
	} else if (NET_IPV4_HDR(pkt)->dst.s4_addr[0] == 224) {
    46e0:	80 79 10 e0          	cmpb   $0xe0,0x10(%ecx)
    46e4:	0f 85 bf 00 00 00    	jne    47a9 <ethernet_send+0x105>
	return net_pkt_ip_data(pkt) - net_pkt_ll_reserve(pkt);
    46ea:	29 de                	sub    %ebx,%esi
		hdr->dst.addr[0] = 0x01;
    46ec:	c6 06 01             	movb   $0x1,(%esi)
		hdr->dst.addr[1] = 0x00;
    46ef:	c6 46 01 00          	movb   $0x0,0x1(%esi)
		hdr->dst.addr[2] = 0x5e;
    46f3:	c6 46 02 5e          	movb   $0x5e,0x2(%esi)
		hdr->dst.addr[3] = NET_IPV4_HDR(pkt)->dst.s4_addr[1];
    46f7:	8a 41 11             	mov    0x11(%ecx),%al
    46fa:	88 46 03             	mov    %al,0x3(%esi)
		hdr->dst.addr[4] = NET_IPV4_HDR(pkt)->dst.s4_addr[2];
    46fd:	8a 41 12             	mov    0x12(%ecx),%al
    4700:	88 46 04             	mov    %al,0x4(%esi)
		hdr->dst.addr[5] = NET_IPV4_HDR(pkt)->dst.s4_addr[3];
    4703:	8a 41 13             	mov    0x13(%ecx),%al
    4706:	88 46 05             	mov    %al,0x5(%esi)
		net_pkt_ll_src(pkt)->addr = net_if_get_link_addr(iface)->addr;
    4709:	8b 45 08             	mov    0x8(%ebp),%eax
		net_pkt_ll_dst(pkt)->len = sizeof(struct net_eth_addr);
    470c:	c6 47 2c 06          	movb   $0x6,0x2c(%edi)
		net_pkt_ll_src(pkt)->addr = net_if_get_link_addr(iface)->addr;
    4710:	8b 40 10             	mov    0x10(%eax),%eax
		net_pkt_ll_src(pkt)->len = sizeof(struct net_eth_addr);
    4713:	c6 47 24 06          	movb   $0x6,0x24(%edi)
		net_pkt_ll_src(pkt)->addr = net_if_get_link_addr(iface)->addr;
    4717:	89 47 20             	mov    %eax,0x20(%edi)
    471a:	eb 39                	jmp    4755 <ethernet_send+0xb1>
					net_pkt_ll_src(pkt)->addr) ||
    471c:	8b 5f 20             	mov    0x20(%edi),%ebx
	if (net_eth_is_addr_broadcast((struct net_eth_addr *)
    471f:	89 d8                	mov    %ebx,%eax
    4721:	e8 da fd ff ff       	call   4500 <net_eth_is_addr_broadcast>
    4726:	84 c0                	test   %al,%al
    4728:	75 0b                	jne    4735 <ethernet_send+0x91>
    472a:	80 3b 33             	cmpb   $0x33,(%ebx)
    472d:	75 15                	jne    4744 <ethernet_send+0xa0>
    472f:	80 7b 01 33          	cmpb   $0x33,0x1(%ebx)
    4733:	75 0f                	jne    4744 <ethernet_send+0xa0>
    4735:	8b 47 14             	mov    0x14(%edi),%eax
		net_pkt_ll_src(pkt)->addr = net_pkt_ll_if(pkt)->addr;
    4738:	8b 48 10             	mov    0x10(%eax),%ecx
    473b:	89 4f 20             	mov    %ecx,0x20(%edi)
		net_pkt_ll_src(pkt)->len = net_pkt_ll_if(pkt)->len;
    473e:	8a 40 14             	mov    0x14(%eax),%al
    4741:	88 47 24             	mov    %al,0x24(%edi)
	if (!net_pkt_ll_dst(pkt)->addr) {
    4744:	83 7f 28 00          	cmpl   $0x0,0x28(%edi)
    4748:	75 0b                	jne    4755 <ethernet_send+0xb1>
			net_pkt_ll_dst(pkt)->addr =
    474a:	c7 47 28 74 77 00 00 	movl   $0x7774,0x28(%edi)
		net_pkt_ll_dst(pkt)->len = sizeof(struct net_eth_addr);
    4751:	c6 47 2c 06          	movb   $0x6,0x2c(%edi)
	return pkt->family;
    4755:	8a 47 34             	mov    0x34(%edi),%al
		ptype = htons(NET_ETH_PTYPE_IP);
    4758:	be 08 00 00 00       	mov    $0x8,%esi
    475d:	c0 e8 03             	shr    $0x3,%al
    4760:	83 e0 0f             	and    $0xf,%eax
	if (net_pkt_family(pkt) == AF_INET) {
    4763:	3c 02                	cmp    $0x2,%al
    4765:	74 05                	je     476c <ethernet_send+0xc8>
		ptype = htons(NET_ETH_PTYPE_IPV6);
    4767:	be 86 dd ff ff       	mov    $0xffffdd86,%esi
	frag = pkt->frags;
    476c:	8b 4f 08             	mov    0x8(%edi),%ecx
	while (frag) {
    476f:	85 c9                	test   %ecx,%ecx
    4771:	74 65                	je     47d8 <ethernet_send+0x134>
		hdr = (struct net_eth_hdr *)(frag->data -
    4773:	8b 59 08             	mov    0x8(%ecx),%ebx
    4776:	89 4d f0             	mov    %ecx,-0x10(%ebp)
					     net_pkt_ll_reserve(pkt));
    4779:	0f b6 47 32          	movzbl 0x32(%edi),%eax
		memcpy(&hdr->dst, net_pkt_ll_dst(pkt)->addr,
    477d:	6a 06                	push   $0x6
		hdr = (struct net_eth_hdr *)(frag->data -
    477f:	29 c3                	sub    %eax,%ebx
		memcpy(&hdr->dst, net_pkt_ll_dst(pkt)->addr,
    4781:	ff 77 28             	pushl  0x28(%edi)
    4784:	53                   	push   %ebx
    4785:	e8 4e d9 ff ff       	call   20d8 <memcpy>
    478a:	83 c4 0c             	add    $0xc,%esp
		memcpy(&hdr->src, net_pkt_ll_src(pkt)->addr,
    478d:	8d 43 06             	lea    0x6(%ebx),%eax
    4790:	6a 06                	push   $0x6
    4792:	ff 77 20             	pushl  0x20(%edi)
    4795:	50                   	push   %eax
    4796:	e8 3d d9 ff ff       	call   20d8 <memcpy>
		frag = frag->frags;
    479b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
		hdr->type = ptype;
    479e:	66 89 73 0c          	mov    %si,0xc(%ebx)
		memcpy(&hdr->src, net_pkt_ll_src(pkt)->addr,
    47a2:	83 c4 0c             	add    $0xc,%esp
		frag = frag->frags;
    47a5:	8b 09                	mov    (%ecx),%ecx
    47a7:	eb c6                	jmp    476f <ethernet_send+0xcb>
		arp_pkt = net_arp_prepare(pkt);
    47a9:	57                   	push   %edi
    47aa:	e8 d4 01 00 00       	call   4983 <net_arp_prepare>
    47af:	89 c7                	mov    %eax,%edi
    47b1:	5a                   	pop    %edx
			return NET_DROP;
    47b2:	b8 02 00 00 00       	mov    $0x2,%eax
		if (!arp_pkt) {
    47b7:	85 ff                	test   %edi,%edi
    47b9:	74 2e                	je     47e9 <ethernet_send+0x145>
	return pkt->frags->data;
    47bb:	8b 47 08             	mov    0x8(%edi),%eax
	return net_pkt_ip_data(pkt) - net_pkt_ll_reserve(pkt);
    47be:	0f b6 4f 32          	movzbl 0x32(%edi),%ecx
    47c2:	8b 40 08             	mov    0x8(%eax),%eax
		net_pkt_ll_src(pkt)->len = sizeof(struct net_eth_addr);
    47c5:	c6 47 24 06          	movb   $0x6,0x24(%edi)
    47c9:	29 c8                	sub    %ecx,%eax
		net_pkt_ll_dst(pkt)->len = sizeof(struct net_eth_addr);
    47cb:	c6 47 2c 06          	movb   $0x6,0x2c(%edi)
		net_pkt_ll_dst(pkt)->addr = (u8_t *)&NET_ETH_HDR(pkt)->dst;
    47cf:	89 47 28             	mov    %eax,0x28(%edi)
		net_pkt_ll_src(pkt)->addr = (u8_t *)&NET_ETH_HDR(pkt)->src;
    47d2:	8d 48 06             	lea    0x6(%eax),%ecx
    47d5:	89 4f 20             	mov    %ecx,0x20(%edi)
	k_fifo_put(&iface->tx_queue, pkt);
    47d8:	8b 45 08             	mov    0x8(%ebp),%eax
    47db:	57                   	push   %edi
    47dc:	8d 78 18             	lea    0x18(%eax),%edi
    47df:	57                   	push   %edi
    47e0:	e8 76 20 00 00       	call   685b <k_queue_append>
    47e5:	59                   	pop    %ecx
	return NET_OK;
    47e6:	31 c0                	xor    %eax,%eax
    47e8:	5b                   	pop    %ebx
}
    47e9:	8d 65 f4             	lea    -0xc(%ebp),%esp
    47ec:	5b                   	pop    %ebx
    47ed:	5e                   	pop    %esi
    47ee:	5f                   	pop    %edi
    47ef:	5d                   	pop    %ebp
    47f0:	c3                   	ret    

000047f1 <if_get_addr>:

	return NULL;
}

static inline struct in_addr *if_get_addr(struct net_if *iface)
{
    47f1:	55                   	push   %ebp
    47f2:	89 e5                	mov    %esp,%ebp
	int i;

	for (i = 0; i < NET_IF_MAX_IPV4_ADDR; i++) {
		if (iface->ipv4.unicast[i].is_used &&
    47f4:	80 78 65 00          	cmpb   $0x0,0x65(%eax)
    47f8:	74 16                	je     4810 <if_get_addr+0x1f>
    47fa:	89 c2                	mov    %eax,%edx
		    iface->ipv4.unicast[i].addr_state == NET_ADDR_PREFERRED) {
			return &iface->ipv4.unicast[i].address.in_addr;
		}
	}

	return NULL;
    47fc:	31 c0                	xor    %eax,%eax
		if (iface->ipv4.unicast[i].is_used &&
    47fe:	66 83 7a 2c 02       	cmpw   $0x2,0x2c(%edx)
    4803:	75 0d                	jne    4812 <if_get_addr+0x21>
		    iface->ipv4.unicast[i].address.family == AF_INET &&
    4805:	83 7a 60 01          	cmpl   $0x1,0x60(%edx)
    4809:	75 07                	jne    4812 <if_get_addr+0x21>
			return &iface->ipv4.unicast[i].address.in_addr;
    480b:	8d 42 30             	lea    0x30(%edx),%eax
    480e:	eb 02                	jmp    4812 <if_get_addr+0x21>
	return NULL;
    4810:	31 c0                	xor    %eax,%eax
}
    4812:	5d                   	pop    %ebp
    4813:	c3                   	ret    

00004814 <prepare_arp>:

static inline struct net_pkt *prepare_arp(struct net_if *iface,
					  struct in_addr *next_addr,
					  struct arp_entry *entry,
					  struct net_pkt *pending)
{
    4814:	55                   	push   %ebp
    4815:	89 e5                	mov    %esp,%ebp
    4817:	57                   	push   %edi
    4818:	56                   	push   %esi
    4819:	53                   	push   %ebx
    481a:	83 ec 10             	sub    $0x10,%esp
    481d:	89 cf                	mov    %ecx,%edi
    481f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    4822:	89 45 e8             	mov    %eax,-0x18(%ebp)
	struct net_buf *frag;
	struct net_arp_hdr *hdr;
	struct net_eth_hdr *eth;
	struct in_addr *my_addr;

	pkt = net_pkt_get_reserve_tx(sizeof(struct net_eth_hdr), K_FOREVER);
    4825:	6a ff                	push   $0xffffffff
    4827:	6a 0e                	push   $0xe
    4829:	e8 13 f3 ff ff       	call   3b41 <net_pkt_get_reserve_tx>
    482e:	5a                   	pop    %edx
    482f:	89 c3                	mov    %eax,%ebx
    4831:	59                   	pop    %ecx
	if (!pkt) {
    4832:	85 c0                	test   %eax,%eax
    4834:	0f 84 2d 01 00 00    	je     4967 <prepare_arp+0x153>
		goto fail;
	}

	frag = net_pkt_get_frag(pkt, K_FOREVER);
    483a:	6a ff                	push   $0xffffffff
    483c:	50                   	push   %eax
    483d:	e8 4d f3 ff ff       	call   3b8f <net_pkt_get_frag>
    4842:	59                   	pop    %ecx
    4843:	89 45 ec             	mov    %eax,-0x14(%ebp)
    4846:	5e                   	pop    %esi
	if (!frag) {
    4847:	85 c0                	test   %eax,%eax
    4849:	0f 84 18 01 00 00    	je     4967 <prepare_arp+0x153>
		goto fail;
	}

	net_pkt_frag_add(pkt, frag);
    484f:	50                   	push   %eax
    4850:	53                   	push   %ebx
    4851:	e8 f6 f3 ff ff       	call   3c4c <net_pkt_frag_add>
    4856:	58                   	pop    %eax
	pkt->iface = iface;
    4857:	8b 45 e8             	mov    -0x18(%ebp),%eax
    485a:	5a                   	pop    %edx
    485b:	89 43 14             	mov    %eax,0x14(%ebx)
	pkt->lladdr_src.type = iface->link_addr.type;
    485e:	8a 40 15             	mov    0x15(%eax),%al
    4861:	88 43 25             	mov    %al,0x25(%ebx)
	pkt->lladdr_dst.type = iface->link_addr.type;
    4864:	88 43 2d             	mov    %al,0x2d(%ebx)
	pkt->family = family;
    4867:	8a 43 34             	mov    0x34(%ebx),%al
    486a:	83 e0 87             	and    $0xffffff87,%eax
    486d:	83 c8 10             	or     $0x10,%eax
    4870:	88 43 34             	mov    %al,0x34(%ebx)
	return pkt->frags->data;
    4873:	8b 43 08             	mov    0x8(%ebx),%eax
    4876:	8b 70 08             	mov    0x8(%eax),%esi
	return net_pkt_ip_data(pkt) - net_pkt_ll_reserve(pkt);
    4879:	0f b6 43 32          	movzbl 0x32(%ebx),%eax
    487d:	89 f1                	mov    %esi,%ecx
    487f:	29 c1                	sub    %eax,%ecx
	/* If entry is not set, then we are just about to send
	 * an ARP request using the data in pending net_pkt.
	 * This can happen if there is already a pending ARP
	 * request and we want to send it again.
	 */
	if (entry) {
    4881:	85 ff                	test   %edi,%edi
    4883:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    4886:	74 22                	je     48aa <prepare_arp+0x96>
		entry->pending = net_pkt_ref(pending);
    4888:	ff 75 08             	pushl  0x8(%ebp)
    488b:	e8 2a f3 ff ff       	call   3bba <net_pkt_ref>
		entry->iface = net_pkt_iface(pkt);

		net_ipaddr_copy(&entry->ip, next_addr);
    4890:	8b 55 e4             	mov    -0x1c(%ebp),%edx
		entry->pending = net_pkt_ref(pending);
    4893:	89 47 08             	mov    %eax,0x8(%edi)
		net_ipaddr_copy(&entry->ip, next_addr);
    4896:	8b 12                	mov    (%edx),%edx
    4898:	8b 43 14             	mov    0x14(%ebx),%eax
    489b:	89 57 0c             	mov    %edx,0xc(%edi)
		entry->iface = net_pkt_iface(pkt);
    489e:	89 47 04             	mov    %eax,0x4(%edi)

		memcpy(&eth->src.addr,
    48a1:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
    48a8:	eb 05                	jmp    48af <prepare_arp+0x9b>
		       net_if_get_link_addr(entry->iface)->addr,
		       sizeof(struct net_eth_addr));
	} else {
		memcpy(&eth->src.addr,
    48aa:	6a 06                	push   $0x6
    48ac:	8b 45 e8             	mov    -0x18(%ebp),%eax
    48af:	ff 70 10             	pushl  0x10(%eax)
    48b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    48b5:	83 c0 06             	add    $0x6,%eax
    48b8:	50                   	push   %eax
    48b9:	e8 1a d8 ff ff       	call   20d8 <memcpy>
    48be:	83 c4 0c             	add    $0xc,%esp
		       net_if_get_link_addr(iface)->addr,
		       sizeof(struct net_eth_addr));
	}

	eth->type = htons(NET_ETH_PTYPE_ARP);
    48c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    48c4:	66 c7 40 0c 08 06    	movw   $0x608,0xc(%eax)
	memset(&eth->dst.addr, 0xff, sizeof(struct net_eth_addr));
    48ca:	6a 06                	push   $0x6
    48cc:	68 ff 00 00 00       	push   $0xff
    48d1:	50                   	push   %eax
    48d2:	e8 6c d8 ff ff       	call   2143 <memset>
    48d7:	83 c4 0c             	add    $0xc,%esp

	hdr->hwtype = htons(NET_ARP_HTYPE_ETH);
    48da:	66 c7 06 00 01       	movw   $0x100,(%esi)
	hdr->protocol = htons(NET_ETH_PTYPE_IP);
    48df:	66 c7 46 02 08 00    	movw   $0x8,0x2(%esi)
	hdr->hwlen = sizeof(struct net_eth_addr);
    48e5:	c6 46 04 06          	movb   $0x6,0x4(%esi)
	hdr->protolen = sizeof(struct in_addr);
    48e9:	c6 46 05 04          	movb   $0x4,0x5(%esi)
	hdr->opcode = htons(NET_ARP_REQUEST);
    48ed:	66 c7 46 06 00 01    	movw   $0x100,0x6(%esi)

	memset(&hdr->dst_hwaddr.addr, 0x00, sizeof(struct net_eth_addr));
    48f3:	8d 46 12             	lea    0x12(%esi),%eax
    48f6:	6a 06                	push   $0x6
    48f8:	6a 00                	push   $0x0
    48fa:	50                   	push   %eax
    48fb:	e8 43 d8 ff ff       	call   2143 <memset>

	net_ipaddr_copy(&hdr->dst_ipaddr, next_addr);
    4900:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	memset(&hdr->dst_hwaddr.addr, 0x00, sizeof(struct net_eth_addr));
    4903:	83 c4 0c             	add    $0xc,%esp
	net_ipaddr_copy(&hdr->dst_ipaddr, next_addr);
    4906:	8b 00                	mov    (%eax),%eax
    4908:	89 46 18             	mov    %eax,0x18(%esi)

	memcpy(hdr->src_hwaddr.addr, eth->src.addr,
    490b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    490e:	83 c0 06             	add    $0x6,%eax
    4911:	6a 06                	push   $0x6
    4913:	50                   	push   %eax
    4914:	8d 46 08             	lea    0x8(%esi),%eax
    4917:	50                   	push   %eax
    4918:	e8 bb d7 ff ff       	call   20d8 <memcpy>
    491d:	83 c4 0c             	add    $0xc,%esp
	       sizeof(struct net_eth_addr));

	if (entry) {
    4920:	85 ff                	test   %edi,%edi
    4922:	74 0a                	je     492e <prepare_arp+0x11a>
		my_addr = if_get_addr(entry->iface);
    4924:	8b 47 04             	mov    0x4(%edi),%eax
    4927:	e8 c5 fe ff ff       	call   47f1 <if_get_addr>
    492c:	eb 0c                	jmp    493a <prepare_arp+0x126>
	return pkt->frags->data;
    492e:	8b 45 08             	mov    0x8(%ebp),%eax
    4931:	8b 40 08             	mov    0x8(%eax),%eax
	} else {
		my_addr = &NET_IPV4_HDR(pending)->src;
    4934:	8b 40 08             	mov    0x8(%eax),%eax
    4937:	83 c0 0c             	add    $0xc,%eax
	}

	if (my_addr) {
    493a:	85 c0                	test   %eax,%eax
    493c:	74 07                	je     4945 <prepare_arp+0x131>
		net_ipaddr_copy(&hdr->src_ipaddr, my_addr);
    493e:	8b 00                	mov    (%eax),%eax
    4940:	89 46 0e             	mov    %eax,0xe(%esi)
    4943:	eb 10                	jmp    4955 <prepare_arp+0x141>
	} else {
		memset(&hdr->src_ipaddr, 0, sizeof(struct in_addr));
    4945:	83 c6 0e             	add    $0xe,%esi
    4948:	6a 04                	push   $0x4
    494a:	6a 00                	push   $0x0
    494c:	56                   	push   %esi
    494d:	e8 f1 d7 ff ff       	call   2143 <memset>
    4952:	83 c4 0c             	add    $0xc,%esp
	}

	net_buf_add(frag, sizeof(struct net_arp_hdr));
    4955:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4958:	6a 1c                	push   $0x1c
    495a:	83 c0 08             	add    $0x8,%eax
    495d:	50                   	push   %eax
    495e:	e8 23 eb ff ff       	call   3486 <net_buf_simple_add>
    4963:	59                   	pop    %ecx
    4964:	5e                   	pop    %esi

	return pkt;
    4965:	eb 12                	jmp    4979 <prepare_arp+0x165>

fail:
	net_pkt_unref(pkt);
    4967:	53                   	push   %ebx
    4968:	e8 6e f2 ff ff       	call   3bdb <net_pkt_unref>
    496d:	58                   	pop    %eax
	net_pkt_unref(pending);
	return NULL;
    496e:	31 db                	xor    %ebx,%ebx
	net_pkt_unref(pending);
    4970:	ff 75 08             	pushl  0x8(%ebp)
    4973:	e8 63 f2 ff ff       	call   3bdb <net_pkt_unref>
    4978:	5a                   	pop    %edx
}
    4979:	8d 65 f4             	lea    -0xc(%ebp),%esp
    497c:	89 d8                	mov    %ebx,%eax
    497e:	5b                   	pop    %ebx
    497f:	5e                   	pop    %esi
    4980:	5f                   	pop    %edi
    4981:	5d                   	pop    %ebp
    4982:	c3                   	ret    

00004983 <net_arp_prepare>:

struct net_pkt *net_arp_prepare(struct net_pkt *pkt)
{
    4983:	55                   	push   %ebp
    4984:	89 e5                	mov    %esp,%ebp
    4986:	57                   	push   %edi
    4987:	56                   	push   %esi
    4988:	53                   	push   %ebx
    4989:	83 ec 08             	sub    $0x8,%esp
    498c:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct arp_entry *entry, *free_entry = NULL, *non_pending = NULL;
	struct net_linkaddr *ll;
	struct net_eth_hdr *hdr;
	struct in_addr *addr;

	if (!pkt || !pkt->frags) {
    498f:	85 db                	test   %ebx,%ebx
    4991:	0f 84 b8 01 00 00    	je     4b4f <net_arp_prepare+0x1cc>
    4997:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
    499b:	0f 84 ac 01 00 00    	je     4b4d <net_arp_prepare+0x1ca>
		return NULL;
	}

	if (net_pkt_ll_reserve(pkt) != sizeof(struct net_eth_hdr)) {
    49a1:	80 7b 32 0e          	cmpb   $0xe,0x32(%ebx)
    49a5:	74 58                	je     49ff <net_arp_prepare+0x7c>
	pkt->ll_reserve = len;
    49a7:	c6 43 32 0e          	movb   $0xe,0x32(%ebx)
		struct net_buf *header;
		struct net_linkaddr *ll;

		net_pkt_set_ll_reserve(pkt, sizeof(struct net_eth_hdr));

		header = net_pkt_get_frag(pkt, K_FOREVER);
    49ab:	6a ff                	push   $0xffffffff
    49ad:	53                   	push   %ebx
    49ae:	e8 dc f1 ff ff       	call   3b8f <net_pkt_get_frag>
    49b3:	5e                   	pop    %esi
    49b4:	5f                   	pop    %edi
    49b5:	89 c7                	mov    %eax,%edi

		hdr = (struct net_eth_hdr *)(header->data -
					     net_pkt_ll_reserve(pkt));
    49b7:	0f b6 43 32          	movzbl 0x32(%ebx),%eax
		hdr = (struct net_eth_hdr *)(header->data -
    49bb:	8b 77 08             	mov    0x8(%edi),%esi
    49be:	29 c6                	sub    %eax,%esi

		hdr->type = htons(NET_ETH_PTYPE_IP);

		ll = net_pkt_ll_dst(pkt);
		if (ll->addr) {
    49c0:	8b 43 28             	mov    0x28(%ebx),%eax
    49c3:	85 c0                	test   %eax,%eax
		hdr->type = htons(NET_ETH_PTYPE_IP);
    49c5:	66 c7 46 0c 08 00    	movw   $0x8,0xc(%esi)
		if (ll->addr) {
    49cb:	74 0c                	je     49d9 <net_arp_prepare+0x56>
			memcpy(&hdr->dst.addr, ll->addr,
    49cd:	6a 06                	push   $0x6
    49cf:	50                   	push   %eax
    49d0:	56                   	push   %esi
    49d1:	e8 02 d7 ff ff       	call   20d8 <memcpy>
    49d6:	83 c4 0c             	add    $0xc,%esp
			       sizeof(struct net_eth_addr));
		}

		ll = net_pkt_ll_src(pkt);
		if (ll->addr) {
    49d9:	8b 43 20             	mov    0x20(%ebx),%eax
    49dc:	85 c0                	test   %eax,%eax
    49de:	74 0f                	je     49ef <net_arp_prepare+0x6c>
			memcpy(&hdr->src.addr, ll->addr,
    49e0:	83 c6 06             	add    $0x6,%esi
    49e3:	6a 06                	push   $0x6
    49e5:	50                   	push   %eax
    49e6:	56                   	push   %esi
    49e7:	e8 ec d6 ff ff       	call   20d8 <memcpy>
    49ec:	83 c4 0c             	add    $0xc,%esp
			       sizeof(struct net_eth_addr));
		}

		net_pkt_frag_insert(pkt, header);
    49ef:	57                   	push   %edi
    49f0:	53                   	push   %ebx
    49f1:	e8 ad f2 ff ff       	call   3ca3 <net_pkt_frag_insert>
    49f6:	58                   	pop    %eax
    49f7:	5a                   	pop    %edx

		net_pkt_compact(pkt);
    49f8:	53                   	push   %ebx
    49f9:	e8 fb f3 ff ff       	call   3df9 <net_pkt_compact>
    49fe:	59                   	pop    %ecx
	return pkt->frags->data;
    49ff:	8b 43 08             	mov    0x8(%ebx),%eax
	hdr = (struct net_eth_hdr *)net_pkt_ll(pkt);

	/* Is the destination in the local network, if not route via
	 * the gateway address.
	 */
	if (!net_if_ipv4_addr_mask_cmp(net_pkt_iface(pkt),
    4a02:	8b 40 08             	mov    0x8(%eax),%eax
    4a05:	83 c0 10             	add    $0x10,%eax
    4a08:	50                   	push   %eax
    4a09:	ff 73 14             	pushl  0x14(%ebx)
    4a0c:	e8 e6 ec ff ff       	call   36f7 <net_if_ipv4_addr_mask_cmp>
    4a11:	5e                   	pop    %esi
    4a12:	84 c0                	test   %al,%al
    4a14:	5f                   	pop    %edi
    4a15:	8b 73 14             	mov    0x14(%ebx),%esi
    4a18:	75 05                	jne    4a1f <net_arp_prepare+0x9c>
				       &NET_IPV4_HDR(pkt)->dst)) {
		addr = &net_pkt_iface(pkt)->ipv4.gw;
    4a1a:	8d 56 74             	lea    0x74(%esi),%edx
    4a1d:	eb 09                	jmp    4a28 <net_arp_prepare+0xa5>
    4a1f:	8b 43 08             	mov    0x8(%ebx),%eax
	} else {
		addr = &NET_IPV4_HDR(pkt)->dst;
    4a22:	8b 50 08             	mov    0x8(%eax),%edx
    4a25:	83 c2 10             	add    $0x10,%edx
		if (arp_table[i].iface == iface &&
    4a28:	8b 0d 04 53 40 00    	mov    0x405304,%ecx
    4a2e:	39 ce                	cmp    %ecx,%esi
    4a30:	75 09                	jne    4a3b <net_arp_prepare+0xb8>
    4a32:	a1 0c 53 40 00       	mov    0x40530c,%eax
    4a37:	39 02                	cmp    %eax,(%edx)
    4a39:	74 43                	je     4a7e <net_arp_prepare+0xfb>
		if (!*free_entry && !arp_table[i].pending &&
    4a3b:	8b 3d 08 53 40 00    	mov    0x405308,%edi
    4a41:	85 ff                	test   %edi,%edi
    4a43:	75 09                	jne    4a4e <net_arp_prepare+0xcb>
			*free_entry = &arp_table[i];
    4a45:	b8 00 53 40 00       	mov    $0x405300,%eax
		if (!*free_entry && !arp_table[i].pending &&
    4a4a:	85 c9                	test   %ecx,%ecx
    4a4c:	74 02                	je     4a50 <net_arp_prepare+0xcd>
    4a4e:	31 c0                	xor    %eax,%eax
			*non_pending = &arp_table[i];
    4a50:	b9 00 53 40 00       	mov    $0x405300,%ecx
		if (!*non_pending && !arp_table[i].pending) {
    4a55:	85 ff                	test   %edi,%edi
    4a57:	74 02                	je     4a5b <net_arp_prepare+0xd8>
    4a59:	31 c9                	xor    %ecx,%ecx
		if (arp_table[i].iface == iface &&
    4a5b:	8b 3d 1c 53 40 00    	mov    0x40531c,%edi
    4a61:	89 7d f0             	mov    %edi,-0x10(%ebp)
    4a64:	39 fe                	cmp    %edi,%esi
    4a66:	75 37                	jne    4a9f <net_arp_prepare+0x11c>
    4a68:	8b 3a                	mov    (%edx),%edi
    4a6a:	39 3d 24 53 40 00    	cmp    %edi,0x405324
    4a70:	75 2d                	jne    4a9f <net_arp_prepare+0x11c>
	for (i = 0; i < CONFIG_NET_ARP_TABLE_SIZE; i++) {
    4a72:	b8 01 00 00 00       	mov    $0x1,%eax
		if (arp_table[i].iface == iface &&
    4a77:	bf 18 00 00 00       	mov    $0x18,%edi
    4a7c:	eb 04                	jmp    4a82 <net_arp_prepare+0xff>
	for (i = 0; i < CONFIG_NET_ARP_TABLE_SIZE; i++) {
    4a7e:	31 c0                	xor    %eax,%eax
		if (arp_table[i].iface == iface &&
    4a80:	31 ff                	xor    %edi,%edi
			if (arp_table[i].pending) {
    4a82:	6b c0 18             	imul   $0x18,%eax,%eax
    4a85:	83 b8 08 53 40 00 00 	cmpl   $0x0,0x405308(%eax)
    4a8c:	75 43                	jne    4ad1 <net_arp_prepare+0x14e>
						 net_pkt_ll_reserve(pkt));
		hdr->type = htons(NET_ETH_PTYPE_IP);

		memcpy(&hdr->src.addr, ll->addr,
		       sizeof(struct net_eth_addr));
		memcpy(&hdr->dst.addr, &entry->eth.addr,
    4a8e:	8d 87 10 53 40 00    	lea    0x405310(%edi),%eax
	frag = pkt->frags;
    4a94:	8b 53 08             	mov    0x8(%ebx),%edx
		memcpy(&hdr->dst.addr, &entry->eth.addr,
    4a97:	89 45 f0             	mov    %eax,-0x10(%ebp)
	while (frag) {
    4a9a:	e9 a8 00 00 00       	jmp    4b47 <net_arp_prepare+0x1c4>
		if (!*free_entry && !arp_table[i].pending &&
    4a9f:	85 c0                	test   %eax,%eax
    4aa1:	75 14                	jne    4ab7 <net_arp_prepare+0x134>
    4aa3:	83 3d 20 53 40 00 00 	cmpl   $0x0,0x405320
    4aaa:	75 0b                	jne    4ab7 <net_arp_prepare+0x134>
    4aac:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    4ab0:	75 05                	jne    4ab7 <net_arp_prepare+0x134>
			*free_entry = &arp_table[i];
    4ab2:	b8 18 53 40 00       	mov    $0x405318,%eax
		if (!*non_pending && !arp_table[i].pending) {
    4ab7:	85 c9                	test   %ecx,%ecx
    4ab9:	75 0e                	jne    4ac9 <net_arp_prepare+0x146>
    4abb:	83 3d 20 53 40 00 00 	cmpl   $0x0,0x405320
    4ac2:	75 05                	jne    4ac9 <net_arp_prepare+0x146>
			*non_pending = &arp_table[i];
    4ac4:	b9 18 53 40 00       	mov    $0x405318,%ecx
		if (!free_entry) {
    4ac9:	85 c0                	test   %eax,%eax
    4acb:	75 1d                	jne    4aea <net_arp_prepare+0x167>
			if (!non_pending) {
    4acd:	85 c9                	test   %ecx,%ecx
    4acf:	75 1b                	jne    4aec <net_arp_prepare+0x169>
				req = prepare_arp(net_pkt_iface(pkt),
    4ad1:	31 c9                	xor    %ecx,%ecx
    4ad3:	89 f0                	mov    %esi,%eax
    4ad5:	53                   	push   %ebx
    4ad6:	e8 39 fd ff ff       	call   4814 <prepare_arp>
    4adb:	89 c6                	mov    %eax,%esi
				net_pkt_unref(pkt);
    4add:	89 1c 24             	mov    %ebx,(%esp)
    4ae0:	e8 f6 f0 ff ff       	call   3bdb <net_pkt_unref>
				return req;
    4ae5:	89 f3                	mov    %esi,%ebx
				net_pkt_unref(pkt);
    4ae7:	59                   	pop    %ecx
				return req;
    4ae8:	eb 65                	jmp    4b4f <net_arp_prepare+0x1cc>
    4aea:	89 c1                	mov    %eax,%ecx
		return prepare_arp(net_pkt_iface(pkt), addr, free_entry, pkt);
    4aec:	89 5d 08             	mov    %ebx,0x8(%ebp)

		frag = frag->frags;
	}

	return pkt;
}
    4aef:	8d 65 f4             	lea    -0xc(%ebp),%esp
		return prepare_arp(net_pkt_iface(pkt), addr, free_entry, pkt);
    4af2:	89 f0                	mov    %esi,%eax
}
    4af4:	5b                   	pop    %ebx
    4af5:	5e                   	pop    %esi
    4af6:	5f                   	pop    %edi
    4af7:	5d                   	pop    %ebp
		return prepare_arp(net_pkt_iface(pkt), addr, free_entry, pkt);
    4af8:	e9 17 fd ff ff       	jmp    4814 <prepare_arp>
		if (!net_buf_headroom(frag)) {
    4afd:	8d 42 08             	lea    0x8(%edx),%eax
    4b00:	89 55 ec             	mov    %edx,-0x14(%ebp)
    4b03:	50                   	push   %eax
    4b04:	e8 c1 e9 ff ff       	call   34ca <net_buf_simple_headroom>
    4b09:	5a                   	pop    %edx
    4b0a:	85 c0                	test   %eax,%eax
    4b0c:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4b0f:	74 34                	je     4b45 <net_arp_prepare+0x1c2>
						 net_pkt_ll_reserve(pkt));
    4b11:	0f b6 43 32          	movzbl 0x32(%ebx),%eax
		hdr = (struct net_eth_hdr *)(frag->data -
    4b15:	8b 7a 08             	mov    0x8(%edx),%edi
    4b18:	89 55 ec             	mov    %edx,-0x14(%ebp)
    4b1b:	29 c7                	sub    %eax,%edi
		hdr->type = htons(NET_ETH_PTYPE_IP);
    4b1d:	66 c7 47 0c 08 00    	movw   $0x8,0xc(%edi)
		memcpy(&hdr->src.addr, ll->addr,
    4b23:	6a 06                	push   $0x6
    4b25:	ff 76 10             	pushl  0x10(%esi)
    4b28:	8d 47 06             	lea    0x6(%edi),%eax
    4b2b:	50                   	push   %eax
    4b2c:	e8 a7 d5 ff ff       	call   20d8 <memcpy>
    4b31:	83 c4 0c             	add    $0xc,%esp
		memcpy(&hdr->dst.addr, &entry->eth.addr,
    4b34:	6a 06                	push   $0x6
    4b36:	ff 75 f0             	pushl  -0x10(%ebp)
    4b39:	57                   	push   %edi
    4b3a:	e8 99 d5 ff ff       	call   20d8 <memcpy>
    4b3f:	83 c4 0c             	add    $0xc,%esp
		frag = frag->frags;
    4b42:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4b45:	8b 12                	mov    (%edx),%edx
	while (frag) {
    4b47:	85 d2                	test   %edx,%edx
    4b49:	75 b2                	jne    4afd <net_arp_prepare+0x17a>
    4b4b:	eb 02                	jmp    4b4f <net_arp_prepare+0x1cc>
		return NULL;
    4b4d:	31 db                	xor    %ebx,%ebx
}
    4b4f:	8d 65 f4             	lea    -0xc(%ebp),%esp
    4b52:	89 d8                	mov    %ebx,%eax
    4b54:	5b                   	pop    %ebx
    4b55:	5e                   	pop    %esi
    4b56:	5f                   	pop    %edi
    4b57:	5d                   	pop    %ebp
    4b58:	c3                   	ret    

00004b59 <net_arp_input>:
	net_pkt_unref(pkt);
	return NULL;
}

enum net_verdict net_arp_input(struct net_pkt *pkt)
{
    4b59:	55                   	push   %ebp
 *
 *  @return Number of bytes in the buffer and its fragments.
 */
static inline size_t net_buf_frags_len(struct net_buf *buf)
{
	size_t bytes = 0;
    4b5a:	31 d2                	xor    %edx,%edx
    4b5c:	89 e5                	mov    %esp,%ebp
    4b5e:	57                   	push   %edi
    4b5f:	56                   	push   %esi
    4b60:	53                   	push   %ebx
    4b61:	83 ec 14             	sub    $0x14,%esp
    4b64:	8b 75 08             	mov    0x8(%ebp),%esi
    4b67:	8b 5e 08             	mov    0x8(%esi),%ebx
    4b6a:	89 d8                	mov    %ebx,%eax

	while (buf) {
    4b6c:	85 c0                	test   %eax,%eax
    4b6e:	74 0a                	je     4b7a <net_arp_input+0x21>
		bytes += buf->len;
    4b70:	0f b7 48 0c          	movzwl 0xc(%eax),%ecx
		buf = buf->frags;
    4b74:	8b 00                	mov    (%eax),%eax
		bytes += buf->len;
    4b76:	01 ca                	add    %ecx,%edx
    4b78:	eb f2                	jmp    4b6c <net_arp_input+0x13>
	struct net_arp_hdr *arp_hdr;
	struct net_pkt *reply;
	struct in_addr *addr;

	if (net_pkt_get_len(pkt) < (sizeof(struct net_arp_hdr) -
				    net_pkt_ll_reserve(pkt))) {
    4b7a:	0f b6 4e 32          	movzbl 0x32(%esi),%ecx
	if (net_pkt_get_len(pkt) < (sizeof(struct net_arp_hdr) -
    4b7e:	b8 1c 00 00 00       	mov    $0x1c,%eax
		NET_DBG("Invalid ARP header (len %zu, min %zu bytes)",
			net_pkt_get_len(pkt),
			sizeof(struct net_arp_hdr) -
			net_pkt_ll_reserve(pkt));
		return NET_DROP;
    4b83:	bf 02 00 00 00       	mov    $0x2,%edi
	if (net_pkt_get_len(pkt) < (sizeof(struct net_arp_hdr) -
    4b88:	29 c8                	sub    %ecx,%eax
    4b8a:	39 d0                	cmp    %edx,%eax
    4b8c:	0f 87 07 02 00 00    	ja     4d99 <net_arp_input+0x240>
    4b92:	8b 5b 08             	mov    0x8(%ebx),%ebx
	}

	arp_hdr = NET_ARP_HDR(pkt);

	switch (ntohs(arp_hdr->opcode)) {
    4b95:	66 8b 43 06          	mov    0x6(%ebx),%ax
    4b99:	86 e0                	xchg   %ah,%al
    4b9b:	66 83 f8 01          	cmp    $0x1,%ax
    4b9f:	74 0f                	je     4bb0 <net_arp_input+0x57>
    4ba1:	66 83 f8 02          	cmp    $0x2,%ax
    4ba5:	0f 84 39 01 00 00    	je     4ce4 <net_arp_input+0x18b>
    4bab:	e9 e0 01 00 00       	jmp    4d90 <net_arp_input+0x237>
    4bb0:	8b 46 14             	mov    0x14(%esi),%eax
    4bb3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	case NET_ARP_REQUEST:
		/* Someone wants to know our ll address */
		addr = if_get_addr(net_pkt_iface(pkt));
    4bb6:	e8 36 fc ff ff       	call   47f1 <if_get_addr>
		if (!addr) {
    4bbb:	85 c0                	test   %eax,%eax
    4bbd:	0f 84 d6 01 00 00    	je     4d99 <net_arp_input+0x240>
			return NET_DROP;
		}

		if (!net_ipv4_addr_cmp(&arp_hdr->dst_ipaddr, addr)) {
    4bc3:	8b 53 18             	mov    0x18(%ebx),%edx
    4bc6:	39 10                	cmp    %edx,(%eax)
    4bc8:	0f 85 cb 01 00 00    	jne    4d99 <net_arp_input+0x240>
	pkt = net_pkt_get_reserve_tx(sizeof(struct net_eth_hdr), K_FOREVER);
    4bce:	6a ff                	push   $0xffffffff
    4bd0:	6a 0e                	push   $0xe
    4bd2:	e8 6a ef ff ff       	call   3b41 <net_pkt_get_reserve_tx>
    4bd7:	5a                   	pop    %edx
    4bd8:	89 c3                	mov    %eax,%ebx
    4bda:	59                   	pop    %ecx
	if (!pkt) {
    4bdb:	85 c0                	test   %eax,%eax
    4bdd:	0f 84 a6 01 00 00    	je     4d89 <net_arp_input+0x230>
	frag = net_pkt_get_frag(pkt, K_FOREVER);
    4be3:	6a ff                	push   $0xffffffff
    4be5:	50                   	push   %eax
    4be6:	e8 a4 ef ff ff       	call   3b8f <net_pkt_get_frag>
    4beb:	59                   	pop    %ecx
    4bec:	89 45 ec             	mov    %eax,-0x14(%ebp)
    4bef:	5f                   	pop    %edi
	if (!frag) {
    4bf0:	85 c0                	test   %eax,%eax
    4bf2:	0f 84 91 01 00 00    	je     4d89 <net_arp_input+0x230>
	net_pkt_frag_add(pkt, frag);
    4bf8:	50                   	push   %eax
    4bf9:	53                   	push   %ebx
    4bfa:	e8 4d f0 ff ff       	call   3c4c <net_pkt_frag_add>
    4bff:	58                   	pop    %eax
	pkt->iface = iface;
    4c00:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4c03:	5a                   	pop    %edx
    4c04:	89 43 14             	mov    %eax,0x14(%ebx)
	pkt->lladdr_src.type = iface->link_addr.type;
    4c07:	8a 40 15             	mov    0x15(%eax),%al
    4c0a:	88 43 25             	mov    %al,0x25(%ebx)
	pkt->lladdr_dst.type = iface->link_addr.type;
    4c0d:	88 43 2d             	mov    %al,0x2d(%ebx)
	pkt->family = family;
    4c10:	8a 43 34             	mov    0x34(%ebx),%al
    4c13:	83 e0 87             	and    $0xffffff87,%eax
    4c16:	83 c8 10             	or     $0x10,%eax
    4c19:	88 43 34             	mov    %al,0x34(%ebx)
	return pkt->frags->data;
    4c1c:	8b 43 08             	mov    0x8(%ebx),%eax
    4c1f:	8b 78 08             	mov    0x8(%eax),%edi
	return net_pkt_ip_data(pkt) - net_pkt_ll_reserve(pkt);
    4c22:	0f b6 43 32          	movzbl 0x32(%ebx),%eax
    4c26:	89 f9                	mov    %edi,%ecx
    4c28:	29 c1                	sub    %eax,%ecx
	return pkt->frags->data;
    4c2a:	8b 46 08             	mov    0x8(%esi),%eax
	return net_pkt_ip_data(pkt) - net_pkt_ll_reserve(pkt);
    4c2d:	89 4d e8             	mov    %ecx,-0x18(%ebp)
	return pkt->frags->data;
    4c30:	8b 50 08             	mov    0x8(%eax),%edx
	return net_pkt_ip_data(pkt) - net_pkt_ll_reserve(pkt);
    4c33:	0f b6 46 32          	movzbl 0x32(%esi),%eax
    4c37:	89 d1                	mov    %edx,%ecx
    4c39:	89 55 e0             	mov    %edx,-0x20(%ebp)
    4c3c:	29 c1                	sub    %eax,%ecx
	eth->type = htons(NET_ETH_PTYPE_ARP);
    4c3e:	8b 55 e8             	mov    -0x18(%ebp),%edx
    4c41:	89 c8                	mov    %ecx,%eax
	memcpy(&eth->dst.addr, &eth_query->src.addr,
    4c43:	83 c0 06             	add    $0x6,%eax
	eth->type = htons(NET_ETH_PTYPE_ARP);
    4c46:	66 c7 42 0c 08 06    	movw   $0x608,0xc(%edx)
	memcpy(&eth->dst.addr, &eth_query->src.addr,
    4c4c:	6a 06                	push   $0x6
    4c4e:	50                   	push   %eax
    4c4f:	52                   	push   %edx
    4c50:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    4c53:	e8 80 d4 ff ff       	call   20d8 <memcpy>
    4c58:	83 c4 0c             	add    $0xc,%esp
	memcpy(&eth->src.addr, net_if_get_link_addr(iface)->addr,
    4c5b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4c5e:	6a 06                	push   $0x6
    4c60:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    4c63:	ff 70 10             	pushl  0x10(%eax)
    4c66:	83 c1 06             	add    $0x6,%ecx
    4c69:	51                   	push   %ecx
    4c6a:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    4c6d:	e8 66 d4 ff ff       	call   20d8 <memcpy>
    4c72:	83 c4 0c             	add    $0xc,%esp
	hdr->hwtype = htons(NET_ARP_HTYPE_ETH);
    4c75:	66 c7 07 00 01       	movw   $0x100,(%edi)
	hdr->protocol = htons(NET_ETH_PTYPE_IP);
    4c7a:	66 c7 47 02 08 00    	movw   $0x8,0x2(%edi)
	hdr->hwlen = sizeof(struct net_eth_addr);
    4c80:	c6 47 04 06          	movb   $0x6,0x4(%edi)
	hdr->protolen = sizeof(struct in_addr);
    4c84:	c6 47 05 04          	movb   $0x4,0x5(%edi)
	hdr->opcode = htons(NET_ARP_REPLY);
    4c88:	66 c7 47 06 00 02    	movw   $0x200,0x6(%edi)
	memcpy(&hdr->dst_hwaddr.addr, &eth_query->src.addr,
    4c8e:	6a 06                	push   $0x6
    4c90:	ff 75 e4             	pushl  -0x1c(%ebp)
    4c93:	8d 47 12             	lea    0x12(%edi),%eax
    4c96:	50                   	push   %eax
    4c97:	e8 3c d4 ff ff       	call   20d8 <memcpy>
    4c9c:	83 c4 0c             	add    $0xc,%esp
	memcpy(&hdr->src_hwaddr.addr, &eth->src.addr,
    4c9f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    4ca2:	8d 47 08             	lea    0x8(%edi),%eax
    4ca5:	6a 06                	push   $0x6
    4ca7:	51                   	push   %ecx
    4ca8:	50                   	push   %eax
    4ca9:	e8 2a d4 ff ff       	call   20d8 <memcpy>
	net_ipaddr_copy(&hdr->dst_ipaddr, &query->src_ipaddr);
    4cae:	8b 55 e0             	mov    -0x20(%ebp),%edx
	memcpy(&hdr->src_hwaddr.addr, &eth->src.addr,
    4cb1:	83 c4 0c             	add    $0xc,%esp
	net_ipaddr_copy(&hdr->dst_ipaddr, &query->src_ipaddr);
    4cb4:	8b 42 0e             	mov    0xe(%edx),%eax
    4cb7:	89 47 18             	mov    %eax,0x18(%edi)
	net_ipaddr_copy(&hdr->src_ipaddr, &query->dst_ipaddr);
    4cba:	8b 42 18             	mov    0x18(%edx),%eax
    4cbd:	89 47 0e             	mov    %eax,0xe(%edi)
	net_buf_add(frag, sizeof(struct net_arp_hdr));
    4cc0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4cc3:	83 c0 08             	add    $0x8,%eax
    4cc6:	6a 1c                	push   $0x1c
    4cc8:	50                   	push   %eax
    4cc9:	e8 b8 e7 ff ff       	call   3486 <net_buf_simple_add>
    4cce:	8b 43 14             	mov    0x14(%ebx),%eax
    4cd1:	59                   	pop    %ecx
    4cd2:	83 c0 18             	add    $0x18,%eax
    4cd5:	5f                   	pop    %edi
    4cd6:	53                   	push   %ebx
    4cd7:	50                   	push   %eax
    4cd8:	e8 7e 1b 00 00       	call   685b <k_queue_append>
    4cdd:	58                   	pop    %eax
    4cde:	5a                   	pop    %edx
    4cdf:	e9 ac 00 00 00       	jmp    4d90 <net_arp_input+0x237>
			net_if_queue_tx(net_pkt_iface(reply), reply);
		}
		break;

	case NET_ARP_REPLY:
		if (net_is_my_ipv4_addr(&arp_hdr->dst_ipaddr)) {
    4ce4:	8d 43 18             	lea    0x18(%ebx),%eax
    4ce7:	6a 00                	push   $0x0
    4ce9:	50                   	push   %eax
    4cea:	e8 40 ea ff ff       	call   372f <net_if_ipv4_addr_lookup>
    4cef:	59                   	pop    %ecx
    4cf0:	85 c0                	test   %eax,%eax
    4cf2:	5f                   	pop    %edi
    4cf3:	0f 84 97 00 00 00    	je     4d90 <net_arp_input+0x237>
    4cf9:	8b 7e 14             	mov    0x14(%esi),%edi
		if (arp_table[i].iface != iface ||
    4cfc:	39 3d 04 53 40 00    	cmp    %edi,0x405304
    4d02:	75 0b                	jne    4d0f <net_arp_input+0x1b6>
    4d04:	8b 43 0e             	mov    0xe(%ebx),%eax
    4d07:	39 05 0c 53 40 00    	cmp    %eax,0x40530c
    4d0d:	74 1a                	je     4d29 <net_arp_input+0x1d0>
    4d0f:	39 3d 1c 53 40 00    	cmp    %edi,0x40531c
    4d15:	75 79                	jne    4d90 <net_arp_input+0x237>
    4d17:	8b 43 0e             	mov    0xe(%ebx),%eax
    4d1a:	39 05 24 53 40 00    	cmp    %eax,0x405324
    4d20:	75 6e                	jne    4d90 <net_arp_input+0x237>
	for (i = 0; i < CONFIG_NET_ARP_TABLE_SIZE; i++) {
    4d22:	b8 01 00 00 00       	mov    $0x1,%eax
    4d27:	eb 02                	jmp    4d2b <net_arp_input+0x1d2>
    4d29:	31 c0                	xor    %eax,%eax
		if (arp_table[i].pending) {
    4d2b:	6b c0 18             	imul   $0x18,%eax,%eax
    4d2e:	8d 90 00 53 40 00    	lea    0x405300(%eax),%edx
    4d34:	83 b8 08 53 40 00 00 	cmpl   $0x0,0x405308(%eax)
    4d3b:	89 55 f0             	mov    %edx,-0x10(%ebp)
    4d3e:	74 50                	je     4d90 <net_arp_input+0x237>
			arp_update(net_pkt_iface(pkt), &arp_hdr->src_ipaddr,
    4d40:	83 c3 08             	add    $0x8,%ebx
			memcpy(&arp_table[i].eth, hwaddr,
    4d43:	05 10 53 40 00       	add    $0x405310,%eax
    4d48:	6a 06                	push   $0x6
    4d4a:	53                   	push   %ebx
    4d4b:	50                   	push   %eax
    4d4c:	e8 87 d3 ff ff       	call   20d8 <memcpy>
			net_pkt_ll_dst(arp_table[i].pending)->len =
    4d51:	8b 55 f0             	mov    -0x10(%ebp),%edx
			memcpy(&arp_table[i].eth, hwaddr,
    4d54:	83 c4 0c             	add    $0xc,%esp
			net_pkt_ll_dst(arp_table[i].pending)->len =
    4d57:	8b 5a 08             	mov    0x8(%edx),%ebx
	return pkt->frags->data;
    4d5a:	8b 43 08             	mov    0x8(%ebx),%eax
    4d5d:	c6 43 2c 06          	movb   $0x6,0x2c(%ebx)
	return net_pkt_ip_data(pkt) - net_pkt_ll_reserve(pkt);
    4d61:	0f b6 4b 32          	movzbl 0x32(%ebx),%ecx
    4d65:	8b 40 08             	mov    0x8(%eax),%eax
    4d68:	29 c8                	sub    %ecx,%eax
			net_pkt_ll_dst(arp_table[i].pending)->addr =
    4d6a:	89 43 28             	mov    %eax,0x28(%ebx)
	*pkt = NULL;
    4d6d:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
	if (net_if_send_data(iface, pending) == NET_DROP) {
    4d74:	53                   	push   %ebx
    4d75:	57                   	push   %edi
    4d76:	e8 75 ea ff ff       	call   37f0 <net_if_send_data>
    4d7b:	5f                   	pop    %edi
    4d7c:	83 f8 02             	cmp    $0x2,%eax
    4d7f:	5a                   	pop    %edx
    4d80:	75 07                	jne    4d89 <net_arp_input+0x230>
		net_pkt_unref(pending);
    4d82:	53                   	push   %ebx
    4d83:	e8 53 ee ff ff       	call   3bdb <net_pkt_unref>
    4d88:	59                   	pop    %ecx
	net_pkt_unref(pending);
    4d89:	53                   	push   %ebx
    4d8a:	e8 4c ee ff ff       	call   3bdb <net_pkt_unref>
    4d8f:	5a                   	pop    %edx
				   &arp_hdr->src_hwaddr);
		}
		break;
	}

	net_pkt_unref(pkt);
    4d90:	56                   	push   %esi

	return NET_OK;
    4d91:	31 ff                	xor    %edi,%edi
	net_pkt_unref(pkt);
    4d93:	e8 43 ee ff ff       	call   3bdb <net_pkt_unref>
    4d98:	58                   	pop    %eax
}
    4d99:	8d 65 f4             	lea    -0xc(%ebp),%esp
    4d9c:	89 f8                	mov    %edi,%eax
    4d9e:	5b                   	pop    %ebx
    4d9f:	5e                   	pop    %esi
    4da0:	5f                   	pop    %edi
    4da1:	5d                   	pop    %ebp
    4da2:	c3                   	ret    

00004da3 <net_arp_clear_cache>:

void net_arp_clear_cache(void)
{
    4da3:	55                   	push   %ebp
	int i;

	for (i = 0; i < CONFIG_NET_ARP_TABLE_SIZE; i++) {
		if (arp_table[i].pending) {
    4da4:	a1 08 53 40 00       	mov    0x405308,%eax
{
    4da9:	89 e5                	mov    %esp,%ebp
		if (arp_table[i].pending) {
    4dab:	85 c0                	test   %eax,%eax
    4dad:	74 07                	je     4db6 <net_arp_clear_cache+0x13>
			net_pkt_unref(arp_table[i].pending);
    4daf:	50                   	push   %eax
    4db0:	e8 26 ee ff ff       	call   3bdb <net_pkt_unref>
    4db5:	5a                   	pop    %edx
		if (arp_table[i].pending) {
    4db6:	a1 20 53 40 00       	mov    0x405320,%eax
    4dbb:	85 c0                	test   %eax,%eax
    4dbd:	74 07                	je     4dc6 <net_arp_clear_cache+0x23>
			net_pkt_unref(arp_table[i].pending);
    4dbf:	50                   	push   %eax
    4dc0:	e8 16 ee ff ff       	call   3bdb <net_pkt_unref>
    4dc5:	58                   	pop    %eax
		}
	}

	memset(&arp_table, 0, sizeof(arp_table));
    4dc6:	6a 30                	push   $0x30
    4dc8:	6a 00                	push   $0x0
    4dca:	68 00 53 40 00       	push   $0x405300
    4dcf:	e8 6f d3 ff ff       	call   2143 <memset>
    4dd4:	83 c4 0c             	add    $0xc,%esp
}
    4dd7:	c9                   	leave  
    4dd8:	c3                   	ret    

00004dd9 <net_arp_init>:

void net_arp_init(void)
{
    4dd9:	55                   	push   %ebp
    4dda:	89 e5                	mov    %esp,%ebp
	net_arp_clear_cache();
}
    4ddc:	5d                   	pop    %ebp
	net_arp_clear_cache();
    4ddd:	e9 c1 ff ff ff       	jmp    4da3 <net_arp_clear_cache>

00004de2 <setup_ipv4_header>:
#define NET_ICMPV4_UNUSED_LEN 4

static inline void setup_ipv4_header(struct net_pkt *pkt, u8_t extra_len,
				     u8_t ttl, u8_t icmp_type,
				     u8_t icmp_code)
{
    4de2:	55                   	push   %ebp

	NET_IPV4_HDR(pkt)->vhl = 0x45;
	NET_IPV4_HDR(pkt)->tos = 0x00;
	NET_IPV4_HDR(pkt)->len[0] = 0;
	NET_IPV4_HDR(pkt)->len[1] = sizeof(struct net_ipv4_hdr) +
		NET_ICMPH_LEN + extra_len + NET_ICMPV4_UNUSED_LEN;
    4de3:	83 c2 1c             	add    $0x1c,%edx
{
    4de6:	89 e5                	mov    %esp,%ebp
    4de8:	57                   	push   %edi
    4de9:	56                   	push   %esi
    4dea:	89 c6                	mov    %eax,%esi
    4dec:	53                   	push   %ebx
    4ded:	83 ec 10             	sub    $0x10,%esp
	struct net_buf *frag = pkt->frags;
    4df0:	8b 7e 08             	mov    0x8(%esi),%edi
{
    4df3:	8b 45 08             	mov    0x8(%ebp),%eax
    4df6:	89 45 e8             	mov    %eax,-0x18(%ebp)
    4df9:	8b 45 0c             	mov    0xc(%ebp),%eax
	return pkt->frags->data;
    4dfc:	8b 5f 08             	mov    0x8(%edi),%ebx
    4dff:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		NET_ICMPH_LEN + extra_len + NET_ICMPV4_UNUSED_LEN;
    4e02:	88 53 03             	mov    %dl,0x3(%ebx)

	NET_IPV4_HDR(pkt)->proto = IPPROTO_ICMP;
	NET_IPV4_HDR(pkt)->ttl = ttl;
    4e05:	88 4b 08             	mov    %cl,0x8(%ebx)
	NET_IPV4_HDR(pkt)->vhl = 0x45;
    4e08:	c6 03 45             	movb   $0x45,(%ebx)
	NET_IPV4_HDR(pkt)->tos = 0x00;
    4e0b:	c6 43 01 00          	movb   $0x0,0x1(%ebx)
	NET_IPV4_HDR(pkt)->len[0] = 0;
    4e0f:	c6 43 02 00          	movb   $0x0,0x2(%ebx)
	NET_IPV4_HDR(pkt)->proto = IPPROTO_ICMP;
    4e13:	c6 43 09 01          	movb   $0x1,0x9(%ebx)
	NET_IPV4_HDR(pkt)->offset[0] = NET_IPV4_HDR(pkt)->offset[1] = 0;
    4e17:	c6 43 07 00          	movb   $0x0,0x7(%ebx)
    4e1b:	c6 43 06 00          	movb   $0x0,0x6(%ebx)
	NET_IPV4_HDR(pkt)->id[0] = NET_IPV4_HDR(pkt)->id[1] = 0;
    4e1f:	c6 43 05 00          	movb   $0x0,0x5(%ebx)
    4e23:	c6 43 04 00          	movb   $0x0,0x4(%ebx)
	pkt->ip_hdr_len = len;
    4e27:	c6 46 33 14          	movb   $0x14,0x33(%esi)

	net_pkt_set_ip_hdr_len(pkt, sizeof(struct net_ipv4_hdr));

	NET_IPV4_HDR(pkt)->chksum = 0;
    4e2b:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
	NET_IPV4_HDR(pkt)->chksum = ~net_calc_chksum_ipv4(pkt);
    4e31:	56                   	push   %esi
    4e32:	e8 74 f6 ff ff       	call   44ab <net_calc_chksum_ipv4>
    4e37:	f7 d0                	not    %eax
    4e39:	66 89 43 0a          	mov    %ax,0xa(%ebx)
    4e3d:	8a 4d e8             	mov    -0x18(%ebp),%cl

	frag = net_pkt_write_u8(pkt, frag, net_pkt_ip_hdr_len(pkt), &pos,
    4e40:	0f b6 46 33          	movzbl 0x33(%esi),%eax
					       struct net_buf *frag,
					       u16_t offset,
					       u16_t *pos,
					       u8_t data)
{
	return net_pkt_write(pkt, frag, offset, pos, sizeof(u8_t),
    4e44:	8d 5d ee             	lea    -0x12(%ebp),%ebx
    4e47:	8d 55 ed             	lea    -0x13(%ebp),%edx
    4e4a:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
    4e51:	88 4d ed             	mov    %cl,-0x13(%ebp)
    4e54:	52                   	push   %edx
    4e55:	6a 01                	push   $0x1
    4e57:	53                   	push   %ebx
    4e58:	50                   	push   %eax
    4e59:	57                   	push   %edi
    4e5a:	56                   	push   %esi
    4e5b:	e8 09 f1 ff ff       	call   3f69 <net_pkt_write>
    4e60:	83 c4 1c             	add    $0x1c,%esp
				icmp_type);
	frag = net_pkt_write_u8(pkt, frag, pos, &pos, icmp_code);
    4e63:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
    4e67:	8a 4d e4             	mov    -0x1c(%ebp),%cl
    4e6a:	6a ff                	push   $0xffffffff
    4e6c:	88 4d ec             	mov    %cl,-0x14(%ebp)
    4e6f:	8d 4d ec             	lea    -0x14(%ebp),%ecx
    4e72:	51                   	push   %ecx
    4e73:	6a 01                	push   $0x1
    4e75:	53                   	push   %ebx
    4e76:	52                   	push   %edx
    4e77:	50                   	push   %eax
    4e78:	56                   	push   %esi
    4e79:	e8 eb f0 ff ff       	call   3f69 <net_pkt_write>
    4e7e:	83 c4 1c             	add    $0x1c,%esp
	net_pkt_write_be32(pkt, frag, pos, &pos, 0);
    4e81:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
						 u16_t *pos,
						 u32_t data)
{
	u32_t value = htonl(data);

	return net_pkt_write(pkt, frag, offset, pos, sizeof(u32_t),
    4e85:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    4e88:	6a ff                	push   $0xffffffff
    4e8a:	51                   	push   %ecx
    4e8b:	6a 04                	push   $0x4
    4e8d:	53                   	push   %ebx
    4e8e:	52                   	push   %edx
    4e8f:	50                   	push   %eax
    4e90:	56                   	push   %esi
	u32_t value = htonl(data);
    4e91:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	return net_pkt_write(pkt, frag, offset, pos, sizeof(u32_t),
    4e98:	e8 cc f0 ff ff       	call   3f69 <net_pkt_write>
    4e9d:	83 c4 1c             	add    $0x1c,%esp
}
    4ea0:	8d 65 f4             	lea    -0xc(%ebp),%esp
    4ea3:	5b                   	pop    %ebx
    4ea4:	5e                   	pop    %esi
    4ea5:	5f                   	pop    %edi
    4ea6:	5d                   	pop    %ebp
    4ea7:	c3                   	ret    

00004ea8 <net_icmpv4_set_hdr>:
{
    4ea8:	55                   	push   %ebp
    4ea9:	89 e5                	mov    %esp,%ebp
    4eab:	57                   	push   %edi
    4eac:	56                   	push   %esi
    4ead:	53                   	push   %ebx
    4eae:	50                   	push   %eax
    4eaf:	8b 5d 08             	mov    0x8(%ebp),%ebx
    4eb2:	8b 75 0c             	mov    0xc(%ebp),%esi
	icmp_hdr = net_pkt_icmp_data(pkt);
    4eb5:	53                   	push   %ebx
    4eb6:	e8 5d f2 ff ff       	call   4118 <net_pkt_icmp_data>
 */
static inline
struct net_icmp_hdr *net_icmp_header_fits(struct net_pkt *pkt,
					  struct net_icmp_hdr *hdr)
{
	if (net_header_fits(pkt, (u8_t *)hdr, sizeof(*hdr))) {
    4ebb:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
    4ec2:	89 c7                	mov    %eax,%edi
    4ec4:	50                   	push   %eax
    4ec5:	53                   	push   %ebx
    4ec6:	e8 08 f6 ff ff       	call   44d3 <net_header_fits>
    4ecb:	83 c4 0c             	add    $0xc,%esp
	if (net_icmp_header_fits(pkt, icmp_hdr)) {
    4ece:	85 ff                	test   %edi,%edi
    4ed0:	74 04                	je     4ed6 <net_icmpv4_set_hdr+0x2e>
    4ed2:	84 c0                	test   %al,%al
    4ed4:	75 64                	jne    4f3a <net_icmpv4_set_hdr+0x92>
    4ed6:	8a 0e                	mov    (%esi),%cl
	frag = net_pkt_write_u8(pkt, pkt->frags,
    4ed8:	8b 43 08             	mov    0x8(%ebx),%eax
    4edb:	0f b6 53 33          	movzbl 0x33(%ebx),%edx
	return net_pkt_write(pkt, frag, offset, pos, sizeof(u8_t),
    4edf:	8d 7d f2             	lea    -0xe(%ebp),%edi
    4ee2:	88 4d f1             	mov    %cl,-0xf(%ebp)
    4ee5:	8d 4d f1             	lea    -0xf(%ebp),%ecx
    4ee8:	6a ff                	push   $0xffffffff
    4eea:	51                   	push   %ecx
    4eeb:	6a 01                	push   $0x1
    4eed:	57                   	push   %edi
    4eee:	52                   	push   %edx
    4eef:	50                   	push   %eax
    4ef0:	53                   	push   %ebx
    4ef1:	e8 73 f0 ff ff       	call   3f69 <net_pkt_write>
    4ef6:	83 c4 1c             	add    $0x1c,%esp
    4ef9:	8a 56 01             	mov    0x1(%esi),%dl
    4efc:	6a ff                	push   $0xffffffff
	frag = net_pkt_write_u8(pkt, frag, pos, &pos, hdr->code);
    4efe:	0f b7 4d f2          	movzwl -0xe(%ebp),%ecx
    4f02:	88 55 f0             	mov    %dl,-0x10(%ebp)
    4f05:	8d 55 f0             	lea    -0x10(%ebp),%edx
    4f08:	52                   	push   %edx
    4f09:	6a 01                	push   $0x1
    4f0b:	57                   	push   %edi
    4f0c:	51                   	push   %ecx
    4f0d:	50                   	push   %eax
    4f0e:	53                   	push   %ebx
    4f0f:	e8 55 f0 ff ff       	call   3f69 <net_pkt_write>
    4f14:	83 c4 1c             	add    $0x1c,%esp
			     (u8_t *)&hdr->chksum, PKT_WAIT_TIME);
    4f17:	8d 56 02             	lea    0x2(%esi),%edx
	frag = net_pkt_write(pkt, frag, pos, &pos, sizeof(hdr->chksum),
    4f1a:	68 e8 03 00 00       	push   $0x3e8
    4f1f:	52                   	push   %edx
    4f20:	6a 02                	push   $0x2
    4f22:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
    4f26:	57                   	push   %edi
    4f27:	52                   	push   %edx
    4f28:	50                   	push   %eax
    4f29:	53                   	push   %ebx
    4f2a:	e8 3a f0 ff ff       	call   3f69 <net_pkt_write>
    4f2f:	83 c4 1c             	add    $0x1c,%esp
	if (!frag) {
    4f32:	85 c0                	test   %eax,%eax
    4f34:	75 02                	jne    4f38 <net_icmpv4_set_hdr+0x90>
		return NULL;
    4f36:	31 f6                	xor    %esi,%esi
    4f38:	89 f7                	mov    %esi,%edi
}
    4f3a:	8d 65 f4             	lea    -0xc(%ebp),%esp
    4f3d:	89 f8                	mov    %edi,%eax
    4f3f:	5b                   	pop    %ebx
    4f40:	5e                   	pop    %esi
    4f41:	5f                   	pop    %edi
    4f42:	5d                   	pop    %ebp
    4f43:	c3                   	ret    

00004f44 <net_icmpv4_get_hdr>:
{
    4f44:	55                   	push   %ebp
    4f45:	89 e5                	mov    %esp,%ebp
    4f47:	57                   	push   %edi
    4f48:	56                   	push   %esi
    4f49:	53                   	push   %ebx
    4f4a:	50                   	push   %eax
    4f4b:	8b 7d 08             	mov    0x8(%ebp),%edi
    4f4e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	icmp_hdr = net_pkt_icmp_data(pkt);
    4f51:	57                   	push   %edi
    4f52:	e8 c1 f1 ff ff       	call   4118 <net_pkt_icmp_data>
    4f57:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
    4f5e:	89 c6                	mov    %eax,%esi
    4f60:	50                   	push   %eax
    4f61:	57                   	push   %edi
    4f62:	e8 6c f5 ff ff       	call   44d3 <net_header_fits>
    4f67:	83 c4 0c             	add    $0xc,%esp
	if (net_icmp_header_fits(pkt, icmp_hdr)) {
    4f6a:	85 f6                	test   %esi,%esi
    4f6c:	74 04                	je     4f72 <net_icmpv4_get_hdr+0x2e>
    4f6e:	84 c0                	test   %al,%al
    4f70:	75 49                	jne    4fbb <net_icmpv4_get_hdr+0x77>
	return net_frag_read(frag, offset, pos, 1, value);
    4f72:	8d 75 f2             	lea    -0xe(%ebp),%esi
    4f75:	53                   	push   %ebx
    4f76:	6a 01                	push   $0x1
    4f78:	56                   	push   %esi
	frag = net_frag_read_u8(pkt->frags, net_pkt_ip_hdr_len(pkt), &pos,
    4f79:	0f b6 47 33          	movzbl 0x33(%edi),%eax
    4f7d:	50                   	push   %eax
    4f7e:	ff 77 08             	pushl  0x8(%edi)
    4f81:	e8 38 ef ff ff       	call   3ebe <net_frag_read>
    4f86:	83 c4 14             	add    $0x14,%esp
	frag = net_frag_read_u8(frag, pos, &pos, &hdr->code);
    4f89:	8d 53 01             	lea    0x1(%ebx),%edx
    4f8c:	52                   	push   %edx
    4f8d:	6a 01                	push   $0x1
    4f8f:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
    4f93:	56                   	push   %esi
    4f94:	52                   	push   %edx
    4f95:	50                   	push   %eax
    4f96:	e8 23 ef ff ff       	call   3ebe <net_frag_read>
    4f9b:	83 c4 14             	add    $0x14,%esp
			     (u8_t *)&hdr->chksum);
    4f9e:	8d 53 02             	lea    0x2(%ebx),%edx
	frag = net_frag_read(frag, pos, &pos, sizeof(hdr->chksum),
    4fa1:	52                   	push   %edx
    4fa2:	6a 02                	push   $0x2
    4fa4:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
    4fa8:	56                   	push   %esi
    4fa9:	52                   	push   %edx
    4faa:	50                   	push   %eax
    4fab:	e8 0e ef ff ff       	call   3ebe <net_frag_read>
    4fb0:	83 c4 14             	add    $0x14,%esp
	if (!frag) {
    4fb3:	85 c0                	test   %eax,%eax
    4fb5:	75 02                	jne    4fb9 <net_icmpv4_get_hdr+0x75>
		return NULL;
    4fb7:	31 db                	xor    %ebx,%ebx
    4fb9:	89 de                	mov    %ebx,%esi
}
    4fbb:	8d 65 f4             	lea    -0xc(%ebp),%esp
    4fbe:	89 f0                	mov    %esi,%eax
    4fc0:	5b                   	pop    %ebx
    4fc1:	5e                   	pop    %esi
    4fc2:	5f                   	pop    %edi
    4fc3:	5d                   	pop    %ebp
    4fc4:	c3                   	ret    

00004fc5 <net_icmpv4_set_chksum>:
{
    4fc5:	55                   	push   %ebp
    4fc6:	89 e5                	mov    %esp,%ebp
    4fc8:	57                   	push   %edi
    4fc9:	56                   	push   %esi
    4fca:	53                   	push   %ebx
    4fcb:	83 ec 08             	sub    $0x8,%esp
	u16_t chksum = 0;
    4fce:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)
{
    4fd4:	8b 5d 08             	mov    0x8(%ebp),%ebx
    4fd7:	8b 7d 0c             	mov    0xc(%ebp),%edi
	icmp_hdr = net_pkt_icmp_data(pkt);
    4fda:	53                   	push   %ebx
    4fdb:	e8 38 f1 ff ff       	call   4118 <net_pkt_icmp_data>
    4fe0:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
    4fe7:	89 c6                	mov    %eax,%esi
    4fe9:	50                   	push   %eax
    4fea:	53                   	push   %ebx
    4feb:	e8 e3 f4 ff ff       	call   44d3 <net_header_fits>
    4ff0:	83 c4 0c             	add    $0xc,%esp
	if (net_icmp_header_fits(pkt, icmp_hdr)) {
    4ff3:	85 f6                	test   %esi,%esi
    4ff5:	74 1c                	je     5013 <net_icmpv4_set_chksum+0x4e>
    4ff7:	84 c0                	test   %al,%al
    4ff9:	74 18                	je     5013 <net_icmpv4_set_chksum+0x4e>
		icmp_hdr->chksum = 0;
    4ffb:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
	return net_calc_chksum(pkt, IPPROTO_ICMPV6);
}

static inline u16_t net_calc_chksum_icmpv4(struct net_pkt *pkt)
{
	return net_calc_chksum(pkt, IPPROTO_ICMP);
    5001:	6a 01                	push   $0x1
    5003:	53                   	push   %ebx
    5004:	e8 c4 f3 ff ff       	call   43cd <net_calc_chksum>
		icmp_hdr->chksum = ~net_calc_chksum_icmpv4(pkt);
    5009:	f7 d0                	not    %eax
    500b:	5b                   	pop    %ebx
    500c:	5a                   	pop    %edx
    500d:	66 89 46 02          	mov    %ax,0x2(%esi)
		return frag;
    5011:	eb 59                	jmp    506c <net_icmpv4_set_chksum+0xa7>
	frag = net_pkt_write(pkt, frag,
    5013:	8d 55 f0             	lea    -0x10(%ebp),%edx
    5016:	8d 75 f2             	lea    -0xe(%ebp),%esi
    5019:	68 e8 03 00 00       	push   $0x3e8
    501e:	52                   	push   %edx
    501f:	6a 02                	push   $0x2
    5021:	56                   	push   %esi
			     1 + 1 /* type + code */, &pos,
    5022:	0f b6 43 33          	movzbl 0x33(%ebx),%eax
	frag = net_pkt_write(pkt, frag,
    5026:	83 c0 02             	add    $0x2,%eax
    5029:	89 55 ec             	mov    %edx,-0x14(%ebp)
    502c:	50                   	push   %eax
    502d:	57                   	push   %edi
    502e:	53                   	push   %ebx
    502f:	e8 35 ef ff ff       	call   3f69 <net_pkt_write>
    5034:	83 c4 1c             	add    $0x1c,%esp
    5037:	89 c7                	mov    %eax,%edi
    5039:	6a 01                	push   $0x1
    503b:	53                   	push   %ebx
    503c:	e8 8c f3 ff ff       	call   43cd <net_calc_chksum>
    5041:	5a                   	pop    %edx
	chksum = ~net_calc_chksum_icmpv4(pkt);
    5042:	f7 d0                	not    %eax
    5044:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
	frag = net_pkt_write(pkt, frag, pos - 2, &pos, sizeof(chksum),
    5048:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
    504c:	83 e8 02             	sub    $0x2,%eax
    504f:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5052:	0f b7 c0             	movzwl %ax,%eax
    5055:	59                   	pop    %ecx
    5056:	68 e8 03 00 00       	push   $0x3e8
    505b:	52                   	push   %edx
    505c:	6a 02                	push   $0x2
    505e:	56                   	push   %esi
    505f:	50                   	push   %eax
    5060:	57                   	push   %edi
    5061:	53                   	push   %ebx
    5062:	e8 02 ef ff ff       	call   3f69 <net_pkt_write>
    5067:	83 c4 1c             	add    $0x1c,%esp
    506a:	89 c7                	mov    %eax,%edi
}
    506c:	8d 65 f4             	lea    -0xc(%ebp),%esp
    506f:	89 f8                	mov    %edi,%eax
    5071:	5b                   	pop    %ebx
    5072:	5e                   	pop    %esi
    5073:	5f                   	pop    %edi
    5074:	5d                   	pop    %ebp
    5075:	c3                   	ret    

00005076 <handle_echo_request>:
{
    5076:	55                   	push   %ebp
    5077:	89 e5                	mov    %esp,%ebp
    5079:	53                   	push   %ebx
    507a:	50                   	push   %eax
    507b:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return pkt->frags->data;
    507e:	8b 43 08             	mov    0x8(%ebx),%eax
    5081:	8b 40 08             	mov    0x8(%eax),%eax
	net_ipaddr_copy(&addr, &NET_IPV4_HDR(pkt)->src);
    5084:	8b 50 0c             	mov    0xc(%eax),%edx
	net_ipaddr_copy(&NET_IPV4_HDR(pkt)->src,
    5087:	8b 48 10             	mov    0x10(%eax),%ecx
    508a:	89 48 0c             	mov    %ecx,0xc(%eax)
	net_ipaddr_copy(&NET_IPV4_HDR(pkt)->dst, &addr);
    508d:	89 50 10             	mov    %edx,0x10(%eax)
	icmp_hdr = net_icmpv4_get_hdr(pkt, &hdr);
    5090:	8d 45 f8             	lea    -0x8(%ebp),%eax
    5093:	50                   	push   %eax
    5094:	53                   	push   %ebx
    5095:	e8 aa fe ff ff       	call   4f44 <net_icmpv4_get_hdr>
    509a:	5a                   	pop    %edx
    509b:	59                   	pop    %ecx
	icmp_hdr->type = NET_ICMPV4_ECHO_REPLY;
    509c:	c6 00 00             	movb   $0x0,(%eax)
	icmp_hdr->code = 0;
    509f:	c6 40 01 00          	movb   $0x0,0x1(%eax)
	icmp_hdr->chksum = 0;
    50a3:	66 c7 40 02 00 00    	movw   $0x0,0x2(%eax)
	net_icmpv4_set_hdr(pkt, icmp_hdr);
    50a9:	50                   	push   %eax
    50aa:	53                   	push   %ebx
    50ab:	e8 f8 fd ff ff       	call   4ea8 <net_icmpv4_set_hdr>
    50b0:	58                   	pop    %eax
    50b1:	5a                   	pop    %edx
	net_icmpv4_set_chksum(pkt, pkt->frags);
    50b2:	ff 73 08             	pushl  0x8(%ebx)
    50b5:	53                   	push   %ebx
    50b6:	e8 0a ff ff ff       	call   4fc5 <net_icmpv4_set_chksum>
    50bb:	59                   	pop    %ecx
    50bc:	58                   	pop    %eax
	if (net_send_data(pkt) < 0) {
    50bd:	53                   	push   %ebx
    50be:	e8 27 e5 ff ff       	call   35ea <net_send_data>
	return NET_OK;
    50c3:	c1 e8 1f             	shr    $0x1f,%eax
	if (net_send_data(pkt) < 0) {
    50c6:	5a                   	pop    %edx
	return NET_OK;
    50c7:	01 c0                	add    %eax,%eax
}
    50c9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    50cc:	c9                   	leave  
    50cd:	c3                   	ret    

000050ce <net_icmpv4_send_error>:

	return -EIO;
}

int net_icmpv4_send_error(struct net_pkt *orig, u8_t type, u8_t code)
{
    50ce:	55                   	push   %ebp
    50cf:	89 e5                	mov    %esp,%ebp
    50d1:	57                   	push   %edi
    50d2:	56                   	push   %esi
    50d3:	53                   	push   %ebx
    50d4:	83 ec 18             	sub    $0x18,%esp
    50d7:	8b 45 0c             	mov    0xc(%ebp),%eax
    50da:	8b 75 08             	mov    0x8(%ebp),%esi
    50dd:	89 45 e8             	mov    %eax,-0x18(%ebp)
    50e0:	8b 45 10             	mov    0x10(%ebp),%eax
    50e3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    50e6:	8b 46 08             	mov    0x8(%esi),%eax
	struct net_if *iface = net_pkt_iface(orig);
	size_t extra_len, reserve;
	struct in_addr addr, *src, *dst;
	int err = -EIO;

	if (NET_IPV4_HDR(orig)->proto == IPPROTO_ICMP) {
    50e9:	8b 40 08             	mov    0x8(%eax),%eax
    50ec:	80 78 09 01          	cmpb   $0x1,0x9(%eax)
    50f0:	75 20                	jne    5112 <net_icmpv4_send_error+0x44>
		struct net_icmp_hdr icmp_hdr[1];

		if (!net_icmpv4_get_hdr(orig, icmp_hdr) ||
    50f2:	8d 45 f0             	lea    -0x10(%ebp),%eax
    50f5:	50                   	push   %eax
    50f6:	56                   	push   %esi
    50f7:	e8 48 fe ff ff       	call   4f44 <net_icmpv4_get_hdr>
    50fc:	59                   	pop    %ecx
    50fd:	85 c0                	test   %eax,%eax
    50ff:	5b                   	pop    %ebx
    5100:	74 06                	je     5108 <net_icmpv4_send_error+0x3a>
    5102:	80 7d f1 07          	cmpb   $0x7,-0xf(%ebp)
    5106:	77 0a                	ja     5112 <net_icmpv4_send_error+0x44>
		    icmp_hdr->code < 8) {
			/* We must not send ICMP errors back */
			err = -EINVAL;
    5108:	ba ea ff ff ff       	mov    $0xffffffea,%edx
    510d:	e9 30 01 00 00       	jmp    5242 <__data_size+0x4a>
    5112:	8b 7e 14             	mov    0x14(%esi),%edi
		}
	}

	iface = net_pkt_iface(orig);

	pkt = net_pkt_get_reserve_tx(0, PKT_WAIT_TIME);
    5115:	68 e8 03 00 00       	push   $0x3e8
    511a:	6a 00                	push   $0x0
    511c:	e8 20 ea ff ff       	call   3b41 <net_pkt_get_reserve_tx>
    5121:	5b                   	pop    %ebx
	if (!pkt) {
    5122:	85 c0                	test   %eax,%eax
	pkt = net_pkt_get_reserve_tx(0, PKT_WAIT_TIME);
    5124:	5a                   	pop    %edx
    5125:	89 c3                	mov    %eax,%ebx
		err = -ENOMEM;
    5127:	ba f4 ff ff ff       	mov    $0xfffffff4,%edx
	if (!pkt) {
    512c:	0f 84 10 01 00 00    	je     5242 <__data_size+0x4a>
    5132:	8b 46 08             	mov    0x8(%esi),%eax

	reserve = sizeof(struct net_ipv4_hdr) + sizeof(struct net_icmp_hdr) +
		NET_ICMPV4_UNUSED_LEN;

	if (NET_IPV4_HDR(orig)->proto == IPPROTO_UDP) {
		extra_len = sizeof(struct net_ipv4_hdr) +
    5135:	ba 1c 00 00 00       	mov    $0x1c,%edx
	if (NET_IPV4_HDR(orig)->proto == IPPROTO_UDP) {
    513a:	8b 40 08             	mov    0x8(%eax),%eax
    513d:	8a 40 09             	mov    0x9(%eax),%al
    5140:	3c 11                	cmp    $0x11,%al
    5142:	74 28                	je     516c <net_icmpv4_send_error+0x9e>
			sizeof(struct net_udp_hdr);
	} else if (NET_IPV4_HDR(orig)->proto == IPPROTO_TCP) {
		extra_len = sizeof(struct net_ipv4_hdr);
    5144:	ba 14 00 00 00       	mov    $0x14,%edx
	} else if (NET_IPV4_HDR(orig)->proto == IPPROTO_TCP) {
    5149:	3c 06                	cmp    $0x6,%al
    514b:	74 1f                	je     516c <net_icmpv4_send_error+0x9e>
	return iface->l2->reserve(iface, (void *)dst_ip6);
    514d:	8b 47 04             	mov    0x4(%edi),%eax
    5150:	6a 00                	push   $0x0
    5152:	57                   	push   %edi
    5153:	ff 50 08             	call   *0x8(%eax)
    5156:	5a                   	pop    %edx
		/* FIXME, add TCP header length too */
	} else {
		size_t space = CONFIG_NET_BUF_DATA_SIZE -
			net_if_get_ll_reserve(iface, NULL);
    5157:	0f b7 d0             	movzwl %ax,%edx
		size_t space = CONFIG_NET_BUF_DATA_SIZE -
    515a:	b8 80 00 00 00       	mov    $0x80,%eax
    515f:	59                   	pop    %ecx
    5160:	29 d0                	sub    %edx,%eax

		if (reserve > space) {
			extra_len = 0;
    5162:	31 d2                	xor    %edx,%edx
		if (reserve > space) {
    5164:	83 f8 1b             	cmp    $0x1b,%eax
    5167:	76 03                	jbe    516c <net_icmpv4_send_error+0x9e>
		} else {
			extra_len = space - reserve;
    5169:	8d 50 e4             	lea    -0x1c(%eax),%edx
    516c:	8b 46 08             	mov    0x8(%esi),%eax
	dst = &NET_IPV4_HDR(orig)->dst;

	/* We only copy minimal IPv4 + next header from original message.
	 * This is so that the memory pressure is minimized.
	 */
	frag = net_pkt_copy(orig, extra_len, reserve, PKT_WAIT_TIME);
    516f:	89 55 dc             	mov    %edx,-0x24(%ebp)
    5172:	8b 40 08             	mov    0x8(%eax),%eax
    5175:	68 e8 03 00 00       	push   $0x3e8
    517a:	89 45 ec             	mov    %eax,-0x14(%ebp)
    517d:	6a 1c                	push   $0x1c
    517f:	52                   	push   %edx
    5180:	56                   	push   %esi
    5181:	e8 3e eb ff ff       	call   3cc4 <net_pkt_copy>
    5186:	83 c4 10             	add    $0x10,%esp
	if (!frag) {
    5189:	85 c0                	test   %eax,%eax
    518b:	0f 84 9f 00 00 00    	je     5230 <__data_size+0x38>
		err = -ENOMEM;
		goto drop;
	}

	net_pkt_frag_add(pkt, frag);
    5191:	50                   	push   %eax
    5192:	89 45 e0             	mov    %eax,-0x20(%ebp)
    5195:	53                   	push   %ebx
    5196:	e8 b1 ea ff ff       	call   3c4c <net_pkt_frag_add>
    519b:	5a                   	pop    %edx
    519c:	59                   	pop    %ecx
	pkt->family = family;
    519d:	8a 4b 34             	mov    0x34(%ebx),%cl
	pkt->iface = iface;
    51a0:	89 7b 14             	mov    %edi,0x14(%ebx)
	pkt->family = family;
    51a3:	83 e1 87             	and    $0xffffff87,%ecx
	net_pkt_set_family(pkt, AF_INET);
	net_pkt_set_iface(pkt, iface);
	net_pkt_set_ll_reserve(pkt, net_buf_headroom(frag));
    51a6:	8b 45 e0             	mov    -0x20(%ebp),%eax
    51a9:	83 c9 10             	or     $0x10,%ecx
    51ac:	83 c0 08             	add    $0x8,%eax
    51af:	88 4b 34             	mov    %cl,0x34(%ebx)
	pkt->lladdr_src.type = iface->link_addr.type;
    51b2:	8a 4f 15             	mov    0x15(%edi),%cl
    51b5:	88 4b 25             	mov    %cl,0x25(%ebx)
	pkt->lladdr_dst.type = iface->link_addr.type;
    51b8:	88 4b 2d             	mov    %cl,0x2d(%ebx)
    51bb:	50                   	push   %eax
    51bc:	e8 09 e3 ff ff       	call   34ca <net_buf_simple_headroom>
    51c1:	88 43 32             	mov    %al,0x32(%ebx)

	setup_ipv4_header(pkt, extra_len, net_if_ipv4_get_ttl(iface),
    51c4:	8b 55 dc             	mov    -0x24(%ebp),%edx
    51c7:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    51cb:	0f b6 4f 7c          	movzbl 0x7c(%edi),%ecx
    51cf:	89 04 24             	mov    %eax,(%esp)
    51d2:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    51d6:	0f b6 d2             	movzbl %dl,%edx
    51d9:	50                   	push   %eax
    51da:	89 d8                	mov    %ebx,%eax
    51dc:	e8 01 fc ff ff       	call   4de2 <setup_ipv4_header>
    51e1:	5f                   	pop    %edi
    51e2:	58                   	pop    %eax
			  type, code);

	net_ipaddr_copy(&addr, src);
    51e3:	8b 45 ec             	mov    -0x14(%ebp),%eax
	net_ipaddr_copy(&NET_IPV4_HDR(pkt)->src, dst);
    51e6:	8b 7d ec             	mov    -0x14(%ebp),%edi
	net_ipaddr_copy(&addr, src);
    51e9:	8b 48 0c             	mov    0xc(%eax),%ecx
    51ec:	8b 43 08             	mov    0x8(%ebx),%eax
	net_ipaddr_copy(&NET_IPV4_HDR(pkt)->src, dst);
    51ef:	8b 7f 10             	mov    0x10(%edi),%edi
	return pkt->frags->data;
    51f2:	8b 50 08             	mov    0x8(%eax),%edx
	net_ipaddr_copy(&NET_IPV4_HDR(pkt)->dst, &addr);
    51f5:	89 4a 10             	mov    %ecx,0x10(%edx)
	net_ipaddr_copy(&NET_IPV4_HDR(pkt)->src, dst);
    51f8:	89 7a 0c             	mov    %edi,0xc(%edx)

	net_pkt_ll_src(pkt)->addr = net_pkt_ll_dst(orig)->addr;
    51fb:	8b 56 28             	mov    0x28(%esi),%edx
    51fe:	89 53 20             	mov    %edx,0x20(%ebx)
	net_pkt_ll_src(pkt)->len = net_pkt_ll_dst(orig)->len;
    5201:	8a 56 2c             	mov    0x2c(%esi),%dl
    5204:	88 53 24             	mov    %dl,0x24(%ebx)
	net_pkt_ll_dst(pkt)->addr = net_pkt_ll_src(orig)->addr;
    5207:	8b 56 20             	mov    0x20(%esi),%edx
    520a:	89 53 28             	mov    %edx,0x28(%ebx)
	net_pkt_ll_dst(pkt)->len = net_pkt_ll_src(orig)->len;
    520d:	8a 56 24             	mov    0x24(%esi),%dl
    5210:	88 53 2c             	mov    %dl,0x2c(%ebx)

	net_icmpv4_set_chksum(pkt, pkt->frags);
    5213:	50                   	push   %eax
    5214:	53                   	push   %ebx
    5215:	e8 ab fd ff ff       	call   4fc5 <net_icmpv4_set_chksum>
    521a:	58                   	pop    %eax
    521b:	5a                   	pop    %edx
			"from %s to %s", type, code,
			net_sprint_ipv4_addr(&NET_IPV4_HDR(pkt)->src), out);
	} while (0);
#endif /* CONFIG_NET_DEBUG_ICMPV4 */

	if (net_send_data(pkt) >= 0) {
    521c:	53                   	push   %ebx
    521d:	e8 c8 e3 ff ff       	call   35ea <net_send_data>
		net_stats_update_icmp_sent();
		return 0;
    5222:	31 d2                	xor    %edx,%edx
	if (net_send_data(pkt) >= 0) {
    5224:	59                   	pop    %ecx
    5225:	85 c0                	test   %eax,%eax
    5227:	79 19                	jns    5242 <__data_size+0x4a>
	int err = -EIO;
    5229:	ba fb ff ff ff       	mov    $0xfffffffb,%edx
    522e:	eb 05                	jmp    5235 <__data_size+0x3d>
		err = -ENOMEM;
    5230:	ba f4 ff ff ff       	mov    $0xfffffff4,%edx
    5235:	89 55 ec             	mov    %edx,-0x14(%ebp)
	}

drop:
	net_pkt_unref(pkt);
    5238:	53                   	push   %ebx
    5239:	e8 9d e9 ff ff       	call   3bdb <net_pkt_unref>
    523e:	58                   	pop    %eax
    523f:	8b 55 ec             	mov    -0x14(%ebp),%edx

drop_no_pkt:
	net_stats_update_icmp_drop();

	return err;
}
    5242:	8d 65 f4             	lea    -0xc(%ebp),%esp
    5245:	89 d0                	mov    %edx,%eax
    5247:	5b                   	pop    %ebx
    5248:	5e                   	pop    %esi
    5249:	5f                   	pop    %edi
    524a:	5d                   	pop    %ebp
    524b:	c3                   	ret    

0000524c <net_icmpv4_register_handler>:

void net_icmpv4_register_handler(struct net_icmpv4_handler *handler)
{
    524c:	55                   	push   %ebp
 * @param node A pointer on the node to prepend
 */
static inline void sys_slist_prepend(sys_slist_t *list,
				     sys_snode_t *node)
{
	node->next = list->head;
    524d:	8b 15 30 53 40 00    	mov    0x405330,%edx
    5253:	89 e5                	mov    %esp,%ebp
	list->head = node;

	if (!list->tail) {
    5255:	83 3d 34 53 40 00 00 	cmpl   $0x0,0x405334
    525c:	8b 45 08             	mov    0x8(%ebp),%eax
	node->next = list->head;
    525f:	89 10                	mov    %edx,(%eax)
	list->head = node;
    5261:	a3 30 53 40 00       	mov    %eax,0x405330
	if (!list->tail) {
    5266:	75 05                	jne    526d <net_icmpv4_register_handler+0x21>
		list->tail = list->head;
    5268:	a3 34 53 40 00       	mov    %eax,0x405334
	sys_slist_prepend(&handlers, &handler->node);
}
    526d:	5d                   	pop    %ebp
    526e:	c3                   	ret    

0000526f <net_icmpv4_input>:
	sys_slist_find_and_remove(&handlers, &handler->node);
}

enum net_verdict net_icmpv4_input(struct net_pkt *pkt,
				  u8_t type, u8_t code)
{
    526f:	55                   	push   %ebp
    5270:	89 e5                	mov    %esp,%ebp
    5272:	53                   	push   %ebx
    5273:	53                   	push   %ebx
    5274:	8a 45 10             	mov    0x10(%ebp),%al
    5277:	8b 5d 08             	mov    0x8(%ebp),%ebx
    527a:	8a 4d 0c             	mov    0xc(%ebp),%cl
    527d:	88 45 fb             	mov    %al,-0x5(%ebp)
    5280:	8b 15 30 53 40 00    	mov    0x405330,%edx
    5286:	89 d0                	mov    %edx,%eax
	struct net_icmpv4_handler *cb;

	net_stats_update_icmp_recv();

	SYS_SLIST_FOR_EACH_CONTAINER(&handlers, cb, node) {
    5288:	85 d2                	test   %edx,%edx
    528a:	74 22                	je     52ae <net_icmpv4_input+0x3f>
		if (cb->type == type && (cb->code == code || cb->code == 0)) {
    528c:	38 4a 04             	cmp    %cl,0x4(%edx)
    528f:	75 17                	jne    52a8 <net_icmpv4_input+0x39>
    5291:	8a 50 05             	mov    0x5(%eax),%dl
    5294:	3a 55 fb             	cmp    -0x5(%ebp),%dl
    5297:	74 04                	je     529d <net_icmpv4_input+0x2e>
    5299:	84 d2                	test   %dl,%dl
    529b:	75 0b                	jne    52a8 <net_icmpv4_input+0x39>
			return cb->handler(pkt);
    529d:	89 5d 08             	mov    %ebx,0x8(%ebp)
    52a0:	8b 40 08             	mov    0x8(%eax),%eax
	}

	net_stats_update_icmp_drop();

	return NET_DROP;
}
    52a3:	59                   	pop    %ecx
    52a4:	5b                   	pop    %ebx
    52a5:	5d                   	pop    %ebp
			return cb->handler(pkt);
    52a6:	ff e0                	jmp    *%eax
	return node->next;
    52a8:	8b 10                	mov    (%eax),%edx
	SYS_SLIST_FOR_EACH_CONTAINER(&handlers, cb, node) {
    52aa:	85 d2                	test   %edx,%edx
    52ac:	75 d8                	jne    5286 <net_icmpv4_input+0x17>
}
    52ae:	5a                   	pop    %edx
    52af:	b8 02 00 00 00       	mov    $0x2,%eax
    52b4:	5b                   	pop    %ebx
    52b5:	5d                   	pop    %ebp
    52b6:	c3                   	ret    

000052b7 <net_icmpv4_init>:
	.code = 0,
	.handler = handle_echo_request,
};

void net_icmpv4_init(void)
{
    52b7:	55                   	push   %ebp
    52b8:	89 e5                	mov    %esp,%ebp
	net_icmpv4_register_handler(&echo_request_handler);
    52ba:	68 f8 00 40 00       	push   $0x4000f8
    52bf:	e8 88 ff ff ff       	call   524c <net_icmpv4_register_handler>
    52c4:	58                   	pop    %eax
}
    52c5:	c9                   	leave  
    52c6:	c3                   	ret    

000052c7 <net_ipv4_unspecified_address>:
	return net_ipv4_finalize_raw(pkt,
				     net_context_get_ip_proto(context));
}

const struct in_addr *net_ipv4_unspecified_address(void)
{
    52c7:	55                   	push   %ebp
	static const struct in_addr addr;

	return &addr;
}
    52c8:	b8 38 53 40 00       	mov    $0x405338,%eax
{
    52cd:	89 e5                	mov    %esp,%ebp
}
    52cf:	5d                   	pop    %ebp
    52d0:	c3                   	ret    

000052d1 <net_ipv4_broadcast_address>:

const struct in_addr *net_ipv4_broadcast_address(void)
{
    52d1:	55                   	push   %ebp
	static const struct in_addr addr = { { { 255, 255, 255, 255 } } };

	return &addr;
}
    52d2:	b8 7c 77 00 00       	mov    $0x777c,%eax
{
    52d7:	89 e5                	mov    %esp,%ebp
}
    52d9:	5d                   	pop    %ebp
    52da:	c3                   	ret    

000052db <net_ipv4_process_pkt>:

	return net_icmpv4_input(pkt, icmp_hdr->type, icmp_hdr->code);
}

enum net_verdict net_ipv4_process_pkt(struct net_pkt *pkt)
{
    52db:	55                   	push   %ebp
	size_t bytes = 0;
    52dc:	31 d2                	xor    %edx,%edx
    52de:	89 e5                	mov    %esp,%ebp
    52e0:	56                   	push   %esi
    52e1:	53                   	push   %ebx
    52e2:	51                   	push   %ecx
    52e3:	8b 5d 08             	mov    0x8(%ebp),%ebx
    52e6:	8b 43 08             	mov    0x8(%ebx),%eax
    52e9:	8b 70 08             	mov    0x8(%eax),%esi
		bytes += buf->len;
    52ec:	0f b7 48 0c          	movzwl 0xc(%eax),%ecx
		buf = buf->frags;
    52f0:	8b 00                	mov    (%eax),%eax
		bytes += buf->len;
    52f2:	01 ca                	add    %ecx,%edx
	while (buf) {
    52f4:	85 c0                	test   %eax,%eax
    52f6:	75 f4                	jne    52ec <net_ipv4_process_pkt+0x11>
	struct net_ipv4_hdr *hdr = NET_IPV4_HDR(pkt);
	int real_len = net_pkt_get_len(pkt);
	int pkt_len = (hdr->len[0] << 8) + hdr->len[1];
    52f8:	0f b6 46 02          	movzbl 0x2(%esi),%eax
    52fc:	0f b6 4e 03          	movzbl 0x3(%esi),%ecx
    5300:	c1 e0 08             	shl    $0x8,%eax
    5303:	01 c8                	add    %ecx,%eax
	enum net_verdict verdict = NET_DROP;

	if (real_len != pkt_len) {
    5305:	39 c2                	cmp    %eax,%edx
    5307:	75 55                	jne    535e <net_ipv4_process_pkt+0x83>
	pkt->ip_hdr_len = len;
    5309:	c6 43 33 14          	movb   $0x14,0x33(%ebx)
	} while (0);
#endif /* CONFIG_NET_DEBUG_IPV4 */

	net_pkt_set_ip_hdr_len(pkt, sizeof(struct net_ipv4_hdr));

	if (!net_is_my_ipv4_addr(&hdr->dst)) {
    530d:	8d 46 10             	lea    0x10(%esi),%eax
    5310:	6a 00                	push   $0x0
    5312:	50                   	push   %eax
    5313:	e8 17 e4 ff ff       	call   372f <net_if_ipv4_addr_lookup>
    5318:	59                   	pop    %ecx
    5319:	85 c0                	test   %eax,%eax
    531b:	5a                   	pop    %edx
    531c:	74 40                	je     535e <net_ipv4_process_pkt+0x83>
#endif
		NET_DBG("IPv4 packet in pkt %p not for me", pkt);
		goto drop;
	}

	switch (hdr->proto) {
    531e:	8a 46 09             	mov    0x9(%esi),%al
    5321:	3c 06                	cmp    $0x6,%al
    5323:	74 2d                	je     5352 <net_ipv4_process_pkt+0x77>
    5325:	3c 11                	cmp    $0x11,%al
    5327:	74 24                	je     534d <net_ipv4_process_pkt+0x72>
    5329:	fe c8                	dec    %al
    532b:	75 31                	jne    535e <net_ipv4_process_pkt+0x83>
	icmp_hdr = net_icmpv4_get_hdr(pkt, &hdr);
    532d:	8d 45 f4             	lea    -0xc(%ebp),%eax
    5330:	50                   	push   %eax
    5331:	53                   	push   %ebx
    5332:	e8 0d fc ff ff       	call   4f44 <net_icmpv4_get_hdr>
    5337:	5e                   	pop    %esi
    5338:	5a                   	pop    %edx
	return net_icmpv4_input(pkt, icmp_hdr->type, icmp_hdr->code);
    5339:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    533d:	52                   	push   %edx
    533e:	0f b6 00             	movzbl (%eax),%eax
    5341:	50                   	push   %eax
    5342:	53                   	push   %ebx
    5343:	e8 27 ff ff ff       	call   526f <net_icmpv4_input>
    5348:	83 c4 0c             	add    $0xc,%esp
	case IPPROTO_ICMP:
		verdict = process_icmpv4_pkt(pkt, hdr);
		break;
    534b:	eb 16                	jmp    5363 <net_ipv4_process_pkt+0x88>
	case IPPROTO_UDP:
		verdict = net_conn_input(IPPROTO_UDP, pkt);
    534d:	53                   	push   %ebx
    534e:	6a 11                	push   $0x11
    5350:	eb 03                	jmp    5355 <net_ipv4_process_pkt+0x7a>
		break;
	case IPPROTO_TCP:
		verdict = net_conn_input(IPPROTO_TCP, pkt);
    5352:	53                   	push   %ebx
    5353:	6a 06                	push   $0x6
    5355:	e8 3e 04 00 00       	call   5798 <net_conn_input>
    535a:	5a                   	pop    %edx
    535b:	59                   	pop    %ecx
		break;
    535c:	eb 05                	jmp    5363 <net_ipv4_process_pkt+0x88>
		return verdict;
	}

drop:
	net_stats_update_ipv4_drop();
	return NET_DROP;
    535e:	b8 02 00 00 00       	mov    $0x2,%eax
}
    5363:	8d 65 f8             	lea    -0x8(%ebp),%esp
    5366:	5b                   	pop    %ebx
    5367:	5e                   	pop    %esi
    5368:	5d                   	pop    %ebp
    5369:	c3                   	ret    

0000536a <mgmt_thread>:
			  K_THREAD_STACK_SIZEOF(mgmt_stack));
#endif
}

static void mgmt_thread(void)
{
    536a:	55                   	push   %ebp
    536b:	89 e5                	mov    %esp,%ebp
    536d:	57                   	push   %edi
    536e:	56                   	push   %esi
    536f:	53                   	push   %ebx
    5370:	53                   	push   %ebx
	struct mgmt_event_entry *mgmt_event;

	while (1) {
		k_sem_take(&network_event, K_FOREVER);
    5371:	6a ff                	push   $0xffffffff
    5373:	68 d4 50 40 00       	push   $0x4050d4
    5378:	e8 c6 1a 00 00       	call   6e43 <k_sem_take>
    537d:	5a                   	pop    %edx
	if (!events[out_event].event) {
    537e:	0f b7 35 3c 53 40 00 	movzwl 0x40533c,%esi
		k_sem_take(&network_event, K_FOREVER);
    5385:	59                   	pop    %ecx
	if (!events[out_event].event) {
    5386:	83 3c f5 4c 53 40 00 	cmpl   $0x0,0x40534c(,%esi,8)
    538d:	00 
    538e:	74 41                	je     53d1 <mgmt_thread+0x67>
    5390:	89 f0                	mov    %esi,%eax
	out_event++;
    5392:	40                   	inc    %eax
	if (out_event == CONFIG_NET_MGMT_EVENT_QUEUE_SIZE) {
    5393:	66 83 f8 02          	cmp    $0x2,%ax
    5397:	74 08                	je     53a1 <mgmt_thread+0x37>
	out_event++;
    5399:	66 a3 3c 53 40 00    	mov    %ax,0x40533c
    539f:	eb 09                	jmp    53aa <mgmt_thread+0x40>
		out_event = 0;
    53a1:	66 c7 05 3c 53 40 00 	movw   $0x0,0x40533c
    53a8:	00 00 
    53aa:	8b 1d 40 53 40 00    	mov    0x405340,%ebx
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&event_callbacks, cb, tmp, node) {
    53b0:	85 db                	test   %ebx,%ebx
    53b2:	75 30                	jne    53e4 <mgmt_thread+0x7a>
	mgmt_event->event = 0;
    53b4:	c7 04 f5 4c 53 40 00 	movl   $0x0,0x40534c(,%esi,8)
    53bb:	00 00 00 00 
	mgmt_event->iface = NULL;
    53bf:	c7 04 f5 50 53 40 00 	movl   $0x0,0x405350(,%esi,8)
    53c6:	00 00 00 00 

		mgmt_run_callbacks(mgmt_event);

		mgmt_clean_event(mgmt_event);

		k_yield();
    53ca:	e8 82 18 00 00       	call   6c51 <k_yield>
    53cf:	eb a0                	jmp    5371 <mgmt_thread+0x7>
			k_sem_init(&network_event, 0, UINT_MAX);
    53d1:	6a ff                	push   $0xffffffff
    53d3:	6a 00                	push   $0x0
    53d5:	68 d4 50 40 00       	push   $0x4050d4
    53da:	e8 a9 19 00 00       	call   6d88 <k_sem_init>
    53df:	83 c4 0c             	add    $0xc,%esp
			continue;
    53e2:	eb 8d                	jmp    5371 <mgmt_thread+0x7>
    53e4:	8b 03                	mov    (%ebx),%eax
    53e6:	31 ff                	xor    %edi,%edi
    53e8:	89 45 f0             	mov    %eax,-0x10(%ebp)
		      NET_MGMT_GET_LAYER(cb->event_mask)) ||
    53eb:	8b 53 08             	mov    0x8(%ebx),%edx
		if (!(NET_MGMT_GET_LAYER(mgmt_event->event) &
    53ee:	8b 04 f5 4c 53 40 00 	mov    0x40534c(,%esi,8),%eax
		      NET_MGMT_GET_LAYER(cb->event_mask)) ||
    53f5:	89 d1                	mov    %edx,%ecx
    53f7:	21 c1                	and    %eax,%ecx
		if (!(NET_MGMT_GET_LAYER(mgmt_event->event) &
    53f9:	81 e1 00 00 00 30    	and    $0x30000000,%ecx
    53ff:	0f 84 92 00 00 00    	je     5497 <mgmt_thread+0x12d>
		      NET_MGMT_GET_LAYER_CODE(cb->event_mask)) ||
    5405:	89 d1                	mov    %edx,%ecx
    5407:	21 c1                	and    %eax,%ecx
		      NET_MGMT_GET_LAYER(cb->event_mask)) ||
    5409:	81 e1 00 00 ff 07    	and    $0x7ff0000,%ecx
    540f:	0f 84 82 00 00 00    	je     5497 <mgmt_thread+0x12d>
		    (NET_MGMT_GET_COMMAND(mgmt_event->event) &&
    5415:	0f b7 c8             	movzwl %ax,%ecx
		      NET_MGMT_GET_LAYER_CODE(cb->event_mask)) ||
    5418:	85 c9                	test   %ecx,%ecx
    541a:	74 09                	je     5425 <mgmt_thread+0xbb>
		    (NET_MGMT_GET_COMMAND(mgmt_event->event) &&
    541c:	66 85 d2             	test   %dx,%dx
    541f:	74 04                	je     5425 <mgmt_thread+0xbb>
		     NET_MGMT_GET_COMMAND(cb->event_mask) &&
    5421:	85 ca                	test   %ecx,%edx
    5423:	74 72                	je     5497 <mgmt_thread+0x12d>
		if (NET_MGMT_EVENT_SYNCHRONOUS(cb->event_mask)) {
    5425:	0f ba e2 1b          	bt     $0x1b,%edx
    5429:	73 5b                	jae    5486 <mgmt_thread+0x11c>
			struct mgmt_event_wait *sync_data =
    542b:	8b 53 04             	mov    0x4(%ebx),%edx
			if (sync_data->iface &&
    542e:	8b 4a 18             	mov    0x18(%edx),%ecx
    5431:	85 c9                	test   %ecx,%ecx
    5433:	74 09                	je     543e <mgmt_thread+0xd4>
    5435:	3b 0c f5 50 53 40 00 	cmp    0x405350(,%esi,8),%ecx
    543c:	75 59                	jne    5497 <mgmt_thread+0x12d>
			cb->raised_event = mgmt_event->event;
    543e:	89 43 08             	mov    %eax,0x8(%ebx)
 */
static inline void sys_slist_remove(sys_slist_t *list,
				    sys_snode_t *prev_node,
				    sys_snode_t *node)
{
	if (!prev_node) {
    5441:	85 ff                	test   %edi,%edi
			sync_data->iface = mgmt_event->iface;
    5443:	8b 04 f5 50 53 40 00 	mov    0x405350(,%esi,8),%eax
    544a:	89 42 18             	mov    %eax,0x18(%edx)
    544d:	8b 03                	mov    (%ebx),%eax
    544f:	75 14                	jne    5465 <mgmt_thread+0xfb>
		list->head = node->next;
    5451:	a3 40 53 40 00       	mov    %eax,0x405340

		/* Was node also the tail? */
		if (list->tail == node) {
    5456:	3b 1d 44 53 40 00    	cmp    0x405344,%ebx
    545c:	75 17                	jne    5475 <mgmt_thread+0x10b>
			list->tail = list->head;
    545e:	a3 44 53 40 00       	mov    %eax,0x405344
    5463:	eb 10                	jmp    5475 <mgmt_thread+0x10b>
		}
	} else {
		prev_node->next = node->next;
    5465:	89 07                	mov    %eax,(%edi)

		/* Was node the tail? */
		if (list->tail == node) {
    5467:	3b 1d 44 53 40 00    	cmp    0x405344,%ebx
    546d:	75 06                	jne    5475 <mgmt_thread+0x10b>
			list->tail = prev_node;
    546f:	89 3d 44 53 40 00    	mov    %edi,0x405344
		}
	}

	node->next = NULL;
    5475:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
			k_sem_give(cb->sync_call);
    547b:	ff 73 04             	pushl  0x4(%ebx)
    547e:	e8 27 19 00 00       	call   6daa <k_sem_give>
    5483:	58                   	pop    %eax
    5484:	eb 11                	jmp    5497 <mgmt_thread+0x12d>
			cb->handler(cb, mgmt_event->event, mgmt_event->iface);
    5486:	ff 34 f5 50 53 40 00 	pushl  0x405350(,%esi,8)
    548d:	50                   	push   %eax
    548e:	53                   	push   %ebx
			prev = &cb->node;
    548f:	89 df                	mov    %ebx,%edi
			cb->handler(cb, mgmt_event->event, mgmt_event->iface);
    5491:	ff 53 04             	call   *0x4(%ebx)
    5494:	83 c4 0c             	add    $0xc,%esp
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&event_callbacks, cb, tmp, node) {
    5497:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    549b:	0f 84 13 ff ff ff    	je     53b4 <mgmt_thread+0x4a>
    54a1:	8b 5d f0             	mov    -0x10(%ebp),%ebx
    54a4:	8b 03                	mov    (%ebx),%eax
    54a6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    54a9:	e9 3d ff ff ff       	jmp    53eb <mgmt_thread+0x81>

000054ae <net_mgmt_event_notify>:

	mgmt_rebuild_global_event_mask();
}

void net_mgmt_event_notify(u32_t mgmt_event, struct net_if *iface)
{
    54ae:	55                   	push   %ebp
	return ((mgmt_event & global_event_mask) == mgmt_event);
    54af:	a1 48 53 40 00       	mov    0x405348,%eax
{
    54b4:	89 e5                	mov    %esp,%ebp
    54b6:	53                   	push   %ebx
    54b7:	8b 55 08             	mov    0x8(%ebp),%edx
    54ba:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	return ((mgmt_event & global_event_mask) == mgmt_event);
    54bd:	21 d0                	and    %edx,%eax
	if (mgmt_is_event_handled(mgmt_event)) {
    54bf:	39 c2                	cmp    %eax,%edx
    54c1:	75 68                	jne    552b <net_mgmt_event_notify+0x7d>
	events[in_event].event = mgmt_event;
    54c3:	0f b7 0d 3e 53 40 00 	movzwl 0x40533e,%ecx
    54ca:	89 c8                	mov    %ecx,%eax
	in_event++;
    54cc:	40                   	inc    %eax
	events[in_event].event = mgmt_event;
    54cd:	89 14 cd 4c 53 40 00 	mov    %edx,0x40534c(,%ecx,8)
	if (in_event == CONFIG_NET_MGMT_EVENT_QUEUE_SIZE) {
    54d4:	66 83 f8 02          	cmp    $0x2,%ax
	events[in_event].iface = iface;
    54d8:	89 1c cd 50 53 40 00 	mov    %ebx,0x405350(,%ecx,8)
	if (in_event == CONFIG_NET_MGMT_EVENT_QUEUE_SIZE) {
    54df:	74 08                	je     54e9 <net_mgmt_event_notify+0x3b>
	in_event++;
    54e1:	66 a3 3e 53 40 00    	mov    %ax,0x40533e
    54e7:	eb 09                	jmp    54f2 <net_mgmt_event_notify+0x44>
		in_event = 0;
    54e9:	66 c7 05 3e 53 40 00 	movw   $0x0,0x40533e
    54f0:	00 00 
	if (in_event == out_event) {
    54f2:	66 a1 3e 53 40 00    	mov    0x40533e,%ax
    54f8:	66 3b 05 3c 53 40 00 	cmp    0x40533c,%ax
    54ff:	75 1c                	jne    551d <net_mgmt_event_notify+0x6f>
		u16_t o_idx = out_event + 1;
    5501:	40                   	inc    %eax
		if (o_idx == CONFIG_NET_MGMT_EVENT_QUEUE_SIZE) {
    5502:	66 83 f8 02          	cmp    $0x2,%ax
    5506:	75 02                	jne    550a <net_mgmt_event_notify+0x5c>
			o_idx = 0;
    5508:	31 c0                	xor    %eax,%eax
		if (events[o_idx].event) {
    550a:	0f b7 d0             	movzwl %ax,%edx
    550d:	83 3c d5 4c 53 40 00 	cmpl   $0x0,0x40534c(,%edx,8)
    5514:	00 
    5515:	74 06                	je     551d <net_mgmt_event_notify+0x6f>
			out_event = o_idx;
    5517:	66 a3 3c 53 40 00    	mov    %ax,0x40533c
			NET_MGMT_GET_LAYER(mgmt_event),
			NET_MGMT_GET_LAYER_CODE(mgmt_event),
			NET_MGMT_GET_COMMAND(mgmt_event));

		mgmt_push_event(mgmt_event, iface);
		k_sem_give(&network_event);
    551d:	c7 45 08 d4 50 40 00 	movl   $0x4050d4,0x8(%ebp)
	}
}
    5524:	5b                   	pop    %ebx
    5525:	5d                   	pop    %ebp
		k_sem_give(&network_event);
    5526:	e9 7f 18 00 00       	jmp    6daa <k_sem_give>
}
    552b:	5b                   	pop    %ebx
    552c:	5d                   	pop    %ebp
    552d:	c3                   	ret    

0000552e <net_mgmt_event_init>:
	return mgmt_event_wait_call(iface, mgmt_event_mask,
				    raised_event, NULL, timeout);
}

void net_mgmt_event_init(void)
{
    552e:	55                   	push   %ebp
	list->head = NULL;
    552f:	c7 05 40 53 40 00 00 	movl   $0x0,0x405340
    5536:	00 00 00 
    5539:	89 e5                	mov    %esp,%ebp
	global_event_mask = 0;

	in_event = 0;
	out_event = 0;

	memset(events, 0,
    553b:	6a 10                	push   $0x10
    553d:	6a 00                	push   $0x0
    553f:	68 4c 53 40 00       	push   $0x40534c
	list->tail = NULL;
    5544:	c7 05 44 53 40 00 00 	movl   $0x0,0x405344
    554b:	00 00 00 
	global_event_mask = 0;
    554e:	c7 05 48 53 40 00 00 	movl   $0x0,0x405348
    5555:	00 00 00 
	in_event = 0;
    5558:	66 c7 05 3e 53 40 00 	movw   $0x0,0x40533e
    555f:	00 00 
	out_event = 0;
    5561:	66 c7 05 3c 53 40 00 	movw   $0x0,0x40533c
    5568:	00 00 
	memset(events, 0,
    556a:	e8 d4 cb ff ff       	call   2143 <memset>
    556f:	83 c4 0c             	add    $0xc,%esp
	       CONFIG_NET_MGMT_EVENT_QUEUE_SIZE *
	       sizeof(struct mgmt_event_entry));

	k_thread_create(&mgmt_thread_data, mgmt_stack,
    5572:	6a 00                	push   $0x0
    5574:	6a 00                	push   $0x0
    5576:	6a f7                	push   $0xfffffff7
    5578:	6a 00                	push   $0x0
    557a:	6a 00                	push   $0x0
    557c:	6a 00                	push   $0x0
    557e:	68 6a 53 00 00       	push   $0x536a
    5583:	68 00 02 00 00       	push   $0x200
    5588:	68 00 c0 40 00       	push   $0x40c000
    558d:	68 60 53 40 00       	push   $0x405360
    5592:	e8 40 1c 00 00       	call   71d7 <k_thread_create>
    5597:	83 c4 28             	add    $0x28,%esp
			K_PRIO_COOP(CONFIG_NET_MGMT_EVENT_THREAD_PRIO), 0, 0);

	NET_DBG("Net MGMT initialized: queue of %u entries, stack size of %u",
		CONFIG_NET_MGMT_EVENT_QUEUE_SIZE,
		CONFIG_NET_MGMT_EVENT_STACK_SIZE);
}
    559a:	c9                   	leave  
    559b:	c3                   	ret    

0000559c <net_udp_header_fits>:
{
    559c:	55                   	push   %ebp
    559d:	89 e5                	mov    %esp,%ebp
    559f:	53                   	push   %ebx
    55a0:	89 d3                	mov    %edx,%ebx
	if (net_header_fits(pkt, (u8_t *)hdr, sizeof(*hdr))) {
    55a2:	6a 08                	push   $0x8
    55a4:	52                   	push   %edx
    55a5:	50                   	push   %eax
    55a6:	e8 28 ef ff ff       	call   44d3 <net_header_fits>
    55ab:	83 c4 0c             	add    $0xc,%esp
    55ae:	84 c0                	test   %al,%al
    55b0:	75 02                	jne    55b4 <net_udp_header_fits+0x18>
	return NULL;
    55b2:	31 db                	xor    %ebx,%ebx
}
    55b4:	89 d8                	mov    %ebx,%eax
    55b6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    55b9:	c9                   	leave  
    55ba:	c3                   	ret    

000055bb <net_udp_set_chksum>:
	NET_DBG("Cannot insert UDP header into %p", pkt);
	return NULL;
}

struct net_buf *net_udp_set_chksum(struct net_pkt *pkt, struct net_buf *frag)
{
    55bb:	55                   	push   %ebp
    55bc:	89 e5                	mov    %esp,%ebp
    55be:	57                   	push   %edi
    55bf:	56                   	push   %esi
    55c0:	53                   	push   %ebx
    55c1:	83 ec 08             	sub    $0x8,%esp
	struct net_udp_hdr *hdr;
	u16_t chksum = 0;
    55c4:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)
{
    55ca:	8b 5d 08             	mov    0x8(%ebp),%ebx
    55cd:	8b 75 0c             	mov    0xc(%ebp),%esi
	u16_t pos;

	hdr = net_pkt_udp_data(pkt);
    55d0:	53                   	push   %ebx
    55d1:	e8 6c eb ff ff       	call   4142 <net_pkt_udp_data>
    55d6:	5f                   	pop    %edi
	if (net_udp_header_fits(pkt, hdr)) {
    55d7:	89 c2                	mov    %eax,%edx
	hdr = net_pkt_udp_data(pkt);
    55d9:	89 c7                	mov    %eax,%edi
	if (net_udp_header_fits(pkt, hdr)) {
    55db:	89 d8                	mov    %ebx,%eax
    55dd:	e8 ba ff ff ff       	call   559c <net_udp_header_fits>
    55e2:	85 c0                	test   %eax,%eax
    55e4:	74 18                	je     55fe <net_udp_set_chksum+0x43>
		hdr->chksum = 0;
    55e6:	66 c7 47 06 00 00    	movw   $0x0,0x6(%edi)
}

static inline u16_t net_calc_chksum_udp(struct net_pkt *pkt)
{
	return net_calc_chksum(pkt, IPPROTO_UDP);
    55ec:	6a 11                	push   $0x11
    55ee:	53                   	push   %ebx
    55ef:	e8 d9 ed ff ff       	call   43cd <net_calc_chksum>
		hdr->chksum = ~net_calc_chksum_udp(pkt);
    55f4:	f7 d0                	not    %eax
    55f6:	5b                   	pop    %ebx
    55f7:	5a                   	pop    %edx
    55f8:	66 89 47 06          	mov    %ax,0x6(%edi)

		return frag;
    55fc:	eb 59                	jmp    5657 <net_udp_set_chksum+0x9c>
	}

	/* We need to set the checksum to 0 first before the calc */
	frag = net_pkt_write(pkt, frag,
    55fe:	8d 55 f0             	lea    -0x10(%ebp),%edx
    5601:	8d 7d f2             	lea    -0xe(%ebp),%edi
    5604:	68 e8 03 00 00       	push   $0x3e8
    5609:	52                   	push   %edx
    560a:	6a 02                	push   $0x2
    560c:	57                   	push   %edi
			     net_pkt_ip_hdr_len(pkt) +
			     net_pkt_ipv6_ext_len(pkt) +
			     2 + 2 + 2 /* src + dst + len */,
    560d:	0f b6 43 33          	movzbl 0x33(%ebx),%eax
	frag = net_pkt_write(pkt, frag,
    5611:	83 c0 06             	add    $0x6,%eax
    5614:	89 55 ec             	mov    %edx,-0x14(%ebp)
    5617:	50                   	push   %eax
    5618:	56                   	push   %esi
    5619:	53                   	push   %ebx
    561a:	e8 4a e9 ff ff       	call   3f69 <net_pkt_write>
    561f:	83 c4 1c             	add    $0x1c,%esp
    5622:	89 c6                	mov    %eax,%esi
    5624:	6a 11                	push   $0x11
    5626:	53                   	push   %ebx
    5627:	e8 a1 ed ff ff       	call   43cd <net_calc_chksum>
    562c:	5a                   	pop    %edx
			     &pos, sizeof(chksum), (u8_t *)&chksum,
			     PKT_WAIT_TIME);

	chksum = ~net_calc_chksum_udp(pkt);
    562d:	f7 d0                	not    %eax
    562f:	66 89 45 f0          	mov    %ax,-0x10(%ebp)

	frag = net_pkt_write(pkt, frag, pos - 2, &pos, sizeof(chksum),
    5633:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
    5637:	83 e8 02             	sub    $0x2,%eax
    563a:	8b 55 ec             	mov    -0x14(%ebp),%edx
    563d:	0f b7 c0             	movzwl %ax,%eax
    5640:	59                   	pop    %ecx
    5641:	68 e8 03 00 00       	push   $0x3e8
    5646:	52                   	push   %edx
    5647:	6a 02                	push   $0x2
    5649:	57                   	push   %edi
    564a:	50                   	push   %eax
    564b:	56                   	push   %esi
    564c:	53                   	push   %ebx
    564d:	e8 17 e9 ff ff       	call   3f69 <net_pkt_write>
    5652:	83 c4 1c             	add    $0x1c,%esp
    5655:	89 c6                	mov    %eax,%esi
			     (u8_t *)&chksum, PKT_WAIT_TIME);

	NET_ASSERT(frag);

	return frag;
}
    5657:	8d 65 f4             	lea    -0xc(%ebp),%esp
    565a:	89 f0                	mov    %esi,%eax
    565c:	5b                   	pop    %ebx
    565d:	5e                   	pop    %esi
    565e:	5f                   	pop    %edi
    565f:	5d                   	pop    %ebp
    5660:	c3                   	ret    

00005661 <net_udp_get_chksum>:

u16_t net_udp_get_chksum(struct net_pkt *pkt, struct net_buf *frag)
{
    5661:	55                   	push   %ebp
    5662:	89 e5                	mov    %esp,%ebp
    5664:	56                   	push   %esi
    5665:	53                   	push   %ebx
    5666:	50                   	push   %eax
    5667:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct net_udp_hdr *hdr;
	u16_t chksum;
	u16_t pos;

	hdr = net_pkt_udp_data(pkt);
    566a:	53                   	push   %ebx
    566b:	e8 d2 ea ff ff       	call   4142 <net_pkt_udp_data>
    5670:	5a                   	pop    %edx
    5671:	89 c6                	mov    %eax,%esi
	if (net_udp_header_fits(pkt, hdr)) {
    5673:	89 c2                	mov    %eax,%edx
    5675:	89 d8                	mov    %ebx,%eax
    5677:	e8 20 ff ff ff       	call   559c <net_udp_header_fits>
    567c:	85 c0                	test   %eax,%eax
    567e:	74 06                	je     5686 <net_udp_get_chksum+0x25>
		return hdr->chksum;
    5680:	66 8b 46 06          	mov    0x6(%esi),%ax
    5684:	eb 20                	jmp    56a6 <net_udp_get_chksum+0x45>
	}

	frag = net_frag_read(frag,
    5686:	8d 45 f4             	lea    -0xc(%ebp),%eax
    5689:	50                   	push   %eax
    568a:	8d 45 f6             	lea    -0xa(%ebp),%eax
    568d:	6a 02                	push   $0x2
    568f:	50                   	push   %eax
			     net_pkt_ip_hdr_len(pkt) +
			     net_pkt_ipv6_ext_len(pkt) +
			     2 + 2 + 2 /* src + dst + len */,
    5690:	0f b6 43 33          	movzbl 0x33(%ebx),%eax
	frag = net_frag_read(frag,
    5694:	83 c0 06             	add    $0x6,%eax
    5697:	50                   	push   %eax
    5698:	ff 75 0c             	pushl  0xc(%ebp)
    569b:	e8 1e e8 ff ff       	call   3ebe <net_frag_read>
    56a0:	83 c4 14             	add    $0x14,%esp
			     &pos, sizeof(chksum), (u8_t *)&chksum);
	NET_ASSERT(frag);

	return chksum;
    56a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    56a6:	8d 65 f8             	lea    -0x8(%ebp),%esp
    56a9:	5b                   	pop    %ebx
    56aa:	5e                   	pop    %esi
    56ab:	5d                   	pop    %ebp
    56ac:	c3                   	ret    

000056ad <net_udp_get_hdr>:

struct net_udp_hdr *net_udp_get_hdr(struct net_pkt *pkt,
				    struct net_udp_hdr *hdr)
{
    56ad:	55                   	push   %ebp
    56ae:	89 e5                	mov    %esp,%ebp
    56b0:	57                   	push   %edi
    56b1:	56                   	push   %esi
    56b2:	53                   	push   %ebx
    56b3:	50                   	push   %eax
    56b4:	8b 7d 08             	mov    0x8(%ebp),%edi
    56b7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct net_udp_hdr *udp_hdr;
	struct net_buf *frag;
	u16_t pos;

	udp_hdr = net_pkt_udp_data(pkt);
    56ba:	57                   	push   %edi
    56bb:	e8 82 ea ff ff       	call   4142 <net_pkt_udp_data>
    56c0:	5a                   	pop    %edx
    56c1:	89 c6                	mov    %eax,%esi
	if (net_udp_header_fits(pkt, udp_hdr)) {
    56c3:	89 c2                	mov    %eax,%edx
    56c5:	89 f8                	mov    %edi,%eax
    56c7:	e8 d0 fe ff ff       	call   559c <net_udp_header_fits>
    56cc:	85 c0                	test   %eax,%eax
    56ce:	75 5e                	jne    572e <net_udp_get_hdr+0x81>
		return udp_hdr;
	}

	frag = net_frag_read(pkt->frags, net_pkt_ip_hdr_len(pkt) +
    56d0:	8d 75 f2             	lea    -0xe(%ebp),%esi
    56d3:	53                   	push   %ebx
    56d4:	6a 02                	push   $0x2
    56d6:	56                   	push   %esi
    56d7:	0f b6 47 33          	movzbl 0x33(%edi),%eax
    56db:	50                   	push   %eax
    56dc:	ff 77 08             	pushl  0x8(%edi)
    56df:	e8 da e7 ff ff       	call   3ebe <net_frag_read>
    56e4:	83 c4 14             	add    $0x14,%esp
			     net_pkt_ipv6_ext_len(pkt),
			     &pos, sizeof(hdr->src_port),
			     (u8_t *)&hdr->src_port);
	frag = net_frag_read(frag, pos, &pos, sizeof(hdr->dst_port),
			     (u8_t *)&hdr->dst_port);
    56e7:	8d 53 02             	lea    0x2(%ebx),%edx
	frag = net_frag_read(frag, pos, &pos, sizeof(hdr->dst_port),
    56ea:	52                   	push   %edx
    56eb:	6a 02                	push   $0x2
    56ed:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
    56f1:	56                   	push   %esi
    56f2:	52                   	push   %edx
    56f3:	50                   	push   %eax
    56f4:	e8 c5 e7 ff ff       	call   3ebe <net_frag_read>
    56f9:	83 c4 14             	add    $0x14,%esp
	frag = net_frag_read(frag, pos, &pos, sizeof(hdr->len),
			     (u8_t *)&hdr->len);
    56fc:	8d 53 04             	lea    0x4(%ebx),%edx
	frag = net_frag_read(frag, pos, &pos, sizeof(hdr->len),
    56ff:	52                   	push   %edx
    5700:	6a 02                	push   $0x2
    5702:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
    5706:	56                   	push   %esi
    5707:	52                   	push   %edx
    5708:	50                   	push   %eax
    5709:	e8 b0 e7 ff ff       	call   3ebe <net_frag_read>
    570e:	83 c4 14             	add    $0x14,%esp
	frag = net_frag_read(frag, pos, &pos, sizeof(hdr->chksum),
			     (u8_t *)&hdr->chksum);
    5711:	8d 53 06             	lea    0x6(%ebx),%edx
	frag = net_frag_read(frag, pos, &pos, sizeof(hdr->chksum),
    5714:	52                   	push   %edx
    5715:	6a 02                	push   $0x2
    5717:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
    571b:	56                   	push   %esi
    571c:	52                   	push   %edx
    571d:	50                   	push   %eax
    571e:	e8 9b e7 ff ff       	call   3ebe <net_frag_read>
	if (!frag) {
		NET_ASSERT(frag);
		return NULL;
    5723:	31 f6                	xor    %esi,%esi
	frag = net_frag_read(frag, pos, &pos, sizeof(hdr->chksum),
    5725:	83 c4 14             	add    $0x14,%esp
	if (!frag) {
    5728:	85 c0                	test   %eax,%eax
    572a:	74 02                	je     572e <net_udp_get_hdr+0x81>
	}

	return hdr;
    572c:	89 de                	mov    %ebx,%esi
}
    572e:	8d 65 f4             	lea    -0xc(%ebp),%esp
    5731:	89 f0                	mov    %esi,%eax
    5733:	5b                   	pop    %ebx
    5734:	5e                   	pop    %esi
    5735:	5f                   	pop    %edi
    5736:	5d                   	pop    %ebp
    5737:	c3                   	ret    

00005738 <net_udp_init>:
{
	return net_conn_unregister(handle);
}

void net_udp_init(void)
{
    5738:	55                   	push   %ebp
    5739:	89 e5                	mov    %esp,%ebp
}
    573b:	5d                   	pop    %ebp
    573c:	c3                   	ret    

0000573d <check_addr>:
}

static bool check_addr(struct net_pkt *pkt,
		       struct sockaddr *addr,
		       bool is_remote)
{
    573d:	55                   	push   %ebp
    573e:	89 e5                	mov    %esp,%ebp
    5740:	57                   	push   %edi
    5741:	56                   	push   %esi
    5742:	53                   	push   %ebx
    5743:	53                   	push   %ebx
	return pkt->family;
    5744:	8a 58 34             	mov    0x34(%eax),%bl
	if (addr->sa_family != net_pkt_family(pkt)) {
    5747:	8b 32                	mov    (%edx),%esi
    5749:	c0 eb 03             	shr    $0x3,%bl
    574c:	83 e3 0f             	and    $0xf,%ebx
    574f:	0f b6 fb             	movzbl %bl,%edi
    5752:	66 39 fe             	cmp    %di,%si
    5755:	75 33                	jne    578a <check_addr+0x4d>
		return true;
	}
#endif /* CONFIG_NET_IPV6 */

#if defined(CONFIG_NET_IPV4)
	if (net_pkt_family(pkt) == AF_INET && addr->sa_family == AF_INET) {
    5757:	80 fb 02             	cmp    $0x2,%bl
    575a:	0f 94 45 f3          	sete   -0xd(%ebp)
    575e:	66 83 fe 02          	cmp    $0x2,%si
    5762:	0f 94 c3             	sete   %bl
    5765:	22 5d f3             	and    -0xd(%ebp),%bl
    5768:	74 24                	je     578e <check_addr+0x51>
    576a:	8b 40 08             	mov    0x8(%eax),%eax
		struct in_addr *addr4;

		if (is_remote) {
    576d:	84 c9                	test   %cl,%cl
			addr4 = &NET_IPV4_HDR(pkt)->src;
    576f:	8b 48 08             	mov    0x8(%eax),%ecx
		if (is_remote) {
    5772:	74 05                	je     5779 <check_addr+0x3c>
			addr4 = &NET_IPV4_HDR(pkt)->src;
    5774:	83 c1 0c             	add    $0xc,%ecx
    5777:	eb 03                	jmp    577c <check_addr+0x3f>
		} else {
			addr4 = &NET_IPV4_HDR(pkt)->dst;
    5779:	83 c1 10             	add    $0x10,%ecx
		}

		if (net_sin(addr)->sin_addr.s_addr) {
    577c:	8b 42 04             	mov    0x4(%edx),%eax
    577f:	85 c0                	test   %eax,%eax
    5781:	74 0d                	je     5790 <check_addr+0x53>
			if (!net_ipv4_addr_cmp(&net_sin(addr)->sin_addr,
    5783:	39 01                	cmp    %eax,(%ecx)
    5785:	0f 94 c3             	sete   %bl
    5788:	eb 06                	jmp    5790 <check_addr+0x53>
		return false;
    578a:	31 db                	xor    %ebx,%ebx
    578c:	eb 02                	jmp    5790 <check_addr+0x53>
			}
		}
	}
#endif /* CONFIG_NET_IPV4 */

	return true;
    578e:	b3 01                	mov    $0x1,%bl
}
    5790:	5a                   	pop    %edx
    5791:	88 d8                	mov    %bl,%al
    5793:	5b                   	pop    %ebx
    5794:	5e                   	pop    %esi
    5795:	5f                   	pop    %edi
    5796:	5d                   	pop    %ebp
    5797:	c3                   	ret    

00005798 <net_conn_input>:
#endif /* CONFIG_NET_IPV4 */
	}
}

enum net_verdict net_conn_input(enum net_ip_protocol proto, struct net_pkt *pkt)
{
    5798:	55                   	push   %ebp
    5799:	89 e5                	mov    %esp,%ebp
    579b:	57                   	push   %edi
    579c:	56                   	push   %esi
    579d:	53                   	push   %ebx
    579e:	83 ec 1c             	sub    $0x1c,%esp
    57a1:	8b 5d 0c             	mov    0xc(%ebp),%ebx

	/* This is only used for getting source and destination ports.
	 * Because both TCP and UDP header have these in the same
	 * location, we can check them both using the UDP struct.
	 */
	if (IS_ENABLED(CONFIG_NET_UDP) && proto == IPPROTO_UDP) {
    57a4:	83 7d 08 11          	cmpl   $0x11,0x8(%ebp)
    57a8:	0f 85 51 01 00 00    	jne    58ff <net_conn_input+0x167>
		struct net_udp_hdr hdr, *udp_hdr;

		ARG_UNUSED(hdr);

		udp_hdr = net_udp_get_hdr(pkt, &hdr);
    57ae:	8d 45 ec             	lea    -0x14(%ebp),%eax
    57b1:	50                   	push   %eax
    57b2:	53                   	push   %ebx
    57b3:	e8 f5 fe ff ff       	call   56ad <net_udp_get_hdr>
    57b8:	5f                   	pop    %edi
		if (!udp_hdr) {
    57b9:	85 c0                	test   %eax,%eax
		udp_hdr = net_udp_get_hdr(pkt, &hdr);
    57bb:	5a                   	pop    %edx
		if (!udp_hdr) {
    57bc:	0f 84 3d 01 00 00    	je     58ff <net_conn_input+0x167>
			return NET_DROP;
		}

		src_port = udp_hdr->src_port;
    57c2:	66 8b 08             	mov    (%eax),%cx
    57c5:	be a0 53 40 00       	mov    $0x4053a0,%esi
    57ca:	66 89 4d e2          	mov    %cx,-0x1e(%ebp)
		dst_port = udp_hdr->dst_port;
    57ce:	66 8b 48 02          	mov    0x2(%eax),%cx
		chksum = udp_hdr->chksum;
    57d2:	66 8b 40 06          	mov    0x6(%eax),%ax
		dst_port = udp_hdr->dst_port;
    57d6:	66 89 4d e0          	mov    %cx,-0x20(%ebp)
		chksum = udp_hdr->chksum;
    57da:	66 89 45 de          	mov    %ax,-0x22(%ebp)
	s16_t best_rank = -1;
    57de:	66 c7 45 e8 ff ff    	movw   $0xffff,-0x18(%ebp)
	int i, best_match = -1;
    57e4:	83 cf ff             	or     $0xffffffff,%edi
			ntohs(src_port),
			ntohs(dst_port),
			net_pkt_family(pkt), ntohs(chksum));
	}

	for (i = 0; i < CONFIG_NET_MAX_CONN; i++) {
    57e7:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		if (!(conns[i].flags & NET_CONN_IN_USE)) {
    57ee:	8a 46 19             	mov    0x19(%esi),%al
    57f1:	88 45 eb             	mov    %al,-0x15(%ebp)
    57f4:	a8 01                	test   $0x1,%al
    57f6:	0f 84 80 00 00 00    	je     587c <net_conn_input+0xe4>
			continue;
		}

		if (conns[i].proto != proto) {
    57fc:	80 7e 18 11          	cmpb   $0x11,0x18(%esi)
    5800:	75 7a                	jne    587c <net_conn_input+0xe4>
			continue;
		}

		if (net_sin(&conns[i].remote_addr)->sin_port) {
    5802:	66 8b 46 02          	mov    0x2(%esi),%ax
			if (net_sin(&conns[i].remote_addr)->sin_port !=
    5806:	66 85 c0             	test   %ax,%ax
    5809:	74 06                	je     5811 <net_conn_input+0x79>
    580b:	66 39 45 e2          	cmp    %ax,-0x1e(%ebp)
    580f:	75 6b                	jne    587c <net_conn_input+0xe4>
    5811:	8d 46 08             	lea    0x8(%esi),%eax
    5814:	89 45 d8             	mov    %eax,-0x28(%ebp)
			    src_port) {
				continue;
			}
		}

		if (net_sin(&conns[i].local_addr)->sin_port) {
    5817:	66 8b 46 0a          	mov    0xa(%esi),%ax
			if (net_sin(&conns[i].local_addr)->sin_port !=
    581b:	66 39 45 e0          	cmp    %ax,-0x20(%ebp)
    581f:	74 05                	je     5826 <net_conn_input+0x8e>
    5821:	66 85 c0             	test   %ax,%ax
    5824:	75 56                	jne    587c <net_conn_input+0xe4>
			    dst_port) {
				continue;
			}
		}

		if (conns[i].flags & NET_CONN_REMOTE_ADDR_SET) {
    5826:	f6 45 eb 02          	testb  $0x2,-0x15(%ebp)
    582a:	74 12                	je     583e <net_conn_input+0xa6>
			if (!check_addr(pkt, &conns[i].remote_addr, true)) {
    582c:	b9 01 00 00 00       	mov    $0x1,%ecx
    5831:	89 f2                	mov    %esi,%edx
    5833:	89 d8                	mov    %ebx,%eax
    5835:	e8 03 ff ff ff       	call   573d <check_addr>
    583a:	84 c0                	test   %al,%al
    583c:	74 3e                	je     587c <net_conn_input+0xe4>
				continue;
			}
		}

		if (conns[i].flags & NET_CONN_LOCAL_ADDR_SET) {
    583e:	f6 45 eb 04          	testb  $0x4,-0x15(%ebp)
    5842:	74 10                	je     5854 <net_conn_input+0xbc>
			if (!check_addr(pkt, &conns[i].local_addr, false)) {
    5844:	31 c9                	xor    %ecx,%ecx
    5846:	8d 56 08             	lea    0x8(%esi),%edx
    5849:	89 d8                	mov    %ebx,%eax
    584b:	e8 ed fe ff ff       	call   573d <check_addr>
    5850:	84 c0                	test   %al,%al
    5852:	74 28                	je     587c <net_conn_input+0xe4>

		/* If we have an existing best_match, and that one
		 * specifies a remote port, then we've matched to a
		 * LISTENING connection that should not override.
		 */
		if (best_match >= 0 &&
    5854:	83 ff ff             	cmp    $0xffffffff,%edi
    5857:	74 0d                	je     5866 <net_conn_input+0xce>
		    net_sin(&conns[best_match].remote_addr)->sin_port) {
    5859:	6b c7 1c             	imul   $0x1c,%edi,%eax
		if (best_match >= 0 &&
    585c:	66 83 b8 a2 53 40 00 	cmpw   $0x0,0x4053a2(%eax)
    5863:	00 
    5864:	75 16                	jne    587c <net_conn_input+0xe4>
			continue;
		}

		if (best_rank < conns[i].rank) {
    5866:	0f b6 4e 1a          	movzbl 0x1a(%esi),%ecx
    586a:	0f bf 45 e8          	movswl -0x18(%ebp),%eax
    586e:	39 c8                	cmp    %ecx,%eax
    5870:	7d 0a                	jge    587c <net_conn_input+0xe4>
			best_rank = conns[i].rank;
    5872:	0f b6 c1             	movzbl %cl,%eax
    5875:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
    5879:	8b 7d e4             	mov    -0x1c(%ebp),%edi
	for (i = 0; i < CONFIG_NET_MAX_CONN; i++) {
    587c:	ff 45 e4             	incl   -0x1c(%ebp)
    587f:	83 c6 1c             	add    $0x1c,%esi
    5882:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
    5886:	0f 85 62 ff ff ff    	jne    57ee <net_conn_input+0x56>
			best_match = i;
		}
	}

	if (best_match >= 0) {
    588c:	83 ff ff             	cmp    $0xffffffff,%edi
    588f:	74 3b                	je     58cc <net_conn_input+0x134>
		 */
		if (IS_ENABLED(CONFIG_NET_UDP_CHECKSUM) &&
		    proto == IPPROTO_UDP) {
			u16_t chksum_calc;

			net_udp_set_chksum(pkt, pkt->frags);
    5891:	ff 73 08             	pushl  0x8(%ebx)
    5894:	53                   	push   %ebx
    5895:	e8 21 fd ff ff       	call   55bb <net_udp_set_chksum>
    589a:	58                   	pop    %eax
    589b:	5a                   	pop    %edx
			chksum_calc = net_udp_get_chksum(pkt, pkt->frags);
    589c:	ff 73 08             	pushl  0x8(%ebx)
    589f:	53                   	push   %ebx
    58a0:	e8 bc fd ff ff       	call   5661 <net_udp_get_chksum>

			if (chksum != chksum_calc) {
    58a5:	66 39 45 de          	cmp    %ax,-0x22(%ebp)
			chksum_calc = net_udp_get_chksum(pkt, pkt->frags);
    58a9:	59                   	pop    %ecx
    58aa:	5e                   	pop    %esi
			if (chksum != chksum_calc) {
    58ab:	75 52                	jne    58ff <net_conn_input+0x167>
			conns[best_match].cb,
			conns[best_match].user_data,
			conns[best_match].rank);
#endif /* CONFIG_NET_CONN_CACHE */

		if (conns[best_match].cb(&conns[best_match], pkt,
    58ad:	6b c7 1c             	imul   $0x1c,%edi,%eax
    58b0:	ff b0 b4 53 40 00    	pushl  0x4053b4(%eax)
    58b6:	05 a0 53 40 00       	add    $0x4053a0,%eax
    58bb:	53                   	push   %ebx
    58bc:	50                   	push   %eax
    58bd:	ff 50 10             	call   *0x10(%eax)
    58c0:	83 c4 0c             	add    $0xc,%esp
			goto drop;
		}

		net_stats_update_per_proto_recv(proto);

		return NET_OK;
    58c3:	31 d2                	xor    %edx,%edx
		if (conns[best_match].cb(&conns[best_match], pkt,
    58c5:	83 f8 02             	cmp    $0x2,%eax
    58c8:	75 3a                	jne    5904 <net_conn_input+0x16c>
    58ca:	eb 33                	jmp    58ff <net_conn_input+0x167>
    58cc:	8a 43 34             	mov    0x34(%ebx),%al
    58cf:	c0 e8 03             	shr    $0x3,%al
    58d2:	83 e0 0f             	and    $0xf,%eax
	    net_is_ipv6_addr_mcast(&NET_IPV6_HDR(pkt)->dst)) {
		;
	} else
#endif
#if defined(CONFIG_NET_IPV4)
	if (net_pkt_family(pkt) == AF_INET &&
    58d5:	3c 02                	cmp    $0x2,%al
    58d7:	75 15                	jne    58ee <net_conn_input+0x156>
	return pkt->frags->data;
    58d9:	8b 43 08             	mov    0x8(%ebx),%eax
	return (addr->s_addr & 0xE0000000) == 0xE0000000;
    58dc:	8b 40 08             	mov    0x8(%eax),%eax
    58df:	8b 40 10             	mov    0x10(%eax),%eax
    58e2:	25 00 00 00 e0       	and    $0xe0000000,%eax
    58e7:	3d 00 00 00 e0       	cmp    $0xe0000000,%eax
    58ec:	eb 02                	jmp    58f0 <net_conn_input+0x158>
	if (net_pkt_family(pkt) == AF_INET6) {
    58ee:	3c 0a                	cmp    $0xa,%al
    58f0:	74 0d                	je     58ff <net_conn_input+0x167>
		net_icmpv4_send_error(pkt, NET_ICMPV4_DST_UNREACH,
    58f2:	6a 03                	push   $0x3
    58f4:	6a 03                	push   $0x3
    58f6:	53                   	push   %ebx
    58f7:	e8 d2 f7 ff ff       	call   50ce <net_icmpv4_send_error>
    58fc:	83 c4 0c             	add    $0xc,%esp
	}

drop:
	net_stats_update_per_proto_drop(proto);

	return NET_DROP;
    58ff:	ba 02 00 00 00       	mov    $0x2,%edx
}
    5904:	8d 65 f4             	lea    -0xc(%ebp),%esp
    5907:	89 d0                	mov    %edx,%eax
    5909:	5b                   	pop    %ebx
    590a:	5e                   	pop    %esi
    590b:	5f                   	pop    %edi
    590c:	5d                   	pop    %ebp
    590d:	c3                   	ret    

0000590e <net_conn_init>:
		cb(&conns[i], user_data);
	}
}

void net_conn_init(void)
{
    590e:	55                   	push   %ebp
    590f:	89 e5                	mov    %esp,%ebp
		for (i = 0; i < CONFIG_NET_MAX_CONN; i++) {
			conn_cache[i].idx = -1;
		}
	} while (0);
#endif /* CONFIG_NET_CONN_CACHE */
}
    5911:	5d                   	pop    %ebp
    5912:	c3                   	ret    

00005913 <net_app_init>:
#else
#define setup_ipv6(...)
#endif /* CONFIG_NET_IPV6 */

int net_app_init(const char *app_info, u32_t flags, s32_t timeout)
{
    5913:	55                   	push   %ebp
    5914:	89 e5                	mov    %esp,%ebp
    5916:	57                   	push   %edi
    5917:	56                   	push   %esi
    5918:	53                   	push   %ebx
    5919:	50                   	push   %eax
    591a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
#define LOOP_DIVIDER 10
	struct net_if *iface = net_if_get_default();
    591d:	e8 bf dd ff ff       	call   36e1 <net_if_get_default>
    5922:	89 c7                	mov    %eax,%edi
		NET_INFO("%s", app_info);
	}

	if (!iface) {
		NET_ERR("No network interfaces");
		return -ENODEV;
    5924:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
	if (!iface) {
    5929:	85 ff                	test   %edi,%edi
    592b:	0f 84 d9 00 00 00    	je     5a0a <net_app_init+0xf7>
	}

	if (flags & NET_APP_NEED_IPV6) {
    5931:	89 d8                	mov    %ebx,%eax
		count++;
	}

	if (flags & NET_APP_NEED_IPV4) {
		count++;
    5933:	31 d2                	xor    %edx,%edx
	if (flags & NET_APP_NEED_IPV6) {
    5935:	d1 e8                	shr    %eax
	}

	k_sem_init(&counter, count, UINT_MAX);
    5937:	6a ff                	push   $0xffffffff
	int count = 0;
    5939:	83 e0 01             	and    $0x1,%eax
		count++;
    593c:	80 e3 04             	and    $0x4,%bl
    593f:	0f 95 c2             	setne  %dl
    5942:	01 d0                	add    %edx,%eax
	if (net_addr_pton(AF_INET, CONFIG_NET_APP_MY_IPV4_ADDR, &addr)) {
    5944:	8d 5d f0             	lea    -0x10(%ebp),%ebx
	k_sem_init(&counter, count, UINT_MAX);
    5947:	50                   	push   %eax
    5948:	68 10 54 40 00       	push   $0x405410
    594d:	e8 36 14 00 00       	call   6d88 <k_sem_init>
    5952:	83 c4 0c             	add    $0xc,%esp
	if (net_addr_pton(AF_INET, CONFIG_NET_APP_MY_IPV4_ADDR, &addr)) {
    5955:	53                   	push   %ebx
    5956:	68 80 77 00 00       	push   $0x7780
    595b:	6a 02                	push   $0x2
    595d:	e8 64 e8 ff ff       	call   41c6 <net_addr_pton>
    5962:	83 c4 0c             	add    $0xc,%esp
    5965:	85 c0                	test   %eax,%eax
    5967:	75 41                	jne    59aa <net_app_init+0x97>
	net_if_ipv4_addr_add(iface, &addr, NET_ADDR_MANUAL, 0);
    5969:	6a 00                	push   $0x0
    596b:	6a 03                	push   $0x3
    596d:	53                   	push   %ebx
    596e:	57                   	push   %edi
    596f:	e8 fa dd ff ff       	call   376e <net_if_ipv4_addr_add>
    5974:	83 c4 10             	add    $0x10,%esp
		if (net_addr_pton(AF_INET, CONFIG_NET_APP_MY_IPV4_NETMASK,
    5977:	53                   	push   %ebx
    5978:	68 8a 77 00 00       	push   $0x778a
    597d:	6a 02                	push   $0x2
    597f:	e8 42 e8 ff ff       	call   41c6 <net_addr_pton>
    5984:	83 c4 0c             	add    $0xc,%esp
    5987:	85 c0                	test   %eax,%eax
    5989:	75 06                	jne    5991 <net_app_init+0x7e>
 * @param netmask IPv4 netmask
 */
static inline void net_if_ipv4_set_netmask(struct net_if *iface,
					   struct in_addr *netmask)
{
	net_ipaddr_copy(&iface->ipv4.netmask, netmask);
    598b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    598e:	89 47 78             	mov    %eax,0x78(%edi)
	k_sem_take(&counter, K_NO_WAIT);
    5991:	6a 00                	push   $0x0
    5993:	68 10 54 40 00       	push   $0x405410
    5998:	e8 a6 14 00 00       	call   6e43 <k_sem_take>
    599d:	5b                   	pop    %ebx
    599e:	5e                   	pop    %esi
	k_sem_give(&waiter);
    599f:	68 04 51 40 00       	push   $0x405104
    59a4:	e8 01 14 00 00       	call   6daa <k_sem_give>
    59a9:	5f                   	pop    %edi

	setup_dhcpv4(iface);

	setup_ipv6(iface, flags);

	if (timeout < 0) {
    59aa:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    59ae:	78 17                	js     59c7 <net_app_init+0xb4>
		count = -1;
	} else if (timeout == 0) {
    59b0:	75 05                	jne    59b7 <net_app_init+0xa4>
		count = -1;
    59b2:	83 ce ff             	or     $0xffffffff,%esi
    59b5:	eb 42                	jmp    59f9 <net_app_init+0xe6>
		count = 0;
	} else {
		count = timeout / 1000 + 1;
    59b7:	8b 45 10             	mov    0x10(%ebp),%eax
    59ba:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
    59bf:	99                   	cltd   
    59c0:	f7 f9                	idiv   %ecx
    59c2:	8d 58 01             	lea    0x1(%eax),%ebx
    59c5:	eb 03                	jmp    59ca <net_app_init+0xb7>
		count = -1;
    59c7:	83 cb ff             	or     $0xffffffff,%ebx
	int loop = timeout / LOOP_DIVIDER;
    59ca:	8b 45 10             	mov    0x10(%ebp),%eax
    59cd:	b9 0a 00 00 00       	mov    $0xa,%ecx
    59d2:	99                   	cltd   
    59d3:	f7 f9                	idiv   %ecx
    59d5:	89 c7                	mov    %eax,%edi
    59d7:	4b                   	dec    %ebx
	}

	/* Loop here until until we are ready to continue. As we might need
	 * to wait multiple events, sleep smaller amounts of data.
	 */
	while (count--) {
    59d8:	89 de                	mov    %ebx,%esi
    59da:	83 fb ff             	cmp    $0xffffffff,%ebx
    59dd:	74 d3                	je     59b2 <net_app_init+0x9f>
		if (k_sem_take(&waiter, loop)) {
    59df:	57                   	push   %edi
    59e0:	68 04 51 40 00       	push   $0x405104
    59e5:	e8 59 14 00 00       	call   6e43 <k_sem_take>
    59ea:	5a                   	pop    %edx
    59eb:	85 c0                	test   %eax,%eax
    59ed:	59                   	pop    %ecx
    59ee:	74 e7                	je     59d7 <net_app_init+0xc4>
			if (!k_sem_count_get(&counter)) {
    59f0:	83 3d 18 54 40 00 00 	cmpl   $0x0,0x405418
    59f7:	75 de                	jne    59d7 <net_app_init+0xc4>
				break;
			}
		}
	}

	if (!count && timeout) {
    59f9:	85 f6                	test   %esi,%esi
    59fb:	75 0b                	jne    5a08 <net_app_init+0xf5>
		NET_ERR("Timeout while waiting setup");
		return -ETIMEDOUT;
    59fd:	b8 c4 ff ff ff       	mov    $0xffffffc4,%eax
	if (!count && timeout) {
    5a02:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    5a06:	75 02                	jne    5a0a <net_app_init+0xf7>
	}

	return 0;
    5a08:	31 c0                	xor    %eax,%eax
}
    5a0a:	8d 65 f4             	lea    -0xc(%ebp),%esp
    5a0d:	5b                   	pop    %ebx
    5a0e:	5e                   	pop    %esi
    5a0f:	5f                   	pop    %edi
    5a10:	5d                   	pop    %ebp
    5a11:	c3                   	ret    

00005a12 <init_net_app>:

#if defined(CONFIG_NET_APP_AUTO_INIT)
static int init_net_app(struct device *device)
{
    5a12:	55                   	push   %ebp
    5a13:	89 e5                	mov    %esp,%ebp
	if (IS_ENABLED(CONFIG_NET_APP_NEED_IPV4)) {
		flags |= NET_APP_NEED_IPV4;
	}

	/* Initialize the application automatically if needed */
	ret = net_app_init("Initializing network", flags,
    5a15:	68 30 75 00 00       	push   $0x7530
    5a1a:	6a 00                	push   $0x0
    5a1c:	68 98 77 00 00       	push   $0x7798
    5a21:	e8 ed fe ff ff       	call   5913 <net_app_init>
    5a26:	83 c4 0c             	add    $0xc,%esp
	if (ret < 0) {
		NET_ERR("Network initialization failed (%d)", ret);
	}

	return ret;
}
    5a29:	c9                   	leave  
    5a2a:	c3                   	ret    

00005a2b <k_cpu_idle>:
 * will be issued causing a low-power consumption sleep mode.
 *
 * @return N/A
 */
void k_cpu_idle(void)
{
    5a2b:	55                   	push   %ebp
    5a2c:	89 e5                	mov    %esp,%ebp
	_sys_k_event_logger_enter_sleep();
#if defined(CONFIG_BOOT_TIME_MEASUREMENT)
	__idle_time_stamp = (u64_t)k_cycle_get_32();
#endif

	__asm__ volatile (
    5a2e:	fb                   	sti    
    5a2f:	f4                   	hlt    
	    "sti\n\t"
	    "hlt\n\t");
}
    5a30:	5d                   	pop    %ebp
    5a31:	c3                   	ret    

00005a32 <_SysFatalErrorHandler>:
 *
 * @return This function does not return.
 */
FUNC_NORETURN __weak void _SysFatalErrorHandler(unsigned int reason,
					 const NANO_ESF *pEsf)
{
    5a32:	55                   	push   %ebp
    5a33:	89 e5                	mov    %esp,%ebp
#ifdef CONFIG_STACK_SENTINEL
	if (reason == _NANO_ERR_STACK_CHK_FAIL) {
		goto hang_system;
	}
#endif
	if (reason == _NANO_ERR_KERNEL_PANIC) {
    5a35:	83 7d 08 08          	cmpl   $0x8,0x8(%ebp)
    5a39:	74 54                	je     5a8f <_SysFatalErrorHandler+0x5d>
		goto hang_system;
	}
	if (k_is_in_isr() || _is_thread_essential()) {
    5a3b:	e8 64 16 00 00       	call   70a4 <k_is_in_isr>
    5a40:	85 c0                	test   %eax,%eax
    5a42:	74 15                	je     5a59 <_SysFatalErrorHandler+0x27>
		printk("Fatal fault in %s! Spinning...\n",
		       k_is_in_isr() ? "ISR" : "essential thread");
    5a44:	e8 5b 16 00 00       	call   70a4 <k_is_in_isr>
		printk("Fatal fault in %s! Spinning...\n",
    5a49:	ba ad 77 00 00       	mov    $0x77ad,%edx
    5a4e:	85 c0                	test   %eax,%eax
    5a50:	75 30                	jne    5a82 <_SysFatalErrorHandler+0x50>
    5a52:	ba b1 77 00 00       	mov    $0x77b1,%edx
    5a57:	eb 29                	jmp    5a82 <_SysFatalErrorHandler+0x50>
	if (k_is_in_isr() || _is_thread_essential()) {
    5a59:	e8 57 16 00 00       	call   70b5 <_is_thread_essential>
    5a5e:	85 c0                	test   %eax,%eax
    5a60:	75 e2                	jne    5a44 <_SysFatalErrorHandler+0x12>
		goto hang_system;
	}
	printk("Fatal fault in thread %p! Aborting.\n", _current);
    5a62:	ff 35 c8 54 40 00    	pushl  0x4054c8
    5a68:	68 e2 77 00 00       	push   $0x77e2
    5a6d:	e8 56 d8 ff ff       	call   32c8 <printk>
    5a72:	5a                   	pop    %edx
    5a73:	59                   	pop    %ecx
	k_thread_abort(_current);
    5a74:	ff 35 c8 54 40 00    	pushl  0x4054c8
    5a7a:	e8 98 18 00 00       	call   7317 <k_thread_abort>
    5a7f:	58                   	pop    %eax
    5a80:	eb 0d                	jmp    5a8f <_SysFatalErrorHandler+0x5d>
		printk("Fatal fault in %s! Spinning...\n",
    5a82:	52                   	push   %edx
    5a83:	68 c2 77 00 00       	push   $0x77c2
    5a88:	e8 3b d8 ff ff       	call   32c8 <printk>
    5a8d:	58                   	pop    %eax
    5a8e:	5a                   	pop    %edx
#else
	ARG_UNUSED(reason);
#endif

#ifdef CONFIG_BOARD_QEMU_X86
	printk("Terminate emulator due to fatal kernel error\n");
    5a8f:	68 07 78 00 00       	push   $0x7807
    5a94:	e8 2f d8 ff ff       	call   32c8 <printk>
    5a99:	58                   	pop    %eax
	__asm__ volatile("outl	%0, %w1;\n\t"
    5a9a:	31 c0                	xor    %eax,%eax
    5a9c:	e7 f4                	out    %eax,$0xf4

00005a9e <_cache_line_size_get>:
	#define CPUID_CACHE_LINE_MASK (0xff << 8)

	GTEXT(_cache_line_size_get)

SECTION_FUNC(TEXT, _cache_line_size_get)
	pushl %ebx
    5a9e:	53                   	push   %ebx
	movl $1, %eax
    5a9f:	b8 01 00 00 00       	mov    $0x1,%eax
	cpuid
    5aa4:	0f a2                	cpuid  
	movl %ebx, %eax
    5aa6:	89 d8                	mov    %ebx,%eax
	andl $CPUID_CACHE_LINE_MASK, %eax
    5aa8:	25 00 ff 00 00       	and    $0xff00,%eax
	shrl $5,%eax	/* shift right 8 to get value, then multiple by 8
    5aad:	c1 e8 05             	shr    $0x5,%eax
					 * to get cache line size */
	popl %ebx
    5ab0:	5b                   	pop    %ebx
	ret
    5ab1:	c3                   	ret    

00005ab2 <init_cache>:
#else
#define init_cache_line_size() do { } while ((0))
#endif

static int init_cache(struct device *unused)
{
    5ab2:	55                   	push   %ebp
    5ab3:	89 e5                	mov    %esp,%ebp
	sys_cache_line_size = _cache_line_size_get();
    5ab5:	e8 e4 ff ff ff       	call   5a9e <_cache_line_size_get>

	init_cache_flush();
	init_cache_line_size();

	return 0;
}
    5aba:	5d                   	pop    %ebp
	sys_cache_line_size = _cache_line_size_get();
    5abb:	a3 e4 55 40 00       	mov    %eax,0x4055e4
}
    5ac0:	31 c0                	xor    %eax,%eax
    5ac2:	c3                   	ret    

00005ac3 <_exception_enter>:
	 *
	 * Clear the direction flag.  It is automatically restored when the
	 * exception exits.
	 */

	cld
    5ac3:	fc                   	cld    


	/*
	 * Swap ecx and handler function on the current stack;
	 */
	xchgl	%ecx, (%esp)
    5ac4:	87 0c 24             	xchg   %ecx,(%esp)

	/*
	 * Push the remaining volatile registers on the existing stack.
	 */

	pushl	%eax
    5ac7:	50                   	push   %eax
	pushl	%edx
    5ac8:	52                   	push   %edx
	/*
	 * Push the cooperative registers on the existing stack as they are
	 * required by debug tools.
	 */

	pushl	%edi
    5ac9:	57                   	push   %edi
	pushl	%esi
    5aca:	56                   	push   %esi
	pushl	%ebx
    5acb:	53                   	push   %ebx
	pushl	%ebp
    5acc:	55                   	push   %ebp

	leal	44(%esp), %eax   /* Calculate ESP before interrupt occurred */
    5acd:	8d 44 24 2c          	lea    0x2c(%esp),%eax
	pushl	%eax             /* Save calculated ESP */
    5ad1:	50                   	push   %eax
	 * Test IF bit of saved EFLAGS and re-enable interrupts if IF=1.
	 */

	/* ESP is still pointing to the ESF at this point */

	testl	$0x200, __NANO_ESF_eflags_OFFSET(%esp)
    5ad2:	f7 44 24 2c 00 02 00 	testl  $0x200,0x2c(%esp)
    5ad9:	00 
	je	allDone
    5ada:	74 01                	je     5add <allDone>
	sti
    5adc:	fb                   	sti    

00005add <allDone>:

allDone:
#if CONFIG_X86_IAMCU
	movl	%esp, %eax		/* NANO_ESF * parameter */
#else
	pushl	%esp			/* push NANO_ESF * parameter */
    5add:	54                   	push   %esp
#endif
	call	*%ecx			/* call exception handler */
    5ade:	ff d1                	call   *%ecx

#ifndef CONFIG_X86_IAMCU
	addl	$0x4, %esp
    5ae0:	83 c4 04             	add    $0x4,%esp
	 * Pop the non-volatile registers from the stack.
	 * Note that debug tools may have altered the saved register values while
	 * the task was stopped, and we want to pick up the altered values.
	 */

	popl	%ebp		/* Discard saved ESP */
    5ae3:	5d                   	pop    %ebp
	popl	%ebp
    5ae4:	5d                   	pop    %ebp
	popl	%ebx
    5ae5:	5b                   	pop    %ebx
	popl	%esi
    5ae6:	5e                   	pop    %esi
	popl	%edi
    5ae7:	5f                   	pop    %edi

	/* restore edx and ecx which are always saved on the stack */

	popl	%edx
    5ae8:	5a                   	pop    %edx
	popl	%eax
    5ae9:	58                   	pop    %eax
	popl	%ecx
    5aea:	59                   	pop    %ecx

	addl	$4, %esp	/* "pop" error code */
    5aeb:	83 c4 04             	add    $0x4,%esp

	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
    5aee:	cf                   	iret   

00005aef <_kernel_oops_handler>:

#if CONFIG_X86_KERNEL_OOPS
SECTION_FUNC(TEXT, _kernel_oops_handler)
	push $0 /* dummy error code */
    5aef:	6a 00                	push   $0x0
	push $_do_kernel_oops
    5af1:	68 4a 5f 00 00       	push   $0x5f4a
	jmp _exception_enter
    5af6:	e9 c8 ff ff ff       	jmp    5ac3 <_exception_enter>

00005afb <_interrupt_enter>:
	 *
	 * Clear the direction flag.  It is automatically restored when the
	 * interrupt exits via the IRET instruction.
	 */

	cld
    5afb:	fc                   	cld    

	/*
	 * Swap EAX with isr_param and EDX with isr.
	 * Push ECX onto the stack
	 */
	xchgl	%eax, 4(%esp)
    5afc:	87 44 24 04          	xchg   %eax,0x4(%esp)
	xchgl	%edx, (%esp)
    5b00:	87 14 24             	xchg   %edx,(%esp)
	pushl	%ecx
    5b03:	51                   	push   %ecx

	/* Push EDI as we will use it for scratch space.
	 * Rest of the callee-saved regs get saved by invocation of C
	 * functions (isr handler, __swap(), etc)
	 */
	pushl	%edi
    5b04:	57                   	push   %edi
	popl	%eax
#endif

	/* load %ecx with &_kernel */

	movl	$_kernel, %ecx
    5b05:	b9 c0 54 40 00       	mov    $0x4054c0,%ecx

	/* switch to the interrupt stack for the non-nested case */

	incl	_kernel_offset_to_nested(%ecx)
    5b0a:	ff 01                	incl   (%ecx)

	/* use interrupt stack if not nested */
	cmpl	$1, _kernel_offset_to_nested(%ecx)
    5b0c:	83 39 01             	cmpl   $0x1,(%ecx)
#ifdef CONFIG_DEBUG_INFO
	jne	nested_save_isf
#else
	jne	alreadyOnIntStack
    5b0f:	75 06                	jne    5b17 <alreadyOnIntStack>
	/*
	 * switch to base of the interrupt stack: save esp in edi, then load
	 * irq_stack pointer
	 */

	movl	%esp, %edi
    5b11:	89 e7                	mov    %esp,%edi
	movl	_kernel_offset_to_irq_stack(%ecx), %esp
    5b13:	8b 61 04             	mov    0x4(%ecx),%esp


	/* save thread's stack pointer onto base of interrupt stack */

	pushl	%edi			/* Save stack pointer */
    5b16:	57                   	push   %edi

00005b17 <alreadyOnIntStack>:

#ifndef CONFIG_X86_IAMCU
	/* EAX has the interrupt handler argument, needs to go on
	 * stack for sys V calling convention
	 */
	push	%eax
    5b17:	50                   	push   %eax
	pop %edx
	pop %eax
#endif

#ifdef CONFIG_NESTED_INTERRUPTS
	sti			/* re-enable interrupts */
    5b18:	fb                   	sti    
#endif
	/* Now call the interrupt handler */
	call	*%edx
    5b19:	ff d2                	call   *%edx
#ifndef CONFIG_X86_IAMCU
	/* Discard ISR argument */
	addl	$0x4, %esp
    5b1b:	83 c4 04             	add    $0x4,%esp
#endif
#ifdef CONFIG_NESTED_INTERRUPTS
	cli			/* disable interrupts again */
    5b1e:	fa                   	cli    
#endif

	/* irq_controller.h interface */
	_irq_controller_eoi_macro
    5b1f:	31 c0                	xor    %eax,%eax
    5b21:	a3 b0 00 e0 fe       	mov    %eax,0xfee000b0
#ifdef CONFIG_INT_LATENCY_BENCHMARK
	call	_int_latency_start
#endif

	/* determine whether exiting from a nested interrupt */
	movl	$_kernel, %ecx
    5b26:	b9 c0 54 40 00       	mov    $0x4054c0,%ecx
#ifdef CONFIG_DEBUG_INFO
	popl	_kernel_offset_to_isf(%ecx)    /* Restore old ISF */
#endif
	decl	_kernel_offset_to_nested(%ecx)	/* dec interrupt nest count */
    5b2b:	ff 09                	decl   (%ecx)
	jne	nestedInterrupt                 /* 'iret' if nested case */
    5b2d:	75 25                	jne    5b54 <nestedInterrupt>


#ifdef CONFIG_PREEMPT_ENABLED
	movl	_kernel_offset_to_current(%ecx), %edx
    5b2f:	8b 51 08             	mov    0x8(%ecx),%edx

	/*
	 * Non-preemptible thread ? Do not schedule (see explanation of
	 * preempt field in kernel_struct.h).
	 */
	cmpw	$_NON_PREEMPT_THRESHOLD, _thread_offset_to_preempt(%edx)
    5b32:	66 81 7a 0a 80 00    	cmpw   $0x80,0xa(%edx)
	jae	noReschedule
    5b38:	73 19                	jae    5b53 <noReschedule>


	/* reschedule only if the scheduler says that we must do so */
	cmpl	%edx, _kernel_offset_to_ready_q_cache(%ecx)
    5b3a:	39 51 14             	cmp    %edx,0x14(%ecx)
	je	noReschedule
    5b3d:	74 14                	je     5b53 <noReschedule>
	 * the existing __swap() primitive to save the remaining
	 * thread's registers (including floating point) and perform
	 * a switch to the new thread.
	 */

	popl	%esp	/* switch back to outgoing thread's stack */
    5b3f:	5c                   	pop    %esp
	popl	%ebx
	popl	%esi
#endif

#if defined(CONFIG_TIMESLICING)
	call	_update_time_slice_before_swap
    5b40:	e8 90 11 00 00       	call   6cd5 <_update_time_slice_before_swap>
#endif
#ifdef CONFIG_STACK_SENTINEL
	call	_check_stack_sentinel
#endif
	pushfl			/* push KERNEL_LOCK_KEY argument */
    5b45:	9c                   	pushf  
#ifdef CONFIG_X86_IAMCU
	/* IAMCU first argument goes into a register, not the stack.
	 */
	popl	%eax
#endif
	call	__swap
    5b46:	e8 26 00 00 00       	call   5b71 <__swap>

#ifndef CONFIG_X86_IAMCU
	addl 	$4, %esp	/* pop KERNEL_LOCK_KEY argument */
    5b4b:	83 c4 04             	add    $0x4,%esp

	/* Restore volatile registers and return to the interrupted thread */
#ifdef CONFIG_INT_LATENCY_BENCHMARK
	call	_int_latency_stop
#endif
	popl	%edi
    5b4e:	5f                   	pop    %edi
	popl	%ecx
    5b4f:	59                   	pop    %ecx
	popl	%edx
    5b50:	5a                   	pop    %edx
	popl	%eax
    5b51:	58                   	pop    %eax

	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
    5b52:	cf                   	iret   

00005b53 <noReschedule>:
	/*
	 * A thread reschedule is not required; switch back to the
	 * interrupted thread's stack and restore volatile registers
	 */

	popl	%esp		/* pop thread stack pointer */
    5b53:	5c                   	pop    %esp

00005b54 <nestedInterrupt>:
	popl	%ebp        /* Discard saved ESP */
	popl	%ebp
	popl	%ebx
	popl	%esi
#endif
	popl	%edi
    5b54:	5f                   	pop    %edi
	popl	%ecx		/* pop volatile registers in reverse order */
    5b55:	59                   	pop    %ecx
	popl	%edx
    5b56:	5a                   	pop    %edx
	popl	%eax
    5b57:	58                   	pop    %eax
	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
    5b58:	cf                   	iret   

00005b59 <_SpuriousIntNoErrCodeHandler>:
 * thus _SpuriousIntNoErrCodeHandler()/_SpuriousIntHandler() shall be
 * invoked with interrupts disabled.
 */
SECTION_FUNC(TEXT, _SpuriousIntNoErrCodeHandler)

	pushl	$0			/* push dummy err code onto stk */
    5b59:	6a 00                	push   $0x0

00005b5b <_SpuriousIntHandler>:
	/* fall through to _SpuriousIntHandler */


SECTION_FUNC(TEXT, _SpuriousIntHandler)

	cld				/* Clear direction flag */
    5b5b:	fc                   	cld    

	/* Create the ESF */

	pushl %eax
    5b5c:	50                   	push   %eax
	pushl %ecx
    5b5d:	51                   	push   %ecx
	pushl %edx
    5b5e:	52                   	push   %edx
	pushl %edi
    5b5f:	57                   	push   %edi
	pushl %esi
    5b60:	56                   	push   %esi
	pushl %ebx
    5b61:	53                   	push   %ebx
	pushl %ebp
    5b62:	55                   	push   %ebp

	leal	44(%esp), %ecx   /* Calculate ESP before exception occurred */
    5b63:	8d 4c 24 2c          	lea    0x2c(%esp),%ecx
	pushl	%ecx             /* Save calculated ESP */
    5b67:	51                   	push   %ecx

#ifndef CONFIG_X86_IAMCU
	pushl	%esp			/* push cur stack pointer: pEsf arg */
    5b68:	54                   	push   %esp
#else
	mov	%esp, %edx
#endif

	/* re-enable interrupts */
	sti
    5b69:	fb                   	sti    

	/* push the 'unsigned int reason' parameter */
#ifndef CONFIG_X86_IAMCU
	pushl	$_NANO_ERR_SPURIOUS_INT
    5b6a:	6a 00                	push   $0x0
#else
	movl	$_NANO_ERR_SPURIOUS_INT, %eax
#endif
	/* call the fatal error handler */
	call	_NanoFatalErrorHandler
    5b6c:	e8 4f 02 00 00       	call   5dc0 <_NanoFatalErrorHandler>

00005b71 <__swap>:
	 * any of these registers into the k_thread.  Only the 'esp' register
	 * after all the pushes have been performed) will be stored in the
	 * k_thread.
	 */

	pushl	%edi
    5b71:	57                   	push   %edi

	movl	$_kernel, %edi
    5b72:	bf c0 54 40 00       	mov    $0x4054c0,%edi

	pushl	%esi
    5b77:	56                   	push   %esi
	pushl	%ebx
    5b78:	53                   	push   %ebx
	pushl	%ebp
    5b79:	55                   	push   %ebp
	 * -EAGAIN eliminates the need for the timeout code to set it.
	 * If another value is ever needed, it can be modified with
	 * _set_thread_return_value().
	 */

	pushl   _k_neg_eagain
    5b7a:	ff 35 08 7b 00 00    	pushl  0x7b08


	/* save esp into k_thread structure */

	movl	_kernel_offset_to_current(%edi), %ecx
    5b80:	8b 4f 08             	mov    0x8(%edi),%ecx
	movl	%esp, _thread_offset_to_esp(%ecx)
    5b83:	89 61 28             	mov    %esp,0x28(%ecx)

#ifdef CONFIG_KERNEL_EVENT_LOGGER_CONTEXT_SWITCH
	/* Register the context switch */
	call	_sys_k_event_logger_context_switch
#endif
	movl	_kernel_offset_to_ready_q_cache(%edi), %eax
    5b86:	8b 47 14             	mov    0x14(%edi),%eax

#endif /* CONFIG_FP_SHARING */

	/* update _kernel.current to reflect incoming thread */

	movl    %eax, _kernel_offset_to_current(%edi)
    5b89:	89 47 08             	mov    %eax,0x8(%edi)

	/* recover task/fiber stack pointer from k_thread */

	movl	_thread_offset_to_esp(%eax), %esp
    5b8c:	8b 60 28             	mov    0x28(%eax),%esp


	/* load return value from a possible _set_thread_return_value() */

	popl	%eax
    5b8f:	58                   	pop    %eax

	/* pop the non-volatile registers from the stack */

	popl	%ebp
    5b90:	5d                   	pop    %ebp
	popl	%ebx
    5b91:	5b                   	pop    %ebx
	popl	%esi
    5b92:	5e                   	pop    %esi
	popl	%edi
    5b93:	5f                   	pop    %edi
	 * - in unified kernel, -EINVAL
	 */

	/* Utilize the 'eflags' parameter to __swap() */

	pushl	4(%esp)
    5b94:	ff 74 24 04          	pushl  0x4(%esp)
	/* restore __swap's %eax */
	popl	%eax

skipIntLatencyStop:
#endif
	popfl
    5b98:	9d                   	popf   
	jne time_read_not_needed
	movw $0x2,__read_swap_end_time_value
	read_tsc __common_var_swap_end_time
time_read_not_needed:
#endif
	ret
    5b99:	c3                   	ret    

00005b9a <_new_thread>:
void _new_thread(struct k_thread *thread, k_thread_stack_t stack,
		 size_t stackSize,
		 _thread_entry_t pEntry,
		 void *parameter1, void *parameter2, void *parameter3,
		 int priority, unsigned int options)
{
    5b9a:	55                   	push   %ebp
    5b9b:	89 e5                	mov    %esp,%ebp
    5b9d:	56                   	push   %esi
    5b9e:	53                   	push   %ebx
	_ASSERT_VALID_PRIO(priority, pEntry);

	unsigned long *pInitialThread;

#if CONFIG_X86_STACK_PROTECTION
	_x86_mmu_set_flags(stack, MMU_PAGE_SIZE, MMU_ENTRY_NOT_PRESENT,
    5b9f:	6a 01                	push   $0x1
{
    5ba1:	8b 75 0c             	mov    0xc(%ebp),%esi
	_x86_mmu_set_flags(stack, MMU_PAGE_SIZE, MMU_ENTRY_NOT_PRESENT,
    5ba4:	6a 00                	push   $0x0
    5ba6:	68 00 10 00 00       	push   $0x1000
    5bab:	56                   	push   %esi
{
    5bac:	8b 5d 08             	mov    0x8(%ebp),%ebx
	_x86_mmu_set_flags(stack, MMU_PAGE_SIZE, MMU_ENTRY_NOT_PRESENT,
    5baf:	e8 a4 00 00 00       	call   5c58 <_x86_mmu_set_flags>
    5bb4:	83 c4 10             	add    $0x10,%esp
	 * if it isn't.
	 */
	*((u32_t *)pStack) = STACK_SENTINEL;
#endif /* CONFIG_STACK_SENTINEL */
	/* Initialize various struct k_thread members */
	_init_thread_base(&thread->base, prio, _THREAD_PRESTART, options);
    5bb7:	ff 75 28             	pushl  0x28(%ebp)
    5bba:	6a 04                	push   $0x4
    5bbc:	ff 75 24             	pushl  0x24(%ebp)
    5bbf:	53                   	push   %ebx
    5bc0:	e8 18 17 00 00       	call   72dd <_init_thread_base>
	_new_thread_init(thread, pStackMem, stackSize, priority, options);

	/* carve the thread entry struct from the "base" of the stack */

	pInitialThread =
		(unsigned long *)STACK_ROUND_DOWN(pStackMem + stackSize);
    5bc5:	8b 45 10             	mov    0x10(%ebp),%eax
	 * primitive.
	 */

	/* push arguments required by _thread_entry() */

	*--pInitialThread = (unsigned long)parameter3;
    5bc8:	8b 55 20             	mov    0x20(%ebp),%edx

	/* static threads overwrite it afterwards with real value */
	thread->init_data = NULL;
    5bcb:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
	thread->fn_abort = NULL;
    5bd2:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
		(unsigned long *)STACK_ROUND_DOWN(pStackMem + stackSize);
    5bd9:	8d 84 06 00 10 00 00 	lea    0x1000(%esi,%eax,1),%eax
	_init_thread_base(&thread->base, prio, _THREAD_PRESTART, options);
    5be0:	83 c4 10             	add    $0x10,%esp
    5be3:	83 e0 fc             	and    $0xfffffffc,%eax
	*--pInitialThread = (unsigned long)parameter3;
    5be6:	89 50 fc             	mov    %edx,-0x4(%eax)
	*--pInitialThread = (unsigned long)parameter2;
    5be9:	8b 55 1c             	mov    0x1c(%ebp),%edx
    5bec:	89 50 f8             	mov    %edx,-0x8(%eax)
	*--pInitialThread = (unsigned long)parameter1;
    5bef:	8b 55 18             	mov    0x18(%ebp),%edx
    5bf2:	89 50 f4             	mov    %edx,-0xc(%eax)
	*--pInitialThread = (unsigned long)pEntry;
    5bf5:	8b 55 14             	mov    0x14(%ebp),%edx
    5bf8:	89 50 f0             	mov    %edx,-0x10(%eax)
 */
static inline unsigned int EflagsGet(void)
{
	unsigned int eflags; /* EFLAGS register contents */

	__asm__ volatile(
    5bfb:	9c                   	pushf  
    5bfc:	5a                   	pop    %edx

	/* push initial EFLAGS; only modify IF and IOPL bits */

	*--pInitialThread = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
    5bfd:	80 e6 cd             	and    $0xcd,%dh

	*--pInitialThread = (unsigned long)_thread_entry_wrapper;

#else /* defined(CONFIG_GDB_INFO) || defined(CONFIG_DEBUG_INFO) */

	*--pInitialThread = (unsigned long)_thread_entry;
    5c00:	c7 40 e8 c5 70 00 00 	movl   $0x70c5,-0x18(%eax)
	*--pInitialThread = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
    5c07:	80 ce 02             	or     $0x2,%dh
	pInitialCtx -= 11;
    5c0a:	83 e8 2c             	sub    $0x2c,%eax
	*--pInitialThread = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
    5c0d:	89 50 18             	mov    %edx,0x18(%eax)
	pInitialCtx -= 11;
    5c10:	89 43 28             	mov    %eax,0x28(%ebx)
	 * The k_thread structure is located at the "low end" of memory set
	 * aside for the thread's stack.
	 */

	_new_thread_internal(pStackMem, stackSize, priority, options, thread);
}
    5c13:	8d 65 f8             	lea    -0x8(%ebp),%esp
    5c16:	5b                   	pop    %ebx
    5c17:	5e                   	pop    %esi
    5c18:	5d                   	pop    %ebp
    5c19:	c3                   	ret    

00005c1a <_x86_mmu_get_flags>:
		!(pte.us < us_permission));
}


void _x86_mmu_get_flags(void *addr, u32_t *pde_flags, u32_t *pte_flags)
{
    5c1a:	55                   	push   %ebp
    5c1b:	89 e5                	mov    %esp,%ebp
    5c1d:	53                   	push   %ebx
    5c1e:	8b 45 08             	mov    0x8(%ebp),%eax

	pde = &X86_MMU_PD->entry[pde_index];
	pt = (struct x86_mmu_page_table *)(pde->pt.page_table << 12);
	pte = &pt->entry[pte_index];

	*pde_flags = pde->pt.value & ~MMU_PDE_PAGE_TABLE_MASK;
    5c21:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	pde_index = MMU_PDE_NUM(addr);
    5c24:	89 c2                	mov    %eax,%edx
    5c26:	c1 ea 16             	shr    $0x16,%edx
	pte_index = MMU_PAGE_NUM(addr);
    5c29:	c1 e8 0c             	shr    $0xc,%eax
	pt = (struct x86_mmu_page_table *)(pde->pt.page_table << 12);
    5c2c:	8b 14 95 00 10 40 00 	mov    0x401000(,%edx,4),%edx
	pte_index = MMU_PAGE_NUM(addr);
    5c33:	25 ff 03 00 00       	and    $0x3ff,%eax
	pt = (struct x86_mmu_page_table *)(pde->pt.page_table << 12);
    5c38:	89 d1                	mov    %edx,%ecx
	*pde_flags = pde->pt.value & ~MMU_PDE_PAGE_TABLE_MASK;
    5c3a:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
	pt = (struct x86_mmu_page_table *)(pde->pt.page_table << 12);
    5c40:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
	*pde_flags = pde->pt.value & ~MMU_PDE_PAGE_TABLE_MASK;
    5c46:	89 13                	mov    %edx,(%ebx)
	*pte_flags = pte->value & ~MMU_PTE_PAGE_MASK;
    5c48:	8b 55 10             	mov    0x10(%ebp),%edx
    5c4b:	8b 04 81             	mov    (%ecx,%eax,4),%eax
    5c4e:	25 ff 0f 00 00       	and    $0xfff,%eax
    5c53:	89 02                	mov    %eax,(%edx)
}
    5c55:	5b                   	pop    %ebx
    5c56:	5d                   	pop    %ebp
    5c57:	c3                   	ret    

00005c58 <_x86_mmu_set_flags>:
	__asm__ ("invlpg %0" :: "m" (*page));
}


void _x86_mmu_set_flags(void *ptr, size_t size, u32_t flags, u32_t mask)
{
    5c58:	55                   	push   %ebp
    5c59:	89 e5                	mov    %esp,%ebp
    5c5b:	53                   	push   %ebx
		pt = (struct x86_mmu_page_table *)(pde->pt.page_table << 12);

		pte_index = MMU_PAGE_NUM(addr);
		pte = &pt->entry[pte_index];

		pte->value = (pte->value & ~mask) | flags;
    5c5c:	8b 5d 14             	mov    0x14(%ebp),%ebx
	u32_t addr = (u32_t)ptr;
    5c5f:	8b 45 08             	mov    0x8(%ebp),%eax
		pte->value = (pte->value & ~mask) | flags;
    5c62:	f7 d3                	not    %ebx
    5c64:	8b 55 0c             	mov    0xc(%ebp),%edx
    5c67:	29 c2                	sub    %eax,%edx
	while (size) {
    5c69:	03 55 08             	add    0x8(%ebp),%edx
    5c6c:	74 34                	je     5ca2 <_x86_mmu_set_flags+0x4a>
		pde_index = MMU_PDE_NUM(addr);
    5c6e:	89 c2                	mov    %eax,%edx
    5c70:	c1 ea 16             	shr    $0x16,%edx
		pt = (struct x86_mmu_page_table *)(pde->pt.page_table << 12);
    5c73:	8b 14 95 00 10 40 00 	mov    0x401000(,%edx,4),%edx
    5c7a:	89 d1                	mov    %edx,%ecx
		pte_index = MMU_PAGE_NUM(addr);
    5c7c:	89 c2                	mov    %eax,%edx
    5c7e:	c1 ea 0a             	shr    $0xa,%edx
		pt = (struct x86_mmu_page_table *)(pde->pt.page_table << 12);
    5c81:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
    5c87:	81 e2 fc 0f 00 00    	and    $0xffc,%edx
    5c8d:	01 ca                	add    %ecx,%edx
		pte->value = (pte->value & ~mask) | flags;
    5c8f:	8b 0a                	mov    (%edx),%ecx
    5c91:	21 d9                	and    %ebx,%ecx
    5c93:	0b 4d 10             	or     0x10(%ebp),%ecx
    5c96:	89 0a                	mov    %ecx,(%edx)
	__asm__ ("invlpg %0" :: "m" (*page));
    5c98:	0f 01 38             	invlpg (%eax)
		tlb_flush_page((void *)addr);

		size -= MMU_PAGE_SIZE;
		addr += MMU_PAGE_SIZE;
    5c9b:	05 00 10 00 00       	add    $0x1000,%eax
    5ca0:	eb c2                	jmp    5c64 <_x86_mmu_set_flags+0xc>
	}
}
    5ca2:	5b                   	pop    %ebx
    5ca3:	5d                   	pop    %ebp
    5ca4:	c3                   	ret    

00005ca5 <dump_entry_flags>:
#define PK	BIT(5)
#define SGX	BIT(15)

#ifdef CONFIG_X86_MMU
static void dump_entry_flags(u32_t flags)
{
    5ca5:	55                   	push   %ebp
	printk("0x%03x %s %s %s\n", flags,
    5ca6:	a8 04                	test   $0x4,%al
{
    5ca8:	89 e5                	mov    %esp,%ebp
    5caa:	53                   	push   %ebx
	printk("0x%03x %s %s %s\n", flags,
    5cab:	bb 3a 78 00 00       	mov    $0x783a,%ebx
    5cb0:	74 05                	je     5cb7 <dump_entry_flags+0x12>
    5cb2:	bb 35 78 00 00       	mov    $0x7835,%ebx
    5cb7:	b9 45 78 00 00       	mov    $0x7845,%ecx
    5cbc:	a8 02                	test   $0x2,%al
    5cbe:	75 05                	jne    5cc5 <dump_entry_flags+0x20>
    5cc0:	b9 4e 78 00 00       	mov    $0x784e,%ecx
    5cc5:	ba 58 78 00 00       	mov    $0x7858,%edx
    5cca:	a8 01                	test   $0x1,%al
    5ccc:	75 05                	jne    5cd3 <dump_entry_flags+0x2e>
    5cce:	ba 60 78 00 00       	mov    $0x7860,%edx
    5cd3:	53                   	push   %ebx
    5cd4:	51                   	push   %ecx
    5cd5:	52                   	push   %edx
    5cd6:	50                   	push   %eax
    5cd7:	68 6c 78 00 00       	push   $0x786c
    5cdc:	e8 e7 d5 ff ff       	call   32c8 <printk>
    5ce1:	83 c4 14             	add    $0x14,%esp
	       flags & MMU_ENTRY_PRESENT ? "Present" : "Non-present",
	       flags & MMU_ENTRY_WRITE ? "Writable" : "Read-only",
	       flags & MMU_ENTRY_USER ? "User" : "Supervisor");
}
    5ce4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5ce7:	c9                   	leave  
    5ce8:	c3                   	ret    

00005ce9 <_df_handler_top>:
{
	/* State of the system when the double-fault forced a task switch
	 * will be in _main_tss. Set up a NANO_ESF and copy system state into
	 * it
	 */
	_df_esf.esp = _main_tss.esp;
    5ce9:	a1 d8 01 40 00       	mov    0x4001d8,%eax
{
    5cee:	55                   	push   %ebp
	_df_esf.esp = _main_tss.esp;
    5cef:	a3 60 73 40 00       	mov    %eax,0x407360
	_df_esf.ebp = _main_tss.ebp;
    5cf4:	a1 dc 01 40 00       	mov    0x4001dc,%eax
    5cf9:	a3 64 73 40 00       	mov    %eax,0x407364
	_df_esf.ebx = _main_tss.ebx;
    5cfe:	a1 d4 01 40 00       	mov    0x4001d4,%eax
    5d03:	a3 68 73 40 00       	mov    %eax,0x407368
	_df_esf.esi = _main_tss.esi;
    5d08:	a1 e0 01 40 00       	mov    0x4001e0,%eax
    5d0d:	a3 6c 73 40 00       	mov    %eax,0x40736c
	_df_esf.edi = _main_tss.edi;
    5d12:	a1 e4 01 40 00       	mov    0x4001e4,%eax
    5d17:	a3 70 73 40 00       	mov    %eax,0x407370
	_df_esf.edx = _main_tss.edx;
    5d1c:	a1 d0 01 40 00       	mov    0x4001d0,%eax
    5d21:	a3 74 73 40 00       	mov    %eax,0x407374
	_df_esf.eax = _main_tss.eax;
    5d26:	a1 c8 01 40 00       	mov    0x4001c8,%eax
    5d2b:	a3 78 73 40 00       	mov    %eax,0x407378
	_df_esf.ecx = _main_tss.ecx;
    5d30:	a1 cc 01 40 00       	mov    0x4001cc,%eax
    5d35:	a3 7c 73 40 00       	mov    %eax,0x40737c
	_df_esf.errorCode = 0;
	_df_esf.eip = _main_tss.eip;
    5d3a:	a1 c0 01 40 00       	mov    0x4001c0,%eax
	_df_esf.errorCode = 0;
    5d3f:	c7 05 80 73 40 00 00 	movl   $0x0,0x407380
    5d46:	00 00 00 
	_df_esf.eip = _main_tss.eip;
    5d49:	a3 84 73 40 00       	mov    %eax,0x407384
	_df_esf.cs = _main_tss.cs;
    5d4e:	0f b7 05 ec 01 40 00 	movzwl 0x4001ec,%eax
    5d55:	a3 88 73 40 00       	mov    %eax,0x407388
	_df_esf.eflags = _main_tss.eflags;
    5d5a:	a1 c4 01 40 00       	mov    0x4001c4,%eax
    5d5f:	a3 8c 73 40 00       	mov    %eax,0x40738c
{
    5d64:	89 e5                	mov    %esp,%ebp

	/* Restore the main IA task to a runnable state */
	_main_tss.esp = (u32_t)(K_THREAD_STACK_BUFFER(_interrupt_stack) +
    5d66:	c7 05 d8 01 40 00 00 	movl   $0x413800,0x4001d8
    5d6d:	38 41 00 
				CONFIG_ISR_STACK_SIZE);
	_main_tss.cs = CODE_SEG;
    5d70:	66 c7 05 ec 01 40 00 	movw   $0x8,0x4001ec
    5d77:	08 00 
	_main_tss.ds = DATA_SEG;
    5d79:	66 c7 05 f4 01 40 00 	movw   $0x10,0x4001f4
    5d80:	10 00 
	_main_tss.es = DATA_SEG;
    5d82:	66 c7 05 e8 01 40 00 	movw   $0x10,0x4001e8
    5d89:	10 00 
	_main_tss.fs = DATA_SEG;
    5d8b:	66 c7 05 f8 01 40 00 	movw   $0x10,0x4001f8
    5d92:	10 00 
	_main_tss.gs = DATA_SEG;
    5d94:	66 c7 05 fc 01 40 00 	movw   $0x10,0x4001fc
    5d9b:	10 00 
	_main_tss.ss = DATA_SEG;
    5d9d:	66 c7 05 f0 01 40 00 	movw   $0x10,0x4001f0
    5da4:	10 00 
	_main_tss.eip = (u32_t)_df_handler_bottom;
    5da6:	c7 05 c0 01 40 00 f3 	movl   $0x5ef3,0x4001c0
    5dad:	5e 00 00 
	_main_tss.cr3 = (u32_t)X86_MMU_PD;
    5db0:	c7 05 bc 01 40 00 00 	movl   $0x401000,0x4001bc
    5db7:	10 40 00 

	/* NT bit is set in EFLAGS so we will task switch back to _main_tss
	 * and run _df_handler_bottom
	 */
	__asm__ volatile ("iret");
    5dba:	cf                   	iret   

00005dbb <_debug_fatal_hook>:
__weak void _debug_fatal_hook(const NANO_ESF *esf) { ARG_UNUSED(esf); }
    5dbb:	55                   	push   %ebp
    5dbc:	89 e5                	mov    %esp,%ebp
    5dbe:	5d                   	pop    %ebp
    5dbf:	c3                   	ret    

00005dc0 <_NanoFatalErrorHandler>:
{
    5dc0:	55                   	push   %ebp
    5dc1:	89 e5                	mov    %esp,%ebp
    5dc3:	57                   	push   %edi
    5dc4:	56                   	push   %esi
    5dc5:	53                   	push   %ebx
    5dc6:	83 ec 28             	sub    $0x28,%esp
    5dc9:	8b 75 08             	mov    0x8(%ebp),%esi
    5dcc:	8b 7d 0c             	mov    0xc(%ebp),%edi
	_debug_fatal_hook(pEsf);
    5dcf:	57                   	push   %edi
    5dd0:	e8 e6 ff ff ff       	call   5dbb <_debug_fatal_hook>
    5dd5:	58                   	pop    %eax
	switch (reason) {
    5dd6:	83 fe 08             	cmp    $0x8,%esi
    5dd9:	77 5a                	ja     5e35 <_NanoFatalErrorHandler+0x75>
    5ddb:	ff 24 b5 20 7a 00 00 	jmp    *0x7a20(,%esi,4)
 * @return the vector of the interrupt that is currently being processed, or
 * -1 if this can't be determined
 */
static inline int _irq_controller_isr_vector_get(void)
{
	return __irq_controller_isr_vector_get();
    5de2:	e8 18 cc ff ff       	call   29ff <__irq_controller_isr_vector_get>
		printk("***** Unhandled interrupt vector ");
    5de7:	68 7d 78 00 00       	push   $0x787d
    5dec:	89 c3                	mov    %eax,%ebx
    5dee:	e8 d5 d4 ff ff       	call   32c8 <printk>
    5df3:	58                   	pop    %eax
		if (vector >= 0) {
    5df4:	85 db                	test   %ebx,%ebx
    5df6:	78 0d                	js     5e05 <_NanoFatalErrorHandler+0x45>
			printk("%d ", vector);
    5df8:	53                   	push   %ebx
    5df9:	68 9f 78 00 00       	push   $0x789f
    5dfe:	e8 c5 d4 ff ff       	call   32c8 <printk>
    5e03:	5b                   	pop    %ebx
    5e04:	58                   	pop    %eax
		printk("*****\n");
    5e05:	68 ff 78 00 00       	push   $0x78ff
    5e0a:	eb 05                	jmp    5e11 <_NanoFatalErrorHandler+0x51>
		printk("***** Invalid Exit Software Error! *****\n");
    5e0c:	68 a3 78 00 00       	push   $0x78a3
    5e11:	e8 b2 d4 ff ff       	call   32c8 <printk>
    5e16:	59                   	pop    %ecx
		break;
    5e17:	eb 29                	jmp    5e42 <_NanoFatalErrorHandler+0x82>
		printk("***** Stack Check Fail! *****\n");
    5e19:	68 cd 78 00 00       	push   $0x78cd
    5e1e:	eb f1                	jmp    5e11 <_NanoFatalErrorHandler+0x51>
		printk("***** Kernel OOPS! *****\n");
    5e20:	68 ec 78 00 00       	push   $0x78ec
    5e25:	eb ea                	jmp    5e11 <_NanoFatalErrorHandler+0x51>
		printk("***** Kernel Panic! *****\n");
    5e27:	68 06 79 00 00       	push   $0x7906
    5e2c:	eb e3                	jmp    5e11 <_NanoFatalErrorHandler+0x51>
		printk("**** Kernel Allocation Failure! ****\n");
    5e2e:	68 21 79 00 00       	push   $0x7921
    5e33:	eb dc                	jmp    5e11 <_NanoFatalErrorHandler+0x51>
		printk("**** Unknown Fatal Error %d! ****\n", reason);
    5e35:	56                   	push   %esi
    5e36:	68 47 79 00 00       	push   $0x7947
    5e3b:	e8 88 d4 ff ff       	call   32c8 <printk>
    5e40:	58                   	pop    %eax
    5e41:	5a                   	pop    %edx
	printk("Current thread ID = %p\n"
    5e42:	8b 47 04             	mov    0x4(%edi),%eax
    5e45:	8b 4f 2c             	mov    0x2c(%edi),%ecx
    5e48:	89 45 f0             	mov    %eax,-0x10(%ebp)
    5e4b:	8b 47 10             	mov    0x10(%edi),%eax
    5e4e:	89 45 ec             	mov    %eax,-0x14(%ebp)
    5e51:	8b 47 0c             	mov    0xc(%edi),%eax
    5e54:	89 45 e8             	mov    %eax,-0x18(%ebp)
    5e57:	8b 47 14             	mov    0x14(%edi),%eax
    5e5a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    5e5d:	8b 47 1c             	mov    0x1c(%edi),%eax
    5e60:	89 45 e0             	mov    %eax,-0x20(%ebp)
    5e63:	8b 47 08             	mov    0x8(%edi),%eax
    5e66:	89 45 dc             	mov    %eax,-0x24(%ebp)
    5e69:	8b 47 18             	mov    0x18(%edi),%eax
    5e6c:	8b 17                	mov    (%edi),%edx
    5e6e:	89 45 d8             	mov    %eax,-0x28(%ebp)
    5e71:	8b 47 24             	mov    0x24(%edi),%eax
    5e74:	89 4d cc             	mov    %ecx,-0x34(%ebp)
    5e77:	89 55 d0             	mov    %edx,-0x30(%ebp)
    5e7a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    5e7d:	0f b7 5f 28          	movzwl 0x28(%edi),%ebx
    5e81:	e8 0a 0e 00 00       	call   6c90 <k_current_get>
    5e86:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    5e89:	8b 55 d0             	mov    -0x30(%ebp),%edx
    5e8c:	51                   	push   %ecx
    5e8d:	52                   	push   %edx
    5e8e:	ff 75 f0             	pushl  -0x10(%ebp)
    5e91:	ff 75 ec             	pushl  -0x14(%ebp)
    5e94:	ff 75 e8             	pushl  -0x18(%ebp)
    5e97:	ff 75 e4             	pushl  -0x1c(%ebp)
    5e9a:	ff 75 e0             	pushl  -0x20(%ebp)
    5e9d:	ff 75 dc             	pushl  -0x24(%ebp)
    5ea0:	ff 75 d8             	pushl  -0x28(%ebp)
    5ea3:	ff 75 d4             	pushl  -0x2c(%ebp)
    5ea6:	53                   	push   %ebx
    5ea7:	50                   	push   %eax
    5ea8:	68 6a 79 00 00       	push   $0x796a
    5ead:	e8 16 d4 ff ff       	call   32c8 <printk>
    5eb2:	83 c4 34             	add    $0x34,%esp
	_SysFatalErrorHandler(reason, pEsf);
    5eb5:	57                   	push   %edi
    5eb6:	56                   	push   %esi
    5eb7:	e8 76 fb ff ff       	call   5a32 <_SysFatalErrorHandler>

00005ebc <generic_exc_handle>:
{
    5ebc:	55                   	push   %ebp
    5ebd:	89 e5                	mov    %esp,%ebp
    5ebf:	56                   	push   %esi
    5ec0:	89 c6                	mov    %eax,%esi
    5ec2:	53                   	push   %ebx
    5ec3:	89 d3                	mov    %edx,%ebx
	printk("***** CPU exception %d\n", vector);
    5ec5:	50                   	push   %eax
    5ec6:	68 44 7a 00 00       	push   $0x7a44
    5ecb:	e8 f8 d3 ff ff       	call   32c8 <printk>
    5ed0:	59                   	pop    %ecx
    5ed1:	58                   	pop    %eax
	if ((1 << vector) & _EXC_ERROR_CODE_FAULTS) {
    5ed2:	b8 00 7d 02 00       	mov    $0x27d00,%eax
    5ed7:	0f a3 f0             	bt     %esi,%eax
    5eda:	73 0f                	jae    5eeb <generic_exc_handle+0x2f>
		printk("***** Exception code: 0x%x\n", pEsf->errorCode);
    5edc:	ff 73 20             	pushl  0x20(%ebx)
    5edf:	68 5c 7a 00 00       	push   $0x7a5c
    5ee4:	e8 df d3 ff ff       	call   32c8 <printk>
    5ee9:	58                   	pop    %eax
    5eea:	5a                   	pop    %edx
	_NanoFatalErrorHandler(_NANO_ERR_CPU_EXCEPTION, pEsf);
    5eeb:	53                   	push   %ebx
    5eec:	6a 06                	push   $0x6
    5eee:	e8 cd fe ff ff       	call   5dc0 <_NanoFatalErrorHandler>

00005ef3 <_df_handler_bottom>:
{
    5ef3:	55                   	push   %ebp
    5ef4:	89 e5                	mov    %esp,%ebp
    5ef6:	83 ec 08             	sub    $0x8,%esp
	_x86_mmu_get_flags((void *)_df_esf.esp - 1, &pde_flags, &pte_flags);
    5ef9:	a1 60 73 40 00       	mov    0x407360,%eax
	_df_tss.esp = (u32_t)(_df_stack + sizeof(_df_stack));
    5efe:	c7 05 58 01 40 00 58 	movl   $0x407358,0x400158
    5f05:	73 40 00 
	_x86_mmu_get_flags((void *)_df_esf.esp - 1, &pde_flags, &pte_flags);
    5f08:	8d 55 f8             	lea    -0x8(%ebp),%edx
    5f0b:	48                   	dec    %eax
    5f0c:	52                   	push   %edx
    5f0d:	8d 55 fc             	lea    -0x4(%ebp),%edx
    5f10:	52                   	push   %edx
    5f11:	50                   	push   %eax
	_df_tss.eip = (u32_t)_df_handler_top;
    5f12:	c7 05 40 01 40 00 e9 	movl   $0x5ce9,0x400140
    5f19:	5c 00 00 
	_x86_mmu_get_flags((void *)_df_esf.esp - 1, &pde_flags, &pte_flags);
    5f1c:	e8 f9 fc ff ff       	call   5c1a <_x86_mmu_get_flags>
    5f21:	83 c4 0c             	add    $0xc,%esp
    5f24:	b8 04 00 00 00       	mov    $0x4,%eax
	if (pte_flags & MMU_ENTRY_PRESENT) {
    5f29:	f6 45 f8 01          	testb  $0x1,-0x8(%ebp)
    5f2d:	74 10                	je     5f3f <_df_handler_bottom+0x4c>
		printk("***** Double Fault *****\n");
    5f2f:	68 78 7a 00 00       	push   $0x7a78
    5f34:	e8 8f d3 ff ff       	call   32c8 <printk>
    5f39:	58                   	pop    %eax
		reason = _NANO_ERR_CPU_EXCEPTION;
    5f3a:	b8 06 00 00 00       	mov    $0x6,%eax
	_NanoFatalErrorHandler(reason, (NANO_ESF *)&_df_esf);
    5f3f:	68 60 73 40 00       	push   $0x407360
    5f44:	50                   	push   %eax
    5f45:	e8 76 fe ff ff       	call   5dc0 <_NanoFatalErrorHandler>

00005f4a <_do_kernel_oops>:
{
    5f4a:	55                   	push   %ebp
    5f4b:	89 e5                	mov    %esp,%ebp
    5f4d:	8b 45 08             	mov    0x8(%ebp),%eax
	_NanoFatalErrorHandler(esf->reason, &esf->nano_esf);
    5f50:	50                   	push   %eax
    5f51:	ff 70 30             	pushl  0x30(%eax)
    5f54:	e8 67 fe ff ff       	call   5dc0 <_NanoFatalErrorHandler>

00005f59 <handle_exc_0>:
EXC_FUNC_NOCODE(IV_DIVIDE_ERROR);
    5f59:	55                   	push   %ebp
    5f5a:	31 c0                	xor    %eax,%eax
    5f5c:	89 e5                	mov    %esp,%ebp
    5f5e:	8b 55 08             	mov    0x8(%ebp),%edx
    5f61:	e8 56 ff ff ff       	call   5ebc <generic_exc_handle>

00005f66 <handle_exc_2>:
EXC_FUNC_NOCODE(IV_NON_MASKABLE_INTERRUPT);
    5f66:	55                   	push   %ebp
    5f67:	b8 02 00 00 00       	mov    $0x2,%eax
    5f6c:	89 e5                	mov    %esp,%ebp
    5f6e:	8b 55 08             	mov    0x8(%ebp),%edx
    5f71:	e8 46 ff ff ff       	call   5ebc <generic_exc_handle>

00005f76 <handle_exc_4>:
EXC_FUNC_NOCODE(IV_OVERFLOW);
    5f76:	55                   	push   %ebp
    5f77:	b8 04 00 00 00       	mov    $0x4,%eax
    5f7c:	89 e5                	mov    %esp,%ebp
    5f7e:	8b 55 08             	mov    0x8(%ebp),%edx
    5f81:	e8 36 ff ff ff       	call   5ebc <generic_exc_handle>

00005f86 <handle_exc_5>:
EXC_FUNC_NOCODE(IV_BOUND_RANGE);
    5f86:	55                   	push   %ebp
    5f87:	b8 05 00 00 00       	mov    $0x5,%eax
    5f8c:	89 e5                	mov    %esp,%ebp
    5f8e:	8b 55 08             	mov    0x8(%ebp),%edx
    5f91:	e8 26 ff ff ff       	call   5ebc <generic_exc_handle>

00005f96 <handle_exc_6>:
EXC_FUNC_NOCODE(IV_INVALID_OPCODE);
    5f96:	55                   	push   %ebp
    5f97:	b8 06 00 00 00       	mov    $0x6,%eax
    5f9c:	89 e5                	mov    %esp,%ebp
    5f9e:	8b 55 08             	mov    0x8(%ebp),%edx
    5fa1:	e8 16 ff ff ff       	call   5ebc <generic_exc_handle>

00005fa6 <handle_exc_7>:
EXC_FUNC_NOCODE(IV_DEVICE_NOT_AVAILABLE);
    5fa6:	55                   	push   %ebp
    5fa7:	b8 07 00 00 00       	mov    $0x7,%eax
    5fac:	89 e5                	mov    %esp,%ebp
    5fae:	8b 55 08             	mov    0x8(%ebp),%edx
    5fb1:	e8 06 ff ff ff       	call   5ebc <generic_exc_handle>

00005fb6 <handle_exc_10>:
EXC_FUNC_CODE(IV_INVALID_TSS);
    5fb6:	55                   	push   %ebp
    5fb7:	b8 0a 00 00 00       	mov    $0xa,%eax
    5fbc:	89 e5                	mov    %esp,%ebp
    5fbe:	8b 55 08             	mov    0x8(%ebp),%edx
    5fc1:	e8 f6 fe ff ff       	call   5ebc <generic_exc_handle>

00005fc6 <handle_exc_11>:
EXC_FUNC_CODE(IV_SEGMENT_NOT_PRESENT);
    5fc6:	55                   	push   %ebp
    5fc7:	b8 0b 00 00 00       	mov    $0xb,%eax
    5fcc:	89 e5                	mov    %esp,%ebp
    5fce:	8b 55 08             	mov    0x8(%ebp),%edx
    5fd1:	e8 e6 fe ff ff       	call   5ebc <generic_exc_handle>

00005fd6 <handle_exc_12>:
EXC_FUNC_CODE(IV_STACK_FAULT);
    5fd6:	55                   	push   %ebp
    5fd7:	b8 0c 00 00 00       	mov    $0xc,%eax
    5fdc:	89 e5                	mov    %esp,%ebp
    5fde:	8b 55 08             	mov    0x8(%ebp),%edx
    5fe1:	e8 d6 fe ff ff       	call   5ebc <generic_exc_handle>

00005fe6 <handle_exc_13>:
EXC_FUNC_CODE(IV_GENERAL_PROTECTION);
    5fe6:	55                   	push   %ebp
    5fe7:	b8 0d 00 00 00       	mov    $0xd,%eax
    5fec:	89 e5                	mov    %esp,%ebp
    5fee:	8b 55 08             	mov    0x8(%ebp),%edx
    5ff1:	e8 c6 fe ff ff       	call   5ebc <generic_exc_handle>

00005ff6 <handle_exc_16>:
EXC_FUNC_NOCODE(IV_X87_FPU_FP_ERROR);
    5ff6:	55                   	push   %ebp
    5ff7:	b8 10 00 00 00       	mov    $0x10,%eax
    5ffc:	89 e5                	mov    %esp,%ebp
    5ffe:	8b 55 08             	mov    0x8(%ebp),%edx
    6001:	e8 b6 fe ff ff       	call   5ebc <generic_exc_handle>

00006006 <handle_exc_17>:
EXC_FUNC_CODE(IV_ALIGNMENT_CHECK);
    6006:	55                   	push   %ebp
    6007:	b8 11 00 00 00       	mov    $0x11,%eax
    600c:	89 e5                	mov    %esp,%ebp
    600e:	8b 55 08             	mov    0x8(%ebp),%edx
    6011:	e8 a6 fe ff ff       	call   5ebc <generic_exc_handle>

00006016 <handle_exc_18>:
EXC_FUNC_NOCODE(IV_MACHINE_CHECK);
    6016:	55                   	push   %ebp
    6017:	b8 12 00 00 00       	mov    $0x12,%eax
    601c:	89 e5                	mov    %esp,%ebp
    601e:	8b 55 08             	mov    0x8(%ebp),%edx
    6021:	e8 96 fe ff ff       	call   5ebc <generic_exc_handle>

00006026 <page_fault_handler>:
{
    6026:	55                   	push   %ebp
    6027:	89 e5                	mov    %esp,%ebp
    6029:	57                   	push   %edi
    602a:	56                   	push   %esi
    602b:	53                   	push   %ebx
    602c:	83 ec 08             	sub    $0x8,%esp
    602f:	8b 75 08             	mov    0x8(%ebp),%esi
	__asm__ ("mov %%cr2, %0" : "=r" (cr2));
    6032:	0f 20 d7             	mov    %cr2,%edi
	err = pEsf->errorCode;
    6035:	8b 5e 20             	mov    0x20(%esi),%ebx
	printk("***** CPU Page Fault (error code 0x%08x)\n", err);
    6038:	53                   	push   %ebx
    6039:	68 a1 7a 00 00       	push   $0x7aa1
    603e:	e8 85 d2 ff ff       	call   32c8 <printk>
    6043:	58                   	pop    %eax
	printk("%s thread %s address 0x%08x\n",
    6044:	f6 c3 10             	test   $0x10,%bl
	printk("***** CPU Page Fault (error code 0x%08x)\n", err);
    6047:	5a                   	pop    %edx
	printk("%s thread %s address 0x%08x\n",
    6048:	b8 92 7a 00 00       	mov    $0x7a92,%eax
    604d:	75 0f                	jne    605e <page_fault_handler+0x38>
	       err & ID ? "executed" : (err & WR ? "wrote" : "read"),
    604f:	b8 9b 7a 00 00       	mov    $0x7a9b,%eax
    6054:	f6 c3 02             	test   $0x2,%bl
    6057:	75 05                	jne    605e <page_fault_handler+0x38>
    6059:	b8 bd 77 00 00       	mov    $0x77bd,%eax
	printk("%s thread %s address 0x%08x\n",
    605e:	ba 35 78 00 00       	mov    $0x7835,%edx
    6063:	80 e3 04             	and    $0x4,%bl
    6066:	75 05                	jne    606d <page_fault_handler+0x47>
    6068:	ba 3a 78 00 00       	mov    $0x783a,%edx
    606d:	57                   	push   %edi
    606e:	50                   	push   %eax
    606f:	52                   	push   %edx
    6070:	68 cb 7a 00 00       	push   $0x7acb
    6075:	e8 4e d2 ff ff       	call   32c8 <printk>
    607a:	83 c4 10             	add    $0x10,%esp
	_x86_mmu_get_flags(addr, &pde_flags, &pte_flags);
    607d:	8d 45 f0             	lea    -0x10(%ebp),%eax
    6080:	50                   	push   %eax
    6081:	8d 45 ec             	lea    -0x14(%ebp),%eax
    6084:	50                   	push   %eax
    6085:	57                   	push   %edi
    6086:	e8 8f fb ff ff       	call   5c1a <_x86_mmu_get_flags>
    608b:	83 c4 0c             	add    $0xc,%esp
	printk("PDE: ");
    608e:	68 e8 7a 00 00       	push   $0x7ae8
    6093:	e8 30 d2 ff ff       	call   32c8 <printk>
    6098:	58                   	pop    %eax
	dump_entry_flags(pde_flags);
    6099:	8b 45 ec             	mov    -0x14(%ebp),%eax
    609c:	e8 04 fc ff ff       	call   5ca5 <dump_entry_flags>
	printk("PTE: ");
    60a1:	68 ee 7a 00 00       	push   $0x7aee
    60a6:	e8 1d d2 ff ff       	call   32c8 <printk>
	dump_entry_flags(pte_flags);
    60ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
	printk("PTE: ");
    60ae:	5a                   	pop    %edx
	dump_entry_flags(pte_flags);
    60af:	e8 f1 fb ff ff       	call   5ca5 <dump_entry_flags>
	_NanoFatalErrorHandler(_NANO_ERR_CPU_EXCEPTION, pEsf);
    60b4:	56                   	push   %esi
    60b5:	6a 06                	push   $0x6
    60b7:	e8 04 fd ff ff       	call   5dc0 <_NanoFatalErrorHandler>

000060bc <_sys_device_do_config_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void _sys_device_do_config_level(int level)
{
    60bc:	55                   	push   %ebp
    60bd:	89 e5                	mov    %esp,%ebp
    60bf:	56                   	push   %esi
    60c0:	53                   	push   %ebx
    60c1:	8b 45 08             	mov    0x8(%ebp),%eax
	struct device *info;

	for (info = config_levels[level]; info < config_levels[level+1];
    60c4:	8b 1c 85 f4 7a 00 00 	mov    0x7af4(,%eax,4),%ebx
    60cb:	8d 70 01             	lea    0x1(%eax),%esi
    60ce:	3b 1c b5 f4 7a 00 00 	cmp    0x7af4(,%esi,4),%ebx
    60d5:	73 0c                	jae    60e3 <_sys_device_do_config_level+0x27>
								info++) {
		struct device_config *device = info->config;

		device->init(info);
    60d7:	8b 03                	mov    (%ebx),%eax
    60d9:	53                   	push   %ebx
								info++) {
    60da:	83 c3 0c             	add    $0xc,%ebx
		device->init(info);
    60dd:	ff 50 04             	call   *0x4(%eax)
    60e0:	58                   	pop    %eax
    60e1:	eb eb                	jmp    60ce <_sys_device_do_config_level+0x12>
	}
}
    60e3:	8d 65 f8             	lea    -0x8(%ebp),%esp
    60e6:	5b                   	pop    %ebx
    60e7:	5e                   	pop    %esi
    60e8:	5d                   	pop    %ebp
    60e9:	c3                   	ret    

000060ea <device_get_binding>:

struct device *device_get_binding(const char *name)
{
    60ea:	55                   	push   %ebp
    60eb:	89 e5                	mov    %esp,%ebp
    60ed:	53                   	push   %ebx
	struct device *info;

	for (info = __device_init_start; info != __device_init_end; info++) {
    60ee:	bb 00 50 40 00       	mov    $0x405000,%ebx
    60f3:	81 fb 9c 50 40 00    	cmp    $0x40509c,%ebx
    60f9:	74 1f                	je     611a <device_get_binding+0x30>
		if (info->driver_api && !strcmp(name, info->config->name)) {
    60fb:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
    60ff:	75 05                	jne    6106 <device_get_binding+0x1c>
	for (info = __device_init_start; info != __device_init_end; info++) {
    6101:	83 c3 0c             	add    $0xc,%ebx
    6104:	eb ed                	jmp    60f3 <device_get_binding+0x9>
		if (info->driver_api && !strcmp(name, info->config->name)) {
    6106:	8b 03                	mov    (%ebx),%eax
    6108:	ff 30                	pushl  (%eax)
    610a:	ff 75 08             	pushl  0x8(%ebp)
    610d:	e8 3e bf ff ff       	call   2050 <strcmp>
    6112:	5a                   	pop    %edx
    6113:	85 c0                	test   %eax,%eax
    6115:	59                   	pop    %ecx
    6116:	75 e9                	jne    6101 <device_get_binding+0x17>
    6118:	eb 02                	jmp    611c <device_get_binding+0x32>
			return info;
		}
	}

	return NULL;
    611a:	31 db                	xor    %ebx,%ebx
}
    611c:	89 d8                	mov    %ebx,%eax
    611e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6121:	c9                   	leave  
    6122:	c3                   	ret    

00006123 <__errno>:
 */
const int _k_neg_eagain = -EAGAIN;

#ifdef CONFIG_ERRNO
int *__errno(void)
{
    6123:	55                   	push   %ebp
	return &_current->errno_var;
    6124:	a1 c8 54 40 00       	mov    0x4054c8,%eax
{
    6129:	89 e5                	mov    %esp,%ebp
	return &_current->errno_var;
    612b:	83 c0 34             	add    $0x34,%eax
}
    612e:	5d                   	pop    %ebp
    612f:	c3                   	ret    

00006130 <_main>:
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void _main(void *unused1, void *unused2, void *unused3)
{
    6130:	55                   	push   %ebp
    6131:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(unused1);
	ARG_UNUSED(unused2);
	ARG_UNUSED(unused3);

	_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
    6133:	6a 02                	push   $0x2
    6135:	e8 82 ff ff ff       	call   60bc <_sys_device_do_config_level>

	/* Final init level before app starts */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
    613a:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
    6141:	e8 76 ff ff ff       	call   60bc <_sys_device_do_config_level>
    6146:	58                   	pop    %eax
		printk("***** delaying boot " STRINGIFY(CONFIG_BOOT_DELAY)
		       "ms (per build configuration) *****\n");
		k_sleep(CONFIG_BOOT_DELAY);
	}
	PRINT_BOOT_BANNER();
	_init_static_threads();
    6147:	e8 15 11 00 00       	call   7261 <_init_static_threads>
	__main_time_stamp = (u64_t)k_cycle_get_32();
#endif

	extern void main(void);

	main();
    614c:	e8 a8 b0 ff ff       	call   11f9 <main>

	/* Terminate thread normally since it has no more work to do */
	_main_thread->base.user_options &= ~K_ESSENTIAL;
    6151:	80 25 88 54 40 00 fe 	andb   $0xfe,0x405488
}
    6158:	c9                   	leave  
    6159:	c3                   	ret    

0000615a <_Cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void _Cstart(void)
{
    615a:	55                   	push   %ebp
    615b:	89 e5                	mov    %esp,%ebp
    615d:	53                   	push   %ebx
    615e:	83 ec 38             	sub    $0x38,%esp
	_current = dummy_thread;
    6161:	8d 45 c4             	lea    -0x3c(%ebp),%eax
	dummy_thread->base.user_options = K_ESSENTIAL;
    6164:	c6 45 cc 01          	movb   $0x1,-0x34(%ebp)
	_current = dummy_thread;
    6168:	a3 c8 54 40 00       	mov    %eax,0x4054c8
	dummy_thread->base.thread_state = _THREAD_DUMMY;
    616d:	c6 45 cd 01          	movb   $0x1,-0x33(%ebp)
    6171:	b8 1c 00 00 00       	mov    $0x1c,%eax
    6176:	8d 90 c0 54 40 00    	lea    0x4054c0(%eax),%edx
    617c:	83 c0 08             	add    $0x8,%eax
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
    617f:	89 90 b8 54 40 00    	mov    %edx,0x4054b8(%eax)
	list->tail = (sys_dnode_t *)list;
    6185:	89 90 bc 54 40 00    	mov    %edx,0x4054bc(%eax)
	for (int ii = 0; ii < K_NUM_PRIORITIES; ii++) {
    618b:	3d 1c 01 00 00       	cmp    $0x11c,%eax
    6190:	75 e4                	jne    6176 <_Cstart+0x1c>
	_new_thread(_main_thread, _main_stack,
    6192:	6a 01                	push   $0x1
    6194:	6a 00                	push   $0x0
    6196:	6a 00                	push   $0x0
    6198:	6a 00                	push   $0x0
    619a:	6a 00                	push   $0x0
    619c:	68 30 61 00 00       	push   $0x6130
    61a1:	68 00 10 00 00       	push   $0x1000
    61a6:	68 00 00 41 00       	push   $0x410000
    61ab:	68 80 54 40 00       	push   $0x405480
	_ready_q.cache = _main_thread;
    61b0:	c7 05 d4 54 40 00 80 	movl   $0x405480,0x4054d4
    61b7:	54 40 00 
	_new_thread(_main_thread, _main_stack,
    61ba:	e8 db f9 ff ff       	call   5b9a <_new_thread>
    61bf:	83 c4 24             	add    $0x24,%esp
	_add_thread_to_ready_q(_main_thread);
    61c2:	68 80 54 40 00       	push   $0x405480
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
    61c7:	80 25 89 54 40 00 fb 	andb   $0xfb,0x405489
    61ce:	e8 5c 07 00 00       	call   692f <_add_thread_to_ready_q>
	_new_thread(_idle_thread, _idle_stack,
    61d3:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
    61da:	6a 0f                	push   $0xf
    61dc:	6a 00                	push   $0x0
    61de:	6a 00                	push   $0x0
    61e0:	6a 00                	push   $0x0
    61e2:	68 4b 73 00 00       	push   $0x734b
    61e7:	68 00 01 00 00       	push   $0x100
    61ec:	68 00 e0 40 00       	push   $0x40e000
    61f1:	68 40 54 40 00       	push   $0x405440
    61f6:	e8 9f f9 ff ff       	call   5b9a <_new_thread>
    61fb:	83 c4 24             	add    $0x24,%esp
	_add_thread_to_ready_q(_idle_thread);
    61fe:	68 40 54 40 00       	push   $0x405440
    6203:	80 25 49 54 40 00 fb 	andb   $0xfb,0x405449
    620a:	e8 20 07 00 00       	call   692f <_add_thread_to_ready_q>
{
	_kernel.nested = 0;
	_kernel.irq_stack = K_THREAD_STACK_BUFFER(_interrupt_stack) +
				CONFIG_ISR_STACK_SIZE;
#if CONFIG_X86_STACK_PROTECTION
	_x86_mmu_set_flags(_interrupt_stack, MMU_PAGE_SIZE,
    620f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
    6216:	6a 00                	push   $0x0
    6218:	68 00 10 00 00       	push   $0x1000
    621d:	68 00 20 41 00       	push   $0x412000
	list->head = (sys_dnode_t *)list;
    6222:	c7 05 cc 54 40 00 cc 	movl   $0x4054cc,0x4054cc
    6229:	54 40 00 
	list->tail = (sys_dnode_t *)list;
    622c:	c7 05 d0 54 40 00 cc 	movl   $0x4054cc,0x4054d0
    6233:	54 40 00 
	_kernel.nested = 0;
    6236:	c7 05 c0 54 40 00 00 	movl   $0x0,0x4054c0
    623d:	00 00 00 
	_kernel.irq_stack = K_THREAD_STACK_BUFFER(_interrupt_stack) +
    6240:	c7 05 c4 54 40 00 00 	movl   $0x413800,0x4054c4
    6247:	38 41 00 
	_x86_mmu_set_flags(_interrupt_stack, MMU_PAGE_SIZE,
    624a:	e8 09 fa ff ff       	call   5c58 <_x86_mmu_set_flags>
    624f:	83 c4 10             	add    $0x10,%esp
	 */

	prepare_multithreading(dummy_thread);

	/* perform basic hardware initialization */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
    6252:	6a 00                	push   $0x0
    6254:	e8 63 fe ff ff       	call   60bc <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
    6259:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
    6260:	e8 57 fe ff ff       	call   60bc <_sys_device_do_config_level>
    6265:	58                   	pop    %eax
	__asm__ volatile (
    6266:	9c                   	pushf  
    6267:	fa                   	cli    
    6268:	5b                   	pop    %ebx

#ifdef CONFIG_STACK_SENTINEL
	_check_stack_sentinel();
#endif
#ifdef CONFIG_TIMESLICING
	_update_time_slice_before_swap();
    6269:	e8 67 0a 00 00       	call   6cd5 <_update_time_slice_before_swap>
#endif

	return __swap(key);
    626e:	53                   	push   %ebx
    626f:	e8 fd f8 ff ff       	call   5b71 <__swap>
    6274:	5a                   	pop    %edx

00006275 <init_mem_slab_module>:
{
	ARG_UNUSED(dev);

	struct k_mem_slab *slab;

	for (slab = _k_mem_slab_list_start;
    6275:	b8 9c 50 40 00       	mov    $0x40509c,%eax
    627a:	3d d4 50 40 00       	cmp    $0x4050d4,%eax
    627f:	72 03                	jb     6284 <init_mem_slab_module+0xf>
	     slab++) {
		create_free_list(slab);
		SYS_TRACING_OBJ_INIT(k_mem_slab, slab);
	}
	return 0;
}
    6281:	31 c0                	xor    %eax,%eax
    6283:	c3                   	ret    
{
    6284:	55                   	push   %ebp
    6285:	89 e5                	mov    %esp,%ebp
    6287:	56                   	push   %esi
    6288:	53                   	push   %ebx
	slab->free_list = NULL;
    6289:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	p = slab->buffer;
    6290:	8b 50 10             	mov    0x10(%eax),%edx
	for (j = 0; j < slab->num_blocks; j++) {
    6293:	8b 58 08             	mov    0x8(%eax),%ebx
    6296:	31 c9                	xor    %ecx,%ecx
    6298:	39 d9                	cmp    %ebx,%ecx
    629a:	74 0e                	je     62aa <init_mem_slab_module+0x35>
		*(char **)p = slab->free_list;
    629c:	8b 70 14             	mov    0x14(%eax),%esi
	for (j = 0; j < slab->num_blocks; j++) {
    629f:	41                   	inc    %ecx
		*(char **)p = slab->free_list;
    62a0:	89 32                	mov    %esi,(%edx)
		slab->free_list = p;
    62a2:	89 50 14             	mov    %edx,0x14(%eax)
		p += slab->block_size;
    62a5:	03 50 0c             	add    0xc(%eax),%edx
    62a8:	eb ee                	jmp    6298 <init_mem_slab_module+0x23>
	     slab++) {
    62aa:	83 c0 1c             	add    $0x1c,%eax
	for (slab = _k_mem_slab_list_start;
    62ad:	3d d4 50 40 00       	cmp    $0x4050d4,%eax
    62b2:	72 d5                	jb     6289 <init_mem_slab_module+0x14>
}
    62b4:	5b                   	pop    %ebx
    62b5:	31 c0                	xor    %eax,%eax
    62b7:	5e                   	pop    %esi
    62b8:	5d                   	pop    %ebp
    62b9:	c3                   	ret    

000062ba <k_mem_slab_alloc>:
	sys_dlist_init(&slab->wait_q);
	SYS_TRACING_OBJ_INIT(k_mem_slab, slab);
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, s32_t timeout)
{
    62ba:	55                   	push   %ebp
    62bb:	89 e5                	mov    %esp,%ebp
    62bd:	56                   	push   %esi
    62be:	53                   	push   %ebx
    62bf:	8b 45 08             	mov    0x8(%ebp),%eax
    62c2:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    62c5:	8b 55 10             	mov    0x10(%ebp),%edx
    62c8:	9c                   	pushf  
    62c9:	fa                   	cli    
    62ca:	5e                   	pop    %esi
	unsigned int key = irq_lock();
	int result;

	if (slab->free_list != NULL) {
    62cb:	8b 48 14             	mov    0x14(%eax),%ecx
    62ce:	85 c9                	test   %ecx,%ecx
    62d0:	74 11                	je     62e3 <k_mem_slab_alloc+0x29>
		/* take a free block */
		*mem = slab->free_list;
    62d2:	89 0b                	mov    %ecx,(%ebx)
		slab->free_list = *(char **)(slab->free_list);
    62d4:	8b 50 14             	mov    0x14(%eax),%edx
    62d7:	8b 12                	mov    (%edx),%edx
		slab->num_used++;
    62d9:	ff 40 18             	incl   0x18(%eax)
		slab->free_list = *(char **)(slab->free_list);
    62dc:	89 50 14             	mov    %edx,0x14(%eax)
		result = 0;
    62df:	31 c0                	xor    %eax,%eax
    62e1:	eb 37                	jmp    631a <k_mem_slab_alloc+0x60>
	} else if (timeout == K_NO_WAIT) {
    62e3:	85 d2                	test   %edx,%edx
    62e5:	75 0d                	jne    62f4 <k_mem_slab_alloc+0x3a>
		/* don't wait for a free block to become available */
		*mem = NULL;
    62e7:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
		result = -ENOMEM;
    62ed:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
    62f2:	eb 26                	jmp    631a <k_mem_slab_alloc+0x60>
	} else {
		/* wait for a free block or timeout */
		_pend_current_thread(&slab->wait_q, timeout);
    62f4:	52                   	push   %edx
    62f5:	50                   	push   %eax
    62f6:	e8 63 08 00 00       	call   6b5e <_pend_current_thread>
    62fb:	58                   	pop    %eax
    62fc:	5a                   	pop    %edx
	_update_time_slice_before_swap();
    62fd:	e8 d3 09 00 00       	call   6cd5 <_update_time_slice_before_swap>
	return __swap(key);
    6302:	56                   	push   %esi
    6303:	e8 69 f8 ff ff       	call   5b71 <__swap>
    6308:	59                   	pop    %ecx
		result = _Swap(key);
		if (result == 0) {
    6309:	85 c0                	test   %eax,%eax
    630b:	75 14                	jne    6321 <k_mem_slab_alloc+0x67>
			*mem = _current->base.swap_data;
    630d:	8b 15 c8 54 40 00    	mov    0x4054c8,%edx
    6313:	8b 52 0c             	mov    0xc(%edx),%edx
    6316:	89 13                	mov    %edx,(%ebx)
    6318:	eb 07                	jmp    6321 <k_mem_slab_alloc+0x67>
    631a:	0f ba e6 09          	bt     $0x9,%esi
    631e:	73 01                	jae    6321 <k_mem_slab_alloc+0x67>
	__asm__ volatile (
    6320:	fb                   	sti    
	}

	irq_unlock(key);

	return result;
}
    6321:	8d 65 f8             	lea    -0x8(%ebp),%esp
    6324:	5b                   	pop    %ebx
    6325:	5e                   	pop    %esi
    6326:	5d                   	pop    %ebp
    6327:	c3                   	ret    

00006328 <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
    6328:	55                   	push   %ebp
    6329:	89 e5                	mov    %esp,%ebp
    632b:	56                   	push   %esi
    632c:	53                   	push   %ebx
    632d:	8b 55 08             	mov    0x8(%ebp),%edx
    6330:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	__asm__ volatile (
    6333:	9c                   	pushf  
    6334:	fa                   	cli    
    6335:	5b                   	pop    %ebx
_find_first_thread_to_unpend(_wait_q_t *wait_q, struct k_thread *from)
{
#ifdef CONFIG_SYS_CLOCK_EXISTS
	extern volatile int _handling_timeouts;

	if (_handling_timeouts) {
    6336:	a1 e8 55 40 00       	mov    0x4055e8,%eax
    633b:	85 c0                	test   %eax,%eax
    633d:	8b 02                	mov    (%edx),%eax
    633f:	74 22                	je     6363 <k_mem_slab_free+0x3b>
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
    6341:	39 c2                	cmp    %eax,%edx
    6343:	75 15                	jne    635a <k_mem_slab_free+0x32>
    6345:	31 c0                	xor    %eax,%eax
    6347:	eb 11                	jmp    635a <k_mem_slab_free+0x32>

		/* skip threads that have an expired timeout */
		SYS_DLIST_ITERATE_FROM_NODE(q, cur) {
			struct k_thread *thread = (struct k_thread *)cur;

			if (_is_thread_timeout_expired(thread)) {
    6349:	83 78 20 fe          	cmpl   $0xfffffffe,0x20(%eax)
    634d:	75 24                	jne    6373 <k_mem_slab_free+0x4b>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
    634f:	3b 42 04             	cmp    0x4(%edx),%eax
    6352:	0f 84 9b 00 00 00    	je     63f3 <k_mem_slab_free+0xcb>
    6358:	8b 00                	mov    (%eax),%eax
		SYS_DLIST_ITERATE_FROM_NODE(q, cur) {
    635a:	85 c0                	test   %eax,%eax
    635c:	75 eb                	jne    6349 <k_mem_slab_free+0x21>
    635e:	e9 90 00 00 00       	jmp    63f3 <k_mem_slab_free+0xcb>
/* must be called with interrupts locked */
static inline struct k_thread *_unpend_first_thread(_wait_q_t *wait_q)
{
	struct k_thread *thread = _find_first_thread_to_unpend(wait_q, NULL);

	if (thread) {
    6363:	85 c0                	test   %eax,%eax
    6365:	0f 84 88 00 00 00    	je     63f3 <k_mem_slab_free+0xcb>
    636b:	39 c2                	cmp    %eax,%edx
    636d:	0f 84 80 00 00 00    	je     63f3 <k_mem_slab_free+0xcb>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
    6373:	8b 50 04             	mov    0x4(%eax),%edx
    6376:	8b 30                	mov    (%eax),%esi
    6378:	89 32                	mov    %esi,(%edx)
	node->next->prev = node->prev;
    637a:	8b 30                	mov    (%eax),%esi
    637c:	89 56 04             	mov    %edx,0x4(%esi)
	thread->base.thread_state &= ~_THREAD_PENDING;
    637f:	80 60 09 fd          	andb   $0xfd,0x9(%eax)
	int key = irq_lock();
	struct k_thread *pending_thread = _unpend_first_thread(&slab->wait_q);

	if (pending_thread) {
		_set_thread_return_value_with_data(pending_thread, 0, *mem);
    6383:	8b 11                	mov    (%ecx),%edx
static ALWAYS_INLINE void
_set_thread_return_value(struct k_thread *thread, unsigned int value)
{
	/* write into 'eax' slot created in _Swap() entry */

	*(unsigned int *)(thread->callee_saved.esp) = value;
    6385:	8b 48 28             	mov    0x28(%eax),%ecx
    6388:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
	thread->base.swap_data = data;
    638e:	89 50 0c             	mov    %edx,0xc(%eax)
}

/* returns _INACTIVE if the timer is not active */
static inline int _abort_timeout(struct _timeout *timeout)
{
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
    6391:	8b 48 20             	mov    0x20(%eax),%ecx
}

/* returns _INACTIVE if the timer has already expired */
static inline int _abort_thread_timeout(struct k_thread *thread)
{
	return _abort_timeout(&thread->base.timeout);
    6394:	8d 50 10             	lea    0x10(%eax),%edx
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
    6397:	83 f9 ff             	cmp    $0xffffffff,%ecx
    639a:	74 23                	je     63bf <k_mem_slab_free+0x97>
	if (!sys_dlist_is_tail(&_timeout_q, &timeout->node)) {
    639c:	3b 15 d0 54 40 00    	cmp    0x4054d0,%edx
    63a2:	74 06                	je     63aa <k_mem_slab_free+0x82>
	return (node == list->tail) ? NULL : node->next;
    63a4:	8b 50 10             	mov    0x10(%eax),%edx
		next->delta_ticks_from_prev += timeout->delta_ticks_from_prev;
    63a7:	01 4a 10             	add    %ecx,0x10(%edx)
	node->prev->next = node->next;
    63aa:	8b 50 14             	mov    0x14(%eax),%edx
    63ad:	8b 48 10             	mov    0x10(%eax),%ecx
    63b0:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
    63b2:	8b 48 10             	mov    0x10(%eax),%ecx
    63b5:	89 51 04             	mov    %edx,0x4(%ecx)
	timeout->delta_ticks_from_prev = _INACTIVE;
    63b8:	c7 40 20 ff ff ff ff 	movl   $0xffffffff,0x20(%eax)
	thread->base.thread_state &= ~_THREAD_PRESTART;
    63bf:	8a 50 09             	mov    0x9(%eax),%dl
    63c2:	88 d1                	mov    %dl,%cl
    63c4:	83 e1 fb             	and    $0xfffffffb,%ecx
	return !(_is_thread_prevented_from_running(thread) ||
    63c7:	80 e2 1b             	and    $0x1b,%dl
	thread->base.thread_state &= ~_THREAD_PRESTART;
    63ca:	88 48 09             	mov    %cl,0x9(%eax)
	return !(_is_thread_prevented_from_running(thread) ||
    63cd:	75 06                	jne    63d5 <k_mem_slab_free+0xad>
    63cf:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
    63d3:	74 2f                	je     6404 <k_mem_slab_free+0xdc>
	return _is_preempt(_current) && __must_switch_threads();
    63d5:	a1 c8 54 40 00       	mov    0x4054c8,%eax
    63da:	66 83 78 0a 7f       	cmpw   $0x7f,0xa(%eax)
    63df:	77 09                	ja     63ea <k_mem_slab_free+0xc2>
    63e1:	e8 9d 07 00 00       	call   6b83 <__must_switch_threads>
    63e6:	85 c0                	test   %eax,%eax
    63e8:	75 23                	jne    640d <k_mem_slab_free+0xe5>
    63ea:	0f ba e3 09          	bt     $0x9,%ebx
    63ee:	73 30                	jae    6420 <k_mem_slab_free+0xf8>
	__asm__ volatile (
    63f0:	fb                   	sti    
    63f1:	eb 2d                	jmp    6420 <k_mem_slab_free+0xf8>
		if (_must_switch_threads()) {
			_Swap(key);
			return;
		}
	} else {
		**(char ***)mem = slab->free_list;
    63f3:	8b 01                	mov    (%ecx),%eax
    63f5:	8b 72 14             	mov    0x14(%edx),%esi
    63f8:	89 30                	mov    %esi,(%eax)
		slab->free_list = *(char **)mem;
    63fa:	8b 01                	mov    (%ecx),%eax
		slab->num_used--;
    63fc:	ff 4a 18             	decl   0x18(%edx)
		slab->free_list = *(char **)mem;
    63ff:	89 42 14             	mov    %eax,0x14(%edx)
    6402:	eb e6                	jmp    63ea <k_mem_slab_free+0xc2>
		_add_thread_to_ready_q(thread);
    6404:	50                   	push   %eax
    6405:	e8 25 05 00 00       	call   692f <_add_thread_to_ready_q>
    640a:	58                   	pop    %eax
    640b:	eb c8                	jmp    63d5 <k_mem_slab_free+0xad>
	_update_time_slice_before_swap();
    640d:	e8 c3 08 00 00       	call   6cd5 <_update_time_slice_before_swap>
	return __swap(key);
    6412:	89 5d 08             	mov    %ebx,0x8(%ebp)
	}

	irq_unlock(key);
}
    6415:	8d 65 f8             	lea    -0x8(%ebp),%esp
    6418:	5b                   	pop    %ebx
    6419:	5e                   	pop    %esi
    641a:	5d                   	pop    %ebp
    641b:	e9 51 f7 ff ff       	jmp    5b71 <__swap>
    6420:	8d 65 f8             	lea    -0x8(%ebp),%esp
    6423:	5b                   	pop    %ebx
    6424:	5e                   	pop    %esi
    6425:	5d                   	pop    %ebp
    6426:	c3                   	ret    

00006427 <sys_dlist_remove>:
{
    6427:	55                   	push   %ebp
	node->prev->next = node->next;
    6428:	8b 50 04             	mov    0x4(%eax),%edx
    642b:	8b 08                	mov    (%eax),%ecx
{
    642d:	89 e5                	mov    %esp,%ebp
	node->prev->next = node->next;
    642f:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
    6431:	8b 00                	mov    (%eax),%eax
    6433:	89 50 04             	mov    %edx,0x4(%eax)
}
    6436:	5d                   	pop    %ebp
    6437:	c3                   	ret    

00006438 <clear_event_registrations>:

/* must be called with interrupts locked */
static inline void clear_event_registrations(struct k_poll_event *events,
					      int last_registered,
					      unsigned int key)
{
    6438:	55                   	push   %ebp
    6439:	89 e5                	mov    %esp,%ebp
    643b:	57                   	push   %edi
    643c:	56                   	push   %esi
    643d:	53                   	push   %ebx
    643e:	6b da 14             	imul   $0x14,%edx,%ebx
    6441:	89 d6                	mov    %edx,%esi
    6443:	89 cf                	mov    %ecx,%edi
    6445:	01 c3                	add    %eax,%ebx
	for (; last_registered >= 0; last_registered--) {
    6447:	85 f6                	test   %esi,%esi
    6449:	78 30                	js     647b <clear_event_registrations+0x43>
	switch (event->type) {
    644b:	8a 43 0d             	mov    0xd(%ebx),%al
	event->poller = NULL;
    644e:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	switch (event->type) {
    6455:	83 e0 0f             	and    $0xf,%eax
    6458:	3c 02                	cmp    $0x2,%al
    645a:	74 08                	je     6464 <clear_event_registrations+0x2c>
    645c:	3c 04                	cmp    $0x4,%al
    645e:	74 04                	je     6464 <clear_event_registrations+0x2c>
    6460:	fe c8                	dec    %al
    6462:	75 07                	jne    646b <clear_event_registrations+0x33>
		sys_dlist_remove(&event->_node);
    6464:	89 d8                	mov    %ebx,%eax
    6466:	e8 bc ff ff ff       	call   6427 <sys_dlist_remove>
    646b:	0f ba e7 09          	bt     $0x9,%edi
    646f:	73 01                	jae    6472 <clear_event_registrations+0x3a>
    6471:	fb                   	sti    
	__asm__ volatile (
    6472:	9c                   	pushf  
    6473:	fa                   	cli    
    6474:	5f                   	pop    %edi
	for (; last_registered >= 0; last_registered--) {
    6475:	4e                   	dec    %esi
    6476:	83 eb 14             	sub    $0x14,%ebx
    6479:	eb cc                	jmp    6447 <clear_event_registrations+0xf>
		clear_event_registration(&events[last_registered]);
		irq_unlock(key);
		key = irq_lock();
	}
}
    647b:	5b                   	pop    %ebx
    647c:	5e                   	pop    %esi
    647d:	5f                   	pop    %edi
    647e:	5d                   	pop    %ebp
    647f:	c3                   	ret    

00006480 <_signal_poll_event>:
}

/* must be called with interrupts locked */
static int _signal_poll_event(struct k_poll_event *event, u32_t state,
			      int *must_reschedule)
{
    6480:	55                   	push   %ebp
    6481:	89 e5                	mov    %esp,%ebp
    6483:	57                   	push   %edi
    6484:	56                   	push   %esi
    6485:	53                   	push   %ebx
    6486:	53                   	push   %ebx
    6487:	89 c6                	mov    %eax,%esi
	*must_reschedule = 0;

	if (!event->poller) {
    6489:	8b 40 08             	mov    0x8(%eax),%eax
{
    648c:	89 55 f0             	mov    %edx,-0x10(%ebp)
	*must_reschedule = 0;
    648f:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
	if (!event->poller) {
    6495:	85 c0                	test   %eax,%eax
    6497:	0f 84 9e 00 00 00    	je     653b <_signal_poll_event+0xbb>
		goto ready_event;
	}

	struct k_thread *thread = event->poller->thread;
    649d:	8b 18                	mov    (%eax),%ebx
	thread->base.thread_state &= ~states;
    649f:	8a 43 09             	mov    0x9(%ebx),%al
    64a2:	88 c2                	mov    %al,%dl
    64a4:	83 e2 df             	and    $0xffffffdf,%edx

	__ASSERT(event->poller->thread, "poller should have a thread\n");

	clear_polling_state(thread);

	if (!_is_thread_pending(thread)) {
    64a7:	a8 02                	test   $0x2,%al
    64a9:	88 53 09             	mov    %dl,0x9(%ebx)
    64ac:	0f 84 89 00 00 00    	je     653b <_signal_poll_event+0xbb>
		goto ready_event;
	}

	if (_is_thread_timeout_expired(thread)) {
		return -EAGAIN;
    64b2:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
	if (_is_thread_timeout_expired(thread)) {
    64b7:	83 7b 20 fe          	cmpl   $0xfffffffe,0x20(%ebx)
    64bb:	0f 84 99 00 00 00    	je     655a <_signal_poll_event+0xda>
	sys_dlist_remove(&thread->base.k_q_node);
    64c1:	89 d8                	mov    %ebx,%eax
    64c3:	89 cf                	mov    %ecx,%edi
    64c5:	e8 5d ff ff ff       	call   6427 <sys_dlist_remove>
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
    64ca:	8b 4b 20             	mov    0x20(%ebx),%ecx
	thread->base.thread_state &= ~_THREAD_PENDING;
    64cd:	80 63 09 fd          	andb   $0xfd,0x9(%ebx)
	return _abort_timeout(&thread->base.timeout);
    64d1:	8d 43 10             	lea    0x10(%ebx),%eax
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
    64d4:	83 f9 ff             	cmp    $0xffffffff,%ecx
    64d7:	74 1a                	je     64f3 <_signal_poll_event+0x73>
	if (!sys_dlist_is_tail(&_timeout_q, &timeout->node)) {
    64d9:	3b 05 d0 54 40 00    	cmp    0x4054d0,%eax
    64df:	74 06                	je     64e7 <_signal_poll_event+0x67>
	return (node == list->tail) ? NULL : node->next;
    64e1:	8b 53 10             	mov    0x10(%ebx),%edx
		next->delta_ticks_from_prev += timeout->delta_ticks_from_prev;
    64e4:	01 4a 10             	add    %ecx,0x10(%edx)
	sys_dlist_remove(&timeout->node);
    64e7:	e8 3b ff ff ff       	call   6427 <sys_dlist_remove>
	timeout->delta_ticks_from_prev = _INACTIVE;
    64ec:	c7 43 20 ff ff ff ff 	movl   $0xffffffff,0x20(%ebx)
	}

	_unpend_thread(thread);
	_abort_thread_timeout(thread);
	_set_thread_return_value(thread,
    64f3:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
    64f7:	19 c0                	sbb    %eax,%eax
    64f9:	8b 53 28             	mov    0x28(%ebx),%edx
    64fc:	83 e0 fc             	and    $0xfffffffc,%eax
    64ff:	89 02                	mov    %eax,(%edx)
	return !(_is_thread_prevented_from_running(thread) ||
    6501:	f6 43 09 1f          	testb  $0x1f,0x9(%ebx)
    6505:	75 34                	jne    653b <_signal_poll_event+0xbb>
    6507:	83 7b 20 ff          	cmpl   $0xffffffff,0x20(%ebx)
    650b:	75 2e                	jne    653b <_signal_poll_event+0xbb>

	if (!_is_thread_ready(thread)) {
		goto ready_event;
	}

	_add_thread_to_ready_q(thread);
    650d:	53                   	push   %ebx
    650e:	e8 1c 04 00 00       	call   692f <_add_thread_to_ready_q>
    6513:	58                   	pop    %eax
	*must_reschedule = !_is_in_isr() && _must_switch_threads();
    6514:	31 c0                	xor    %eax,%eax
    6516:	83 3d c0 54 40 00 00 	cmpl   $0x0,0x4054c0
    651d:	75 1a                	jne    6539 <_signal_poll_event+0xb9>
	return _is_preempt(_current) && __must_switch_threads();
    651f:	8b 15 c8 54 40 00    	mov    0x4054c8,%edx
    6525:	66 83 7a 0a 7f       	cmpw   $0x7f,0xa(%edx)
    652a:	77 0d                	ja     6539 <_signal_poll_event+0xb9>
    652c:	e8 52 06 00 00       	call   6b83 <__must_switch_threads>
    6531:	85 c0                	test   %eax,%eax
    6533:	0f 95 c0             	setne  %al
    6536:	0f b6 c0             	movzbl %al,%eax
    6539:	89 07                	mov    %eax,(%edi)
	event->state |= state;
    653b:	8a 46 0d             	mov    0xd(%esi),%al
	event->poller = NULL;
    653e:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
	event->state |= state;
    6545:	88 c2                	mov    %al,%dl
    6547:	83 e0 0f             	and    $0xf,%eax
    654a:	c0 ea 04             	shr    $0x4,%dl
    654d:	0b 55 f0             	or     -0x10(%ebp),%edx
    6550:	c1 e2 04             	shl    $0x4,%edx
    6553:	09 d0                	or     %edx,%eax
    6555:	88 46 0d             	mov    %al,0xd(%esi)

ready_event:
	set_event_ready(event, state);
	return 0;
    6558:	31 c0                	xor    %eax,%eax
}
    655a:	8d 65 f4             	lea    -0xc(%ebp),%esp
    655d:	5b                   	pop    %ebx
    655e:	5e                   	pop    %esi
    655f:	5f                   	pop    %edi
    6560:	5d                   	pop    %ebp
    6561:	c3                   	ret    

00006562 <add_event>:
{
    6562:	55                   	push   %ebp
    6563:	89 e5                	mov    %esp,%ebp
    6565:	57                   	push   %edi
    6566:	56                   	push   %esi
    6567:	53                   	push   %ebx
    6568:	53                   	push   %ebx
	return list->head == list;
    6569:	8b 38                	mov    (%eax),%edi
	return sys_dlist_is_empty(list) ? NULL : list->tail;
    656b:	39 f8                	cmp    %edi,%eax
    656d:	74 1d                	je     658c <add_event+0x2a>
    656f:	8b 70 04             	mov    0x4(%eax),%esi
    6572:	89 75 f0             	mov    %esi,-0x10(%ebp)
	if (!pending || _is_t1_higher_prio_than_t2(pending->poller->thread,
    6575:	85 f6                	test   %esi,%esi
    6577:	74 13                	je     658c <add_event+0x2a>
    6579:	8b 09                	mov    (%ecx),%ecx
    657b:	8a 49 0a             	mov    0xa(%ecx),%cl
    657e:	88 cb                	mov    %cl,%bl
    6580:	8b 4e 08             	mov    0x8(%esi),%ecx
    6583:	8b 31                	mov    (%ecx),%esi
    6585:	89 f9                	mov    %edi,%ecx
    6587:	38 5e 0a             	cmp    %bl,0xa(%esi)
    658a:	7d 15                	jge    65a1 <add_event+0x3f>
	node->next = list;
    658c:	89 02                	mov    %eax,(%edx)
	node->prev = list->tail;
    658e:	8b 48 04             	mov    0x4(%eax),%ecx
    6591:	89 4a 04             	mov    %ecx,0x4(%edx)
    6594:	eb 33                	jmp    65c9 <add_event+0x67>
	return (node == list->tail) ? NULL : node->next;
    6596:	3b 4d f0             	cmp    -0x10(%ebp),%ecx
    6599:	74 26                	je     65c1 <add_event+0x5f>
    659b:	8b 09                	mov    (%ecx),%ecx
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
    659d:	85 c9                	test   %ecx,%ecx
    659f:	74 20                	je     65c1 <add_event+0x5f>
    65a1:	85 c9                	test   %ecx,%ecx
    65a3:	74 1c                	je     65c1 <add_event+0x5f>
		if (_is_t1_higher_prio_than_t2(poller->thread,
    65a5:	8b 71 08             	mov    0x8(%ecx),%esi
    65a8:	8b 36                	mov    (%esi),%esi
    65aa:	3a 5e 0a             	cmp    0xa(%esi),%bl
    65ad:	7d e7                	jge    6596 <add_event+0x34>
		node->prev = insert_point->prev;
    65af:	8b 41 04             	mov    0x4(%ecx),%eax
		node->next = insert_point;
    65b2:	89 0a                	mov    %ecx,(%edx)
		node->prev = insert_point->prev;
    65b4:	89 42 04             	mov    %eax,0x4(%edx)
		insert_point->prev->next = node;
    65b7:	8b 41 04             	mov    0x4(%ecx),%eax
    65ba:	89 10                	mov    %edx,(%eax)
		insert_point->prev = node;
    65bc:	89 51 04             	mov    %edx,0x4(%ecx)
    65bf:	eb 10                	jmp    65d1 <add_event+0x6f>
	node->prev = list->tail;
    65c1:	8b 7d f0             	mov    -0x10(%ebp),%edi
	node->next = list;
    65c4:	89 02                	mov    %eax,(%edx)
	node->prev = list->tail;
    65c6:	89 7a 04             	mov    %edi,0x4(%edx)
	list->tail->next = node;
    65c9:	8b 48 04             	mov    0x4(%eax),%ecx
    65cc:	89 11                	mov    %edx,(%ecx)
	list->tail = node;
    65ce:	89 50 04             	mov    %edx,0x4(%eax)
}
    65d1:	58                   	pop    %eax
    65d2:	5b                   	pop    %ebx
    65d3:	5e                   	pop    %esi
    65d4:	5f                   	pop    %edi
    65d5:	5d                   	pop    %ebp
    65d6:	c3                   	ret    

000065d7 <k_poll_event_init>:
{
    65d7:	55                   	push   %ebp
    65d8:	89 e5                	mov    %esp,%ebp
    65da:	8b 45 08             	mov    0x8(%ebp),%eax
	event->state = K_POLL_STATE_NOT_READY;
    65dd:	8a 55 0c             	mov    0xc(%ebp),%dl
    65e0:	83 e2 0f             	and    $0xf,%edx
    65e3:	88 50 0d             	mov    %dl,0xd(%eax)
	event->mode = mode;
    65e6:	8a 50 0e             	mov    0xe(%eax),%dl
    65e9:	8a 4d 10             	mov    0x10(%ebp),%cl
    65ec:	83 e2 fe             	and    $0xfffffffe,%edx
    65ef:	83 e1 01             	and    $0x1,%ecx
	event->poller = NULL;
    65f2:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	event->mode = mode;
    65f9:	09 ca                	or     %ecx,%edx
    65fb:	88 50 0e             	mov    %dl,0xe(%eax)
	event->unused = 0;
    65fe:	66 83 60 0e 01       	andw   $0x1,0xe(%eax)
	event->obj = obj;
    6603:	8b 55 14             	mov    0x14(%ebp),%edx
    6606:	89 50 10             	mov    %edx,0x10(%eax)
}
    6609:	5d                   	pop    %ebp
    660a:	c3                   	ret    

0000660b <k_poll>:
{
    660b:	55                   	push   %ebp
    660c:	89 e5                	mov    %esp,%ebp
    660e:	57                   	push   %edi
    660f:	56                   	push   %esi
    6610:	53                   	push   %ebx
    6611:	83 ec 14             	sub    $0x14,%esp
    6614:	9c                   	pushf  
    6615:	fa                   	cli    
    6616:	5a                   	pop    %edx
	set_polling_state(_current);
    6617:	a1 c8 54 40 00       	mov    0x4054c8,%eax
	thread->base.thread_state |= states;
    661c:	80 48 09 20          	orb    $0x20,0x9(%eax)
    6620:	0f ba e2 09          	bt     $0x9,%edx
    6624:	73 01                	jae    6627 <k_poll+0x1c>
	__asm__ volatile (
    6626:	fb                   	sti    
	struct _poller poller = { .thread = _current };
    6627:	a1 c8 54 40 00       	mov    0x4054c8,%eax
    662c:	8b 5d 08             	mov    0x8(%ebp),%ebx
    662f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	for (int ii = 0; ii < num_events; ii++) {
    6632:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	int last_registered = -1, rc;
    6639:	83 ce ff             	or     $0xffffffff,%esi
    663c:	8d 7d e8             	lea    -0x18(%ebp),%edi
	for (int ii = 0; ii < num_events; ii++) {
    663f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6642:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6645:	7d 4e                	jge    6695 <k_poll+0x8a>
	__asm__ volatile (
    6647:	9c                   	pushf  
    6648:	fa                   	cli    
    6649:	8f 45 e0             	popl   -0x20(%ebp)
	switch (event->type) {
    664c:	8a 43 0d             	mov    0xd(%ebx),%al
    664f:	83 e0 0f             	and    $0xf,%eax
    6652:	3c 02                	cmp    $0x2,%al
    6654:	74 1a                	je     6670 <k_poll+0x65>
    6656:	3c 04                	cmp    $0x4,%al
    6658:	74 28                	je     6682 <k_poll+0x77>
    665a:	3c 01                	cmp    $0x1,%al
    665c:	0f 85 a7 00 00 00    	jne    6709 <k_poll+0xfe>
		if (event->signal->signaled) {
    6662:	8b 4b 10             	mov    0x10(%ebx),%ecx
			*state = K_POLL_STATE_SIGNALED;
    6665:	ba 01 00 00 00       	mov    $0x1,%edx
		if (event->signal->signaled) {
    666a:	83 79 08 00          	cmpl   $0x0,0x8(%ecx)
    666e:	eb 1d                	jmp    668d <k_poll+0x82>
		if (k_sem_count_get(event->sem) > 0) {
    6670:	8b 53 10             	mov    0x10(%ebx),%edx
    6673:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
    6677:	0f 85 df 00 00 00    	jne    675c <k_poll+0x151>
    667d:	e9 87 00 00 00       	jmp    6709 <k_poll+0xfe>
		if (!k_queue_is_empty(event->queue)) {
    6682:	8b 4b 10             	mov    0x10(%ebx),%ecx
			*state = K_POLL_STATE_FIFO_DATA_AVAILABLE;
    6685:	ba 04 00 00 00       	mov    $0x4,%edx
		if (!k_queue_is_empty(event->queue)) {
    668a:	83 39 00             	cmpl   $0x0,(%ecx)
		if (event->signal->signaled) {
    668d:	0f 85 ce 00 00 00    	jne    6761 <k_poll+0x156>
    6693:	eb 74                	jmp    6709 <k_poll+0xfe>
    6695:	9c                   	pushf  
    6696:	fa                   	cli    
    6697:	5b                   	pop    %ebx
	return _is_thread_polling(_current);
    6698:	8b 15 c8 54 40 00    	mov    0x4054c8,%edx
    669e:	8a 42 09             	mov    0x9(%edx),%al
	if (!is_polling()) {
    66a1:	a8 20                	test   $0x20,%al
    66a3:	75 10                	jne    66b5 <k_poll+0xaa>
		clear_event_registrations(events, last_registered, key);
    66a5:	89 d9                	mov    %ebx,%ecx
    66a7:	89 f2                	mov    %esi,%edx
    66a9:	8b 45 08             	mov    0x8(%ebp),%eax
		return 0;
    66ac:	31 ff                	xor    %edi,%edi
		clear_event_registrations(events, last_registered, key);
    66ae:	e8 85 fd ff ff       	call   6438 <clear_event_registrations>
    66b3:	eb 11                	jmp    66c6 <k_poll+0xbb>
	thread->base.thread_state &= ~states;
    66b5:	83 e0 df             	and    $0xffffffdf,%eax
    66b8:	88 42 09             	mov    %al,0x9(%edx)
	if (timeout == K_NO_WAIT) {
    66bb:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    66bf:	75 15                	jne    66d6 <k_poll+0xcb>
		return -EAGAIN;
    66c1:	bf f5 ff ff ff       	mov    $0xfffffff5,%edi
    66c6:	0f ba e3 09          	bt     $0x9,%ebx
    66ca:	0f 83 b8 00 00 00    	jae    6788 <k_poll+0x17d>
	__asm__ volatile (
    66d0:	fb                   	sti    
    66d1:	e9 b2 00 00 00       	jmp    6788 <k_poll+0x17d>
	_pend_current_thread(&wait_q, timeout);
    66d6:	ff 75 10             	pushl  0x10(%ebp)
	_wait_q_t wait_q = _WAIT_Q_INIT(&wait_q);
    66d9:	8d 45 ec             	lea    -0x14(%ebp),%eax
	_pend_current_thread(&wait_q, timeout);
    66dc:	50                   	push   %eax
	_wait_q_t wait_q = _WAIT_Q_INIT(&wait_q);
    66dd:	89 45 ec             	mov    %eax,-0x14(%ebp)
    66e0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	_pend_current_thread(&wait_q, timeout);
    66e3:	e8 76 04 00 00       	call   6b5e <_pend_current_thread>
    66e8:	58                   	pop    %eax
    66e9:	5a                   	pop    %edx
	_update_time_slice_before_swap();
    66ea:	e8 e6 05 00 00       	call   6cd5 <_update_time_slice_before_swap>
	return __swap(key);
    66ef:	53                   	push   %ebx
    66f0:	e8 7c f4 ff ff       	call   5b71 <__swap>
    66f5:	59                   	pop    %ecx
    66f6:	89 c7                	mov    %eax,%edi
	__asm__ volatile (
    66f8:	9c                   	pushf  
    66f9:	fa                   	cli    
    66fa:	5b                   	pop    %ebx
	clear_event_registrations(events, last_registered, key);
    66fb:	89 d9                	mov    %ebx,%ecx
    66fd:	89 f2                	mov    %esi,%edx
    66ff:	8b 45 08             	mov    0x8(%ebp),%eax
    6702:	e8 31 fd ff ff       	call   6438 <clear_event_registrations>
    6707:	eb bd                	jmp    66c6 <k_poll+0xbb>
		} else if (timeout != K_NO_WAIT && is_polling()) {
    6709:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    670d:	74 38                	je     6747 <k_poll+0x13c>
    670f:	8b 15 c8 54 40 00    	mov    0x4054c8,%edx
    6715:	f6 42 09 20          	testb  $0x20,0x9(%edx)
    6719:	74 2c                	je     6747 <k_poll+0x13c>
	switch (event->type) {
    671b:	3c 02                	cmp    $0x2,%al
    671d:	74 0d                	je     672c <k_poll+0x121>
    671f:	3c 04                	cmp    $0x4,%al
    6721:	74 11                	je     6734 <k_poll+0x129>
    6723:	fe c8                	dec    %al
    6725:	75 1c                	jne    6743 <k_poll+0x138>
		add_event(&event->signal->poll_events, event, poller);
    6727:	8b 43 10             	mov    0x10(%ebx),%eax
    672a:	eb 0e                	jmp    673a <k_poll+0x12f>
		add_event(&event->sem->poll_events, event, poller);
    672c:	8b 43 10             	mov    0x10(%ebx),%eax
    672f:	83 c0 10             	add    $0x10,%eax
    6732:	eb 06                	jmp    673a <k_poll+0x12f>
		add_event(&event->queue->poll_events, event, poller);
    6734:	8b 43 10             	mov    0x10(%ebx),%eax
    6737:	83 c0 08             	add    $0x8,%eax
		add_event(&event->signal->poll_events, event, poller);
    673a:	89 f9                	mov    %edi,%ecx
    673c:	89 da                	mov    %ebx,%edx
    673e:	e8 1f fe ff ff       	call   6562 <add_event>
	event->poller = poller;
    6743:	89 7b 08             	mov    %edi,0x8(%ebx)
				++last_registered;
    6746:	46                   	inc    %esi
    6747:	8b 45 e0             	mov    -0x20(%ebp),%eax
    674a:	0f ba e0 09          	bt     $0x9,%eax
    674e:	73 01                	jae    6751 <k_poll+0x146>
	__asm__ volatile (
    6750:	fb                   	sti    
	for (int ii = 0; ii < num_events; ii++) {
    6751:	ff 45 e4             	incl   -0x1c(%ebp)
    6754:	83 c3 14             	add    $0x14,%ebx
    6757:	e9 e3 fe ff ff       	jmp    663f <k_poll+0x34>
			*state = K_POLL_STATE_SEM_AVAILABLE;
    675c:	ba 02 00 00 00       	mov    $0x2,%edx
	event->state |= state;
    6761:	8a 43 0d             	mov    0xd(%ebx),%al
	event->poller = NULL;
    6764:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	event->state |= state;
    676b:	88 c1                	mov    %al,%cl
    676d:	83 e0 0f             	and    $0xf,%eax
    6770:	c0 e9 04             	shr    $0x4,%cl
    6773:	09 ca                	or     %ecx,%edx
    6775:	c1 e2 04             	shl    $0x4,%edx
    6778:	09 d0                	or     %edx,%eax
    677a:	88 43 0d             	mov    %al,0xd(%ebx)
			clear_polling_state(_current);
    677d:	a1 c8 54 40 00       	mov    0x4054c8,%eax
    6782:	80 60 09 df          	andb   $0xdf,0x9(%eax)
    6786:	eb bf                	jmp    6747 <k_poll+0x13c>
}
    6788:	8d 65 f4             	lea    -0xc(%ebp),%esp
    678b:	89 f8                	mov    %edi,%eax
    678d:	5b                   	pop    %ebx
    678e:	5e                   	pop    %esi
    678f:	5f                   	pop    %edi
    6790:	5d                   	pop    %ebp
    6791:	c3                   	ret    

00006792 <_handle_obj_poll_events>:

/* returns 1 if a reschedule must take place, 0 otherwise */
int _handle_obj_poll_events(sys_dlist_t *events, u32_t state)
{
    6792:	55                   	push   %ebp
    6793:	89 e5                	mov    %esp,%ebp
    6795:	53                   	push   %ebx
    6796:	51                   	push   %ecx
    6797:	8b 45 08             	mov    0x8(%ebp),%eax
	return list->head == list;
    679a:	8b 18                	mov    (%eax),%ebx

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node;

	if (sys_dlist_is_empty(list)) {
    679c:	39 d8                	cmp    %ebx,%eax
    679e:	75 04                	jne    67a4 <_handle_obj_poll_events+0x12>
	struct k_poll_event *poll_event;
	int must_reschedule;

	poll_event = (struct k_poll_event *)sys_dlist_get(events);
	if (!poll_event) {
		return 0;
    67a0:	31 c0                	xor    %eax,%eax
    67a2:	eb 1b                	jmp    67bf <_handle_obj_poll_events+0x2d>
		return NULL;
	}

	node = list->head;
	sys_dlist_remove(node);
    67a4:	89 d8                	mov    %ebx,%eax
    67a6:	e8 7c fc ff ff       	call   6427 <sys_dlist_remove>
	if (!poll_event) {
    67ab:	85 db                	test   %ebx,%ebx
    67ad:	74 f1                	je     67a0 <_handle_obj_poll_events+0xe>
	}

	(void)_signal_poll_event(poll_event, state, &must_reschedule);
    67af:	8d 4d f8             	lea    -0x8(%ebp),%ecx
    67b2:	8b 55 0c             	mov    0xc(%ebp),%edx
    67b5:	89 d8                	mov    %ebx,%eax
    67b7:	e8 c4 fc ff ff       	call   6480 <_signal_poll_event>
	return must_reschedule;
    67bc:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
    67bf:	5a                   	pop    %edx
    67c0:	5b                   	pop    %ebx
    67c1:	5d                   	pop    %ebp
    67c2:	c3                   	ret    

000067c3 <k_queue_init>:
SYS_INIT(init_queue_module, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_OBJECTS);

#endif /* CONFIG_OBJECT_TRACING */

void k_queue_init(struct k_queue *queue)
{
    67c3:	55                   	push   %ebp
    67c4:	89 e5                	mov    %esp,%ebp
    67c6:	8b 45 08             	mov    0x8(%ebp),%eax
	sys_slist_init(&queue->data_q);
	sys_dlist_init(&queue->wait_q);
#if defined(CONFIG_POLL)
	sys_dlist_init(&queue->poll_events);
    67c9:	8d 50 08             	lea    0x8(%eax),%edx
	list->head = NULL;
    67cc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	list->tail = NULL;
    67d2:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	list->head = (sys_dnode_t *)list;
    67d9:	89 50 08             	mov    %edx,0x8(%eax)
	list->tail = (sys_dnode_t *)list;
    67dc:	89 50 0c             	mov    %edx,0xc(%eax)
#endif

	SYS_TRACING_OBJ_INIT(k_queue, queue);
}
    67df:	5d                   	pop    %ebp
    67e0:	c3                   	ret    

000067e1 <k_queue_insert>:

	irq_unlock(key);
}

void k_queue_insert(struct k_queue *queue, void *prev, void *data)
{
    67e1:	55                   	push   %ebp
    67e2:	89 e5                	mov    %esp,%ebp
    67e4:	56                   	push   %esi
    67e5:	53                   	push   %ebx
    67e6:	8b 45 08             	mov    0x8(%ebp),%eax
    67e9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    67ec:	8b 55 10             	mov    0x10(%ebp),%edx
	__asm__ volatile (
    67ef:	9c                   	pushf  
    67f0:	fa                   	cli    
    67f1:	5b                   	pop    %ebx
	if (!prev) {
    67f2:	85 c9                	test   %ecx,%ecx
    67f4:	75 0e                	jne    6804 <k_queue_insert+0x23>
	node->next = list->head;
    67f6:	8b 08                	mov    (%eax),%ecx
    67f8:	89 0a                	mov    %ecx,(%edx)
	list->head = node;
    67fa:	89 10                	mov    %edx,(%eax)
	if (!list->tail) {
    67fc:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
    6800:	75 27                	jne    6829 <k_queue_insert+0x48>
    6802:	eb 1c                	jmp    6820 <k_queue_insert+0x3f>
	} else if (!prev->next) {
    6804:	8b 31                	mov    (%ecx),%esi
    6806:	85 f6                	test   %esi,%esi
    6808:	75 1b                	jne    6825 <k_queue_insert+0x44>
	if (!list->tail) {
    680a:	8b 48 04             	mov    0x4(%eax),%ecx
	node->next = NULL;
    680d:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
	if (!list->tail) {
    6813:	85 c9                	test   %ecx,%ecx
    6815:	75 07                	jne    681e <k_queue_insert+0x3d>
		list->tail = node;
    6817:	89 50 04             	mov    %edx,0x4(%eax)
		list->head = node;
    681a:	89 10                	mov    %edx,(%eax)
    681c:	eb 0b                	jmp    6829 <k_queue_insert+0x48>
		list->tail->next = node;
    681e:	89 11                	mov    %edx,(%ecx)
		list->tail = node;
    6820:	89 50 04             	mov    %edx,0x4(%eax)
    6823:	eb 04                	jmp    6829 <k_queue_insert+0x48>
		node->next = prev->next;
    6825:	89 32                	mov    %esi,(%edx)
		prev->next = node;
    6827:	89 11                	mov    %edx,(%ecx)
	return _handle_obj_poll_events(&queue->poll_events, state);
    6829:	83 c0 08             	add    $0x8,%eax
    682c:	6a 04                	push   $0x4
    682e:	50                   	push   %eax
    682f:	e8 5e ff ff ff       	call   6792 <_handle_obj_poll_events>
    6834:	5a                   	pop    %edx
#endif /* !CONFIG_POLL */

	sys_slist_insert(&queue->data_q, prev, data);

#if defined(CONFIG_POLL)
	if (handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE)) {
    6835:	85 c0                	test   %eax,%eax
	return _handle_obj_poll_events(&queue->poll_events, state);
    6837:	59                   	pop    %ecx
	if (handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE)) {
    6838:	74 13                	je     684d <k_queue_insert+0x6c>
	_update_time_slice_before_swap();
    683a:	e8 96 04 00 00       	call   6cd5 <_update_time_slice_before_swap>
	return __swap(key);
    683f:	89 5d 08             	mov    %ebx,0x8(%ebp)
		return;
	}
#endif /* CONFIG_POLL */

	irq_unlock(key);
}
    6842:	8d 65 f8             	lea    -0x8(%ebp),%esp
    6845:	5b                   	pop    %ebx
    6846:	5e                   	pop    %esi
    6847:	5d                   	pop    %ebp
    6848:	e9 24 f3 ff ff       	jmp    5b71 <__swap>
    684d:	0f ba e3 09          	bt     $0x9,%ebx
    6851:	73 01                	jae    6854 <k_queue_insert+0x73>
	__asm__ volatile (
    6853:	fb                   	sti    
    6854:	8d 65 f8             	lea    -0x8(%ebp),%esp
    6857:	5b                   	pop    %ebx
    6858:	5e                   	pop    %esi
    6859:	5d                   	pop    %ebp
    685a:	c3                   	ret    

0000685b <k_queue_append>:

void k_queue_append(struct k_queue *queue, void *data)
{
    685b:	55                   	push   %ebp
    685c:	89 e5                	mov    %esp,%ebp
	return k_queue_insert(queue, queue->data_q.tail, data);
    685e:	ff 75 0c             	pushl  0xc(%ebp)
{
    6861:	8b 45 08             	mov    0x8(%ebp),%eax
	return k_queue_insert(queue, queue->data_q.tail, data);
    6864:	ff 70 04             	pushl  0x4(%eax)
    6867:	50                   	push   %eax
    6868:	e8 74 ff ff ff       	call   67e1 <k_queue_insert>
    686d:	83 c4 0c             	add    $0xc,%esp
}
    6870:	c9                   	leave  
    6871:	c3                   	ret    

00006872 <k_queue_prepend>:

void k_queue_prepend(struct k_queue *queue, void *data)
{
    6872:	55                   	push   %ebp
    6873:	89 e5                	mov    %esp,%ebp
	return k_queue_insert(queue, NULL, data);
    6875:	ff 75 0c             	pushl  0xc(%ebp)
    6878:	6a 00                	push   $0x0
    687a:	ff 75 08             	pushl  0x8(%ebp)
    687d:	e8 5f ff ff ff       	call   67e1 <k_queue_insert>
    6882:	83 c4 0c             	add    $0xc,%esp
}
    6885:	c9                   	leave  
    6886:	c3                   	ret    

00006887 <k_queue_get>:
	return val;
}
#endif /* CONFIG_POLL */

void *k_queue_get(struct k_queue *queue, s32_t timeout)
{
    6887:	55                   	push   %ebp
    6888:	89 e5                	mov    %esp,%ebp
    688a:	57                   	push   %edi
    688b:	56                   	push   %esi
    688c:	53                   	push   %ebx
    688d:	83 ec 14             	sub    $0x14,%esp
    6890:	8b 7d 08             	mov    0x8(%ebp),%edi
    6893:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	__asm__ volatile (
    6896:	9c                   	pushf  
    6897:	fa                   	cli    
    6898:	5a                   	pop    %edx
    6899:	8b 07                	mov    (%edi),%eax
	unsigned int key;
	void *data;

	key = irq_lock();

	if (likely(!sys_slist_is_empty(&queue->data_q))) {
    689b:	85 c0                	test   %eax,%eax
    689d:	74 0e                	je     68ad <k_queue_get+0x26>
	list->head = node->next;
    689f:	8b 08                	mov    (%eax),%ecx
	if (list->tail == node) {
    68a1:	3b 47 04             	cmp    0x4(%edi),%eax
	list->head = node->next;
    68a4:	89 0f                	mov    %ecx,(%edi)
	if (list->tail == node) {
    68a6:	75 0b                	jne    68b3 <k_queue_get+0x2c>
		list->tail = list->head;
    68a8:	89 4f 04             	mov    %ecx,0x4(%edi)
    68ab:	eb 06                	jmp    68b3 <k_queue_get+0x2c>
		data = sys_slist_get_not_empty(&queue->data_q);
		irq_unlock(key);
		return data;
	}

	if (timeout == K_NO_WAIT) {
    68ad:	85 db                	test   %ebx,%ebx
    68af:	75 0b                	jne    68bc <k_queue_get+0x35>
		irq_unlock(key);
		return NULL;
    68b1:	31 c0                	xor    %eax,%eax
    68b3:	0f ba e2 09          	bt     $0x9,%edx
    68b7:	73 58                	jae    6911 <k_queue_get+0x8a>
	__asm__ volatile (
    68b9:	fb                   	sti    
    68ba:	eb 55                	jmp    6911 <k_queue_get+0x8a>
    68bc:	0f ba e2 09          	bt     $0x9,%edx
    68c0:	73 01                	jae    68c3 <k_queue_get+0x3c>
    68c2:	fb                   	sti    
	k_poll_event_init(&event, K_POLL_TYPE_FIFO_DATA_AVAILABLE,
    68c3:	8d 75 e0             	lea    -0x20(%ebp),%esi
    68c6:	57                   	push   %edi
    68c7:	6a 00                	push   $0x0
    68c9:	6a 04                	push   $0x4
    68cb:	56                   	push   %esi
    68cc:	e8 06 fd ff ff       	call   65d7 <k_poll_event_init>
    68d1:	83 c4 10             	add    $0x10,%esp
		err = k_poll(&event, 1, timeout);
    68d4:	53                   	push   %ebx
    68d5:	6a 01                	push   $0x1
		event.state = K_POLL_STATE_NOT_READY;
    68d7:	80 65 ed 0f          	andb   $0xf,-0x13(%ebp)
		err = k_poll(&event, 1, timeout);
    68db:	56                   	push   %esi
    68dc:	e8 2a fd ff ff       	call   660b <k_poll>
    68e1:	83 c4 0c             	add    $0xc,%esp
		if (err) {
    68e4:	85 c0                	test   %eax,%eax
    68e6:	75 27                	jne    690f <k_queue_get+0x88>
	__asm__ volatile (
    68e8:	9c                   	pushf  
    68e9:	fa                   	cli    
    68ea:	59                   	pop    %ecx
    68eb:	8b 07                	mov    (%edi),%eax
	return sys_slist_is_empty(list) ? NULL : sys_slist_get_not_empty(list);
    68ed:	85 c0                	test   %eax,%eax
    68ef:	74 0c                	je     68fd <k_queue_get+0x76>
	list->head = node->next;
    68f1:	8b 10                	mov    (%eax),%edx
	if (list->tail == node) {
    68f3:	3b 47 04             	cmp    0x4(%edi),%eax
	list->head = node->next;
    68f6:	89 17                	mov    %edx,(%edi)
	if (list->tail == node) {
    68f8:	75 03                	jne    68fd <k_queue_get+0x76>
		list->tail = list->head;
    68fa:	89 57 04             	mov    %edx,0x4(%edi)
    68fd:	0f ba e1 09          	bt     $0x9,%ecx
    6901:	73 01                	jae    6904 <k_queue_get+0x7d>
	__asm__ volatile (
    6903:	fb                   	sti    
	} while (!val && timeout == K_FOREVER);
    6904:	85 c0                	test   %eax,%eax
    6906:	75 09                	jne    6911 <k_queue_get+0x8a>
    6908:	83 fb ff             	cmp    $0xffffffff,%ebx
    690b:	74 c7                	je     68d4 <k_queue_get+0x4d>
    690d:	eb 02                	jmp    6911 <k_queue_get+0x8a>
			return NULL;
    690f:	31 c0                	xor    %eax,%eax
#else
	_pend_current_thread(&queue->wait_q, timeout);

	return _Swap(key) ? NULL : _current->base.swap_data;
#endif /* CONFIG_POLL */
}
    6911:	8d 65 f4             	lea    -0xc(%ebp),%esp
    6914:	5b                   	pop    %ebx
    6915:	5e                   	pop    %esi
    6916:	5f                   	pop    %edi
    6917:	5d                   	pop    %ebp
    6918:	c3                   	ret    

00006919 <_get_highest_ready_prio>:
{
    6919:	55                   	push   %ebp
    691a:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
    691c:	0f bc 05 d8 54 40 00 	bsf    0x4054d8,%eax
    6923:	75 05                	jne    692a <_get_highest_ready_prio+0x11>
    6925:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	return abs_prio - _NUM_COOP_PRIO;
    692a:	83 e8 10             	sub    $0x10,%eax
}
    692d:	5d                   	pop    %ebp
    692e:	c3                   	ret    

0000692f <_add_thread_to_ready_q>:
 *
 * Interrupts must be locked when calling this function.
 */

void _add_thread_to_ready_q(struct k_thread *thread)
{
    692f:	55                   	push   %ebp
    6930:	89 e5                	mov    %esp,%ebp
    6932:	56                   	push   %esi
    6933:	53                   	push   %ebx
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
    6934:	bb 01 00 00 00       	mov    $0x1,%ebx
    6939:	8b 45 08             	mov    0x8(%ebp),%eax
#ifdef CONFIG_MULTITHREADING
	int q_index = _get_ready_q_q_index(thread->base.prio);
    693c:	0f be 50 0a          	movsbl 0xa(%eax),%edx
	return prio + _NUM_COOP_PRIO;
    6940:	8d 4a 10             	lea    0x10(%edx),%ecx
	sys_dlist_t *q = &_ready_q.q[q_index];
    6943:	83 c2 12             	add    $0x12,%edx
	return (prio + _NUM_COOP_PRIO) >> 5;
    6946:	89 ce                	mov    %ecx,%esi
    6948:	c1 fe 05             	sar    $0x5,%esi
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
    694b:	d3 e3                	shl    %cl,%ebx
    694d:	8d 0c d5 cc 54 40 00 	lea    0x4054cc(,%edx,8),%ecx
	*bmap |= _get_ready_q_prio_bit(prio);
    6954:	09 1c b5 d8 54 40 00 	or     %ebx,0x4054d8(,%esi,4)
	sys_dlist_t *q = &_ready_q.q[q_index];
    695b:	89 08                	mov    %ecx,(%eax)
	node->prev = list->tail;
    695d:	8b 0c d5 d0 54 40 00 	mov    0x4054d0(,%edx,8),%ecx
    6964:	89 48 04             	mov    %ecx,0x4(%eax)
	list->tail->next = node;
    6967:	8b 0c d5 d0 54 40 00 	mov    0x4054d0(,%edx,8),%ecx
    696e:	89 01                	mov    %eax,(%ecx)
	list->tail = node;
    6970:	89 04 d5 d0 54 40 00 	mov    %eax,0x4054d0(,%edx,8)
	_set_ready_q_prio_bit(thread->base.prio);
	sys_dlist_append(q, &thread->base.k_q_node);

	struct k_thread **cache = &_ready_q.cache;

	*cache = _is_t1_higher_prio_than_t2(thread, *cache) ? thread : *cache;
    6977:	8b 15 d4 54 40 00    	mov    0x4054d4,%edx
    697d:	8a 5a 0a             	mov    0xa(%edx),%bl
    6980:	38 58 0a             	cmp    %bl,0xa(%eax)
    6983:	7c 02                	jl     6987 <_add_thread_to_ready_q+0x58>
    6985:	89 d0                	mov    %edx,%eax
#else
	sys_dlist_append(&_ready_q.q[0], &thread->base.k_q_node);
	_ready_q.prio_bmap[0] = 1;
	_ready_q.cache = thread;
#endif
}
    6987:	5b                   	pop    %ebx
	*cache = _is_t1_higher_prio_than_t2(thread, *cache) ? thread : *cache;
    6988:	a3 d4 54 40 00       	mov    %eax,0x4054d4
}
    698d:	5e                   	pop    %esi
    698e:	5d                   	pop    %ebp
    698f:	c3                   	ret    

00006990 <_ready_thread>:
	thread->base.thread_state &= ~_THREAD_PRESTART;
    6990:	8a 50 09             	mov    0x9(%eax),%dl
    6993:	88 d1                	mov    %dl,%cl
    6995:	83 e1 fb             	and    $0xfffffffb,%ecx
	return !(_is_thread_prevented_from_running(thread) ||
    6998:	80 e2 1b             	and    $0x1b,%dl
	thread->base.thread_state &= ~_THREAD_PRESTART;
    699b:	88 48 09             	mov    %cl,0x9(%eax)
	return !(_is_thread_prevented_from_running(thread) ||
    699e:	75 11                	jne    69b1 <_ready_thread+0x21>
    69a0:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
    69a4:	75 0b                	jne    69b1 <_ready_thread+0x21>
{
    69a6:	55                   	push   %ebp
    69a7:	89 e5                	mov    %esp,%ebp
		_add_thread_to_ready_q(thread);
    69a9:	50                   	push   %eax
    69aa:	e8 80 ff ff ff       	call   692f <_add_thread_to_ready_q>
    69af:	58                   	pop    %eax
}
    69b0:	c9                   	leave  
    69b1:	c3                   	ret    

000069b2 <_add_timeout>:

static inline void _add_timeout(struct k_thread *thread,
				struct _timeout *timeout,
				_wait_q_t *wait_q,
				s32_t timeout_in_ticks)
{
    69b2:	55                   	push   %ebp
    69b3:	89 e5                	mov    %esp,%ebp
    69b5:	53                   	push   %ebx
	__ASSERT(timeout_in_ticks >= 0, "");

	timeout->delta_ticks_from_prev = timeout_in_ticks;
	timeout->thread = thread;
    69b6:	89 42 08             	mov    %eax,0x8(%edx)
	timeout->wait_q = (sys_dlist_t *)wait_q;
    69b9:	89 4a 0c             	mov    %ecx,0xc(%edx)
{
    69bc:	8b 5d 08             	mov    0x8(%ebp),%ebx
	timeout->delta_ticks_from_prev = timeout_in_ticks;
    69bf:	89 5a 10             	mov    %ebx,0x10(%edx)
	/* If timer is submitted to expire ASAP with
	 * timeout_in_ticks (duration) as zero value,
	 * then handle timeout immedately without going
	 * through timeout queue.
	 */
	if (!timeout_in_ticks) {
    69c2:	85 db                	test   %ebx,%ebx
    69c4:	75 4e                	jne    6a14 <_add_timeout+0x62>
	__asm__ volatile (
    69c6:	9c                   	pushf  
    69c7:	fa                   	cli    
    69c8:	5b                   	pop    %ebx
	timeout->delta_ticks_from_prev = _INACTIVE;
    69c9:	c7 42 10 ff ff ff ff 	movl   $0xffffffff,0x10(%edx)
	if (thread) {
    69d0:	85 c0                	test   %eax,%eax
    69d2:	74 2b                	je     69ff <_add_timeout+0x4d>
	if (timeout_obj->wait_q) {
    69d4:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
    69d8:	74 17                	je     69f1 <_add_timeout+0x3f>
	node->prev->next = node->next;
    69da:	8b 50 04             	mov    0x4(%eax),%edx
    69dd:	8b 08                	mov    (%eax),%ecx
    69df:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
    69e1:	8b 08                	mov    (%eax),%ecx
    69e3:	89 51 04             	mov    %edx,0x4(%ecx)
		thread->base.timeout.wait_q = NULL;
    69e6:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
	thread->base.thread_state &= ~_THREAD_PENDING;
    69ed:	80 60 09 fd          	andb   $0xfd,0x9(%eax)
		_ready_thread(thread);
    69f1:	e8 9a ff ff ff       	call   6990 <_ready_thread>
    69f6:	0f ba e3 09          	bt     $0x9,%ebx
    69fa:	73 79                	jae    6a75 <_add_timeout+0xc3>
	__asm__ volatile (
    69fc:	fb                   	sti    
    69fd:	eb 76                	jmp    6a75 <_add_timeout+0xc3>
    69ff:	0f ba e3 09          	bt     $0x9,%ebx
    6a03:	73 01                	jae    6a06 <_add_timeout+0x54>
    6a05:	fb                   	sti    
		if (timeout->func) {
    6a06:	8b 42 14             	mov    0x14(%edx),%eax
    6a09:	85 c0                	test   %eax,%eax
    6a0b:	74 68                	je     6a75 <_add_timeout+0xc3>
			timeout->func(timeout);
    6a0d:	89 55 08             	mov    %edx,0x8(%ebp)
#ifdef CONFIG_TICKLESS_KERNEL
	if (!program_time || (adjusted_timeout < program_time)) {
		_set_time(adjusted_timeout);
	}
#endif
}
    6a10:	5b                   	pop    %ebx
    6a11:	5d                   	pop    %ebp
			timeout->func(timeout);
    6a12:	ff e0                	jmp    *%eax
	return list->head == list;
    6a14:	a1 cc 54 40 00       	mov    0x4054cc,%eax
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
    6a19:	85 c0                	test   %eax,%eax
    6a1b:	74 07                	je     6a24 <_add_timeout+0x72>
    6a1d:	3d cc 54 40 00       	cmp    $0x4054cc,%eax
    6a22:	75 1d                	jne    6a41 <_add_timeout+0x8f>
	node->next = list;
    6a24:	c7 02 cc 54 40 00    	movl   $0x4054cc,(%edx)
	node->prev = list->tail;
    6a2a:	a1 d0 54 40 00       	mov    0x4054d0,%eax
    6a2f:	89 42 04             	mov    %eax,0x4(%edx)
	list->tail->next = node;
    6a32:	a1 d0 54 40 00       	mov    0x4054d0,%eax
    6a37:	89 10                	mov    %edx,(%eax)
	list->tail = node;
    6a39:	89 15 d0 54 40 00    	mov    %edx,0x4054d0
    6a3f:	eb 34                	jmp    6a75 <_add_timeout+0xc3>
		if (*delta <= in_q->delta_ticks_from_prev) {
    6a41:	8b 4a 10             	mov    0x10(%edx),%ecx
    6a44:	8b 58 10             	mov    0x10(%eax),%ebx
    6a47:	39 d9                	cmp    %ebx,%ecx
    6a49:	7f 17                	jg     6a62 <_add_timeout+0xb0>
			in_q->delta_ticks_from_prev -= *delta;
    6a4b:	29 cb                	sub    %ecx,%ebx
		node->prev = insert_point->prev;
    6a4d:	8b 48 04             	mov    0x4(%eax),%ecx
    6a50:	89 58 10             	mov    %ebx,0x10(%eax)
    6a53:	89 4a 04             	mov    %ecx,0x4(%edx)
		node->next = insert_point;
    6a56:	89 02                	mov    %eax,(%edx)
		insert_point->prev->next = node;
    6a58:	8b 48 04             	mov    0x4(%eax),%ecx
    6a5b:	89 11                	mov    %edx,(%ecx)
		insert_point->prev = node;
    6a5d:	89 50 04             	mov    %edx,0x4(%eax)
    6a60:	eb 13                	jmp    6a75 <_add_timeout+0xc3>
		*delta -= in_q->delta_ticks_from_prev;
    6a62:	29 d9                	sub    %ebx,%ecx
    6a64:	89 4a 10             	mov    %ecx,0x10(%edx)
	return (node == list->tail) ? NULL : node->next;
    6a67:	3b 05 d0 54 40 00    	cmp    0x4054d0,%eax
    6a6d:	74 b5                	je     6a24 <_add_timeout+0x72>
    6a6f:	8b 00                	mov    (%eax),%eax
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
    6a71:	85 c0                	test   %eax,%eax
    6a73:	eb ad                	jmp    6a22 <_add_timeout+0x70>
}
    6a75:	5b                   	pop    %ebx
    6a76:	5d                   	pop    %ebp
    6a77:	c3                   	ret    

00006a78 <_remove_thread_from_ready_q>:
 *
 * Interrupts must be locked when calling this function.
 */

void _remove_thread_from_ready_q(struct k_thread *thread)
{
    6a78:	55                   	push   %ebp
    6a79:	89 e5                	mov    %esp,%ebp
    6a7b:	53                   	push   %ebx
    6a7c:	8b 45 08             	mov    0x8(%ebp),%eax
	node->prev->next = node->next;
    6a7f:	8b 48 04             	mov    0x4(%eax),%ecx
    6a82:	8b 18                	mov    (%eax),%ebx
#ifdef CONFIG_MULTITHREADING
	int q_index = _get_ready_q_q_index(thread->base.prio);
    6a84:	0f be 50 0a          	movsbl 0xa(%eax),%edx
    6a88:	89 19                	mov    %ebx,(%ecx)
	node->next->prev = node->prev;
    6a8a:	8b 18                	mov    (%eax),%ebx
    6a8c:	89 4b 04             	mov    %ecx,0x4(%ebx)
	sys_dlist_t *q = &_ready_q.q[q_index];
    6a8f:	8d 0c d5 5c 55 40 00 	lea    0x40555c(,%edx,8),%ecx

	sys_dlist_remove(&thread->base.k_q_node);
	if (sys_dlist_is_empty(q)) {
    6a96:	3b 0c d5 5c 55 40 00 	cmp    0x40555c(,%edx,8),%ecx
    6a9d:	75 1c                	jne    6abb <_remove_thread_from_ready_q+0x43>
		_clear_ready_q_prio_bit(thread->base.prio);
    6a9f:	0f be 48 0a          	movsbl 0xa(%eax),%ecx
	return (prio + _NUM_COOP_PRIO) >> 5;
    6aa3:	83 c1 10             	add    $0x10,%ecx
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
    6aa6:	ba 01 00 00 00       	mov    $0x1,%edx
	return (prio + _NUM_COOP_PRIO) >> 5;
    6aab:	89 cb                	mov    %ecx,%ebx
    6aad:	c1 fb 05             	sar    $0x5,%ebx
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
    6ab0:	d3 e2                	shl    %cl,%edx
	*bmap &= ~_get_ready_q_prio_bit(prio);
    6ab2:	f7 d2                	not    %edx
    6ab4:	21 14 9d d8 54 40 00 	and    %edx,0x4054d8(,%ebx,4)
	}

	struct k_thread **cache = &_ready_q.cache;

	*cache = *cache == thread ? _get_ready_q_head() : *cache;
    6abb:	8b 15 d4 54 40 00    	mov    0x4054d4,%edx
    6ac1:	39 d0                	cmp    %edx,%eax
    6ac3:	75 0c                	jne    6ad1 <_remove_thread_from_ready_q+0x59>
	int prio = _get_highest_ready_prio();
    6ac5:	e8 4f fe ff ff       	call   6919 <_get_highest_ready_prio>
    6aca:	8b 14 c5 5c 55 40 00 	mov    0x40555c(,%eax,8),%edx
#else
	_ready_q.prio_bmap[0] = 0;
	_ready_q.cache = NULL;
	sys_dlist_remove(&thread->base.k_q_node);
#endif
}
    6ad1:	5b                   	pop    %ebx
	*cache = *cache == thread ? _get_ready_q_head() : *cache;
    6ad2:	89 15 d4 54 40 00    	mov    %edx,0x4054d4
}
    6ad8:	5d                   	pop    %ebp
    6ad9:	c3                   	ret    

00006ada <_pend_thread>:
#endif

/* pend the specified thread: it must *not* be in the ready queue */
/* must be called with interrupts locked */
void _pend_thread(struct k_thread *thread, _wait_q_t *wait_q, s32_t timeout)
{
    6ada:	55                   	push   %ebp
    6adb:	89 e5                	mov    %esp,%ebp
    6add:	57                   	push   %edi
    6ade:	56                   	push   %esi
    6adf:	53                   	push   %ebx
    6ae0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    6ae3:	8b 75 08             	mov    0x8(%ebp),%esi
    6ae6:	8b 45 10             	mov    0x10(%ebp),%eax
	return list->head == list;
    6ae9:	8b 19                	mov    (%ecx),%ebx
#ifdef CONFIG_MULTITHREADING
	sys_dlist_t *wait_q_list = (sys_dlist_t *)wait_q;
	struct k_thread *pending;

	SYS_DLIST_FOR_EACH_CONTAINER(wait_q_list, pending, base.k_q_node) {
    6aeb:	85 db                	test   %ebx,%ebx
    6aed:	74 04                	je     6af3 <_pend_thread+0x19>
    6aef:	39 d9                	cmp    %ebx,%ecx
    6af1:	75 0f                	jne    6b02 <_pend_thread+0x28>
    6af3:	31 db                	xor    %ebx,%ebx
    6af5:	eb 0b                	jmp    6b02 <_pend_thread+0x28>
	return (node == list->tail) ? NULL : node->next;
    6af7:	3b 59 04             	cmp    0x4(%ecx),%ebx
    6afa:	74 24                	je     6b20 <_pend_thread+0x46>
    6afc:	8b 1b                	mov    (%ebx),%ebx
    6afe:	85 db                	test   %ebx,%ebx
    6b00:	74 1e                	je     6b20 <_pend_thread+0x46>
    6b02:	85 db                	test   %ebx,%ebx
    6b04:	74 1a                	je     6b20 <_pend_thread+0x46>
		if (_is_t1_higher_prio_than_t2(thread, pending)) {
    6b06:	8a 53 0a             	mov    0xa(%ebx),%dl
    6b09:	38 56 0a             	cmp    %dl,0xa(%esi)
    6b0c:	7d e9                	jge    6af7 <_pend_thread+0x1d>
		node->prev = insert_point->prev;
    6b0e:	8b 53 04             	mov    0x4(%ebx),%edx
		node->next = insert_point;
    6b11:	89 1e                	mov    %ebx,(%esi)
		node->prev = insert_point->prev;
    6b13:	89 56 04             	mov    %edx,0x4(%esi)
		insert_point->prev->next = node;
    6b16:	8b 53 04             	mov    0x4(%ebx),%edx
    6b19:	89 32                	mov    %esi,(%edx)
		insert_point->prev = node;
    6b1b:	89 73 04             	mov    %esi,0x4(%ebx)
    6b1e:	eb 10                	jmp    6b30 <_pend_thread+0x56>
	node->next = list;
    6b20:	89 0e                	mov    %ecx,(%esi)
	node->prev = list->tail;
    6b22:	8b 51 04             	mov    0x4(%ecx),%edx
    6b25:	89 56 04             	mov    %edx,0x4(%esi)
	list->tail->next = node;
    6b28:	8b 51 04             	mov    0x4(%ecx),%edx
    6b2b:	89 32                	mov    %esi,(%edx)
	list->tail = node;
    6b2d:	89 71 04             	mov    %esi,0x4(%ecx)
	thread->base.thread_state |= _THREAD_PENDING;
    6b30:	80 4e 09 02          	orb    $0x2,0x9(%esi)
	sys_dlist_append(wait_q_list, &thread->base.k_q_node);

inserted:
	_mark_thread_as_pending(thread);

	if (timeout != K_FOREVER) {
    6b34:	83 f8 ff             	cmp    $0xffffffff,%eax
    6b37:	74 20                	je     6b59 <_pend_thread+0x7f>
#ifdef _NON_OPTIMIZED_TICKS_PER_SEC
extern s32_t _ms_to_ticks(s32_t ms);
#else
static ALWAYS_INLINE s32_t _ms_to_ticks(s32_t ms)
{
	return (s32_t)ceiling_fraction((u32_t)ms, _ms_per_tick);
    6b39:	bf 0a 00 00 00       	mov    $0xa,%edi
    6b3e:	83 c0 09             	add    $0x9,%eax
    6b41:	31 d2                	xor    %edx,%edx

static inline void _add_thread_timeout(struct k_thread *thread,
				       _wait_q_t *wait_q,
				       s32_t timeout_in_ticks)
{
	_add_timeout(thread, &thread->base.timeout, wait_q, timeout_in_ticks);
    6b43:	8d 5e 10             	lea    0x10(%esi),%ebx
    6b46:	f7 f7                	div    %edi
		s32_t ticks = _TICK_ALIGN + _ms_to_ticks(timeout);
    6b48:	40                   	inc    %eax
    6b49:	89 da                	mov    %ebx,%edx
    6b4b:	89 45 08             	mov    %eax,0x8(%ebp)
    6b4e:	89 f0                	mov    %esi,%eax

		_add_thread_timeout(thread, wait_q, ticks);
	}
#endif
}
    6b50:	5b                   	pop    %ebx
    6b51:	5e                   	pop    %esi
    6b52:	5f                   	pop    %edi
    6b53:	5d                   	pop    %ebp
    6b54:	e9 59 fe ff ff       	jmp    69b2 <_add_timeout>
    6b59:	5b                   	pop    %ebx
    6b5a:	5e                   	pop    %esi
    6b5b:	5f                   	pop    %edi
    6b5c:	5d                   	pop    %ebp
    6b5d:	c3                   	ret    

00006b5e <_pend_current_thread>:

/* pend the current thread */
/* must be called with interrupts locked */
void _pend_current_thread(_wait_q_t *wait_q, s32_t timeout)
{
    6b5e:	55                   	push   %ebp
    6b5f:	89 e5                	mov    %esp,%ebp
	_remove_thread_from_ready_q(_current);
    6b61:	ff 35 c8 54 40 00    	pushl  0x4054c8
    6b67:	e8 0c ff ff ff       	call   6a78 <_remove_thread_from_ready_q>
    6b6c:	58                   	pop    %eax
	_pend_thread(_current, wait_q, timeout);
    6b6d:	ff 75 0c             	pushl  0xc(%ebp)
    6b70:	ff 75 08             	pushl  0x8(%ebp)
    6b73:	ff 35 c8 54 40 00    	pushl  0x4054c8
    6b79:	e8 5c ff ff ff       	call   6ada <_pend_thread>
    6b7e:	83 c4 0c             	add    $0xc,%esp
}
    6b81:	c9                   	leave  
    6b82:	c3                   	ret    

00006b83 <__must_switch_threads>:
/*
 * Check if there is a thread of higher prio than the current one. Should only
 * be called if we already know that the current thread is preemptible.
 */
int __must_switch_threads(void)
{
    6b83:	55                   	push   %ebp

#ifdef CONFIG_KERNEL_DEBUG
	_dump_ready_q();
#endif  /* CONFIG_KERNEL_DEBUG */

	return _is_prio_higher(_get_highest_ready_prio(), _current->base.prio);
    6b84:	a1 c8 54 40 00       	mov    0x4054c8,%eax
{
    6b89:	89 e5                	mov    %esp,%ebp
	return _is_prio_higher(_get_highest_ready_prio(), _current->base.prio);
    6b8b:	0f be 50 0a          	movsbl 0xa(%eax),%edx
    6b8f:	e8 85 fd ff ff       	call   6919 <_get_highest_ready_prio>
#else
	return 0;
#endif
}
    6b94:	5d                   	pop    %ebp
	return prio1 < prio2;
    6b95:	39 c2                	cmp    %eax,%edx
    6b97:	0f 9f c0             	setg   %al
    6b9a:	0f b6 c0             	movzbl %al,%eax
    6b9d:	c3                   	ret    

00006b9e <_reschedule_threads>:
{
    6b9e:	55                   	push   %ebp
	return _is_preempt(_current) && __must_switch_threads();
    6b9f:	a1 c8 54 40 00       	mov    0x4054c8,%eax
    6ba4:	89 e5                	mov    %esp,%ebp
    6ba6:	66 83 78 0a 7f       	cmpw   $0x7f,0xa(%eax)
    6bab:	8b 4d 08             	mov    0x8(%ebp),%ecx
    6bae:	77 09                	ja     6bb9 <_reschedule_threads+0x1b>
    6bb0:	e8 ce ff ff ff       	call   6b83 <__must_switch_threads>
    6bb5:	85 c0                	test   %eax,%eax
    6bb7:	75 09                	jne    6bc2 <_reschedule_threads+0x24>
    6bb9:	0f ba e1 09          	bt     $0x9,%ecx
    6bbd:	73 16                	jae    6bd5 <_reschedule_threads+0x37>
    6bbf:	fb                   	sti    
}
    6bc0:	eb 13                	jmp    6bd5 <_reschedule_threads+0x37>
    6bc2:	89 4d 08             	mov    %ecx,0x8(%ebp)
		_set_time(remaining);
	}

#endif
	/* Restart time slice count at new thread switch */
	_time_slice_elapsed = 0;
    6bc5:	c7 05 ec 55 40 00 00 	movl   $0x0,0x4055ec
    6bcc:	00 00 00 
}
    6bcf:	5d                   	pop    %ebp
    6bd0:	e9 9c ef ff ff       	jmp    5b71 <__swap>
    6bd5:	5d                   	pop    %ebp
    6bd6:	c3                   	ret    

00006bd7 <k_sched_unlock>:
{
    6bd7:	55                   	push   %ebp
    6bd8:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
    6bda:	9c                   	pushf  
    6bdb:	fa                   	cli    
    6bdc:	5a                   	pop    %edx
	++_current->base.sched_locked;
    6bdd:	a1 c8 54 40 00       	mov    0x4054c8,%eax
    6be2:	fe 40 0b             	incb   0xb(%eax)
	_reschedule_threads(key);
    6be5:	52                   	push   %edx
    6be6:	e8 b3 ff ff ff       	call   6b9e <_reschedule_threads>
    6beb:	58                   	pop    %eax
}
    6bec:	c9                   	leave  
    6bed:	c3                   	ret    

00006bee <_move_thread_to_end_of_prio_q>:
{
    6bee:	55                   	push   %ebp
    6bef:	89 e5                	mov    %esp,%ebp
    6bf1:	56                   	push   %esi
    6bf2:	53                   	push   %ebx
    6bf3:	8b 45 08             	mov    0x8(%ebp),%eax
	int q_index = _get_ready_q_q_index(thread->base.prio);
    6bf6:	0f be 50 0a          	movsbl 0xa(%eax),%edx
	sys_dlist_t *q = &_ready_q.q[q_index];
    6bfa:	83 c2 12             	add    $0x12,%edx
    6bfd:	8d 0c d5 cc 54 40 00 	lea    0x4054cc(,%edx,8),%ecx
	if (sys_dlist_is_tail(q, &thread->base.k_q_node)) {
    6c04:	3b 41 04             	cmp    0x4(%ecx),%eax
    6c07:	74 44                	je     6c4d <_move_thread_to_end_of_prio_q+0x5f>
	node->prev->next = node->next;
    6c09:	8b 58 04             	mov    0x4(%eax),%ebx
    6c0c:	8b 30                	mov    (%eax),%esi
    6c0e:	89 33                	mov    %esi,(%ebx)
	node->next->prev = node->prev;
    6c10:	8b 30                	mov    (%eax),%esi
    6c12:	89 5e 04             	mov    %ebx,0x4(%esi)
	node->next = list;
    6c15:	89 08                	mov    %ecx,(%eax)
	node->prev = list->tail;
    6c17:	8b 0c d5 d0 54 40 00 	mov    0x4054d0(,%edx,8),%ecx
    6c1e:	89 48 04             	mov    %ecx,0x4(%eax)
	list->tail->next = node;
    6c21:	8b 0c d5 d0 54 40 00 	mov    0x4054d0(,%edx,8),%ecx
    6c28:	89 01                	mov    %eax,(%ecx)
	list->tail = node;
    6c2a:	89 04 d5 d0 54 40 00 	mov    %eax,0x4054d0(,%edx,8)
	*cache = *cache == thread ? _get_ready_q_head() : *cache;
    6c31:	8b 15 d4 54 40 00    	mov    0x4054d4,%edx
    6c37:	39 d0                	cmp    %edx,%eax
    6c39:	75 0c                	jne    6c47 <_move_thread_to_end_of_prio_q+0x59>
	int prio = _get_highest_ready_prio();
    6c3b:	e8 d9 fc ff ff       	call   6919 <_get_highest_ready_prio>
    6c40:	8b 14 c5 5c 55 40 00 	mov    0x40555c(,%eax,8),%edx
	*cache = *cache == thread ? _get_ready_q_head() : *cache;
    6c47:	89 15 d4 54 40 00    	mov    %edx,0x4054d4
}
    6c4d:	5b                   	pop    %ebx
    6c4e:	5e                   	pop    %esi
    6c4f:	5d                   	pop    %ebp
    6c50:	c3                   	ret    

00006c51 <k_yield>:
{
    6c51:	55                   	push   %ebp
    6c52:	89 e5                	mov    %esp,%ebp
    6c54:	53                   	push   %ebx
    6c55:	9c                   	pushf  
    6c56:	fa                   	cli    
    6c57:	5b                   	pop    %ebx
	_move_thread_to_end_of_prio_q(_current);
    6c58:	ff 35 c8 54 40 00    	pushl  0x4054c8
    6c5e:	e8 8b ff ff ff       	call   6bee <_move_thread_to_end_of_prio_q>
	if (_current == _get_next_ready_thread()) {
    6c63:	a1 d4 54 40 00       	mov    0x4054d4,%eax
	_move_thread_to_end_of_prio_q(_current);
    6c68:	5a                   	pop    %edx
	if (_current == _get_next_ready_thread()) {
    6c69:	39 05 c8 54 40 00    	cmp    %eax,0x4054c8
    6c6f:	75 09                	jne    6c7a <k_yield+0x29>
    6c71:	0f ba e3 09          	bt     $0x9,%ebx
    6c75:	73 14                	jae    6c8b <k_yield+0x3a>
	__asm__ volatile (
    6c77:	fb                   	sti    
    6c78:	eb 11                	jmp    6c8b <k_yield+0x3a>
    6c7a:	53                   	push   %ebx
	_time_slice_elapsed = 0;
    6c7b:	c7 05 ec 55 40 00 00 	movl   $0x0,0x4055ec
    6c82:	00 00 00 
    6c85:	e8 e7 ee ff ff       	call   5b71 <__swap>
    6c8a:	58                   	pop    %eax
}
    6c8b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6c8e:	c9                   	leave  
    6c8f:	c3                   	ret    

00006c90 <k_current_get>:
{
    6c90:	55                   	push   %ebp
}
    6c91:	a1 c8 54 40 00       	mov    0x4054c8,%eax
{
    6c96:	89 e5                	mov    %esp,%ebp
}
    6c98:	5d                   	pop    %ebp
    6c99:	c3                   	ret    

00006c9a <_is_thread_time_slicing>:
{
    6c9a:	55                   	push   %ebp
		return 0;
    6c9b:	31 c0                	xor    %eax,%eax
{
    6c9d:	89 e5                	mov    %esp,%ebp
	if (!(_time_slice_duration > 0) || (_is_idle_thread_ptr(thread))
    6c9f:	83 3d e0 55 40 00 00 	cmpl   $0x0,0x4055e0
{
    6ca6:	8b 55 08             	mov    0x8(%ebp),%edx
	if (!(_time_slice_duration > 0) || (_is_idle_thread_ptr(thread))
    6ca9:	7e 28                	jle    6cd3 <_is_thread_time_slicing+0x39>
    6cab:	3b 15 0c 7b 00 00    	cmp    0x7b0c,%edx
    6cb1:	74 20                	je     6cd3 <_is_thread_time_slicing+0x39>
	    || _is_prio_higher(thread->base.prio, _time_slice_prio_ceiling)) {
    6cb3:	0f be 52 0a          	movsbl 0xa(%edx),%edx
    6cb7:	39 15 dc 55 40 00    	cmp    %edx,0x4055dc
    6cbd:	7f 14                	jg     6cd3 <_is_thread_time_slicing+0x39>
	return list->head != list->tail;
    6cbf:	8b 04 d5 60 55 40 00 	mov    0x405560(,%edx,8),%eax
    6cc6:	39 04 d5 5c 55 40 00 	cmp    %eax,0x40555c(,%edx,8)
    6ccd:	0f 95 c0             	setne  %al
    6cd0:	0f b6 c0             	movzbl %al,%eax
}
    6cd3:	5d                   	pop    %ebp
    6cd4:	c3                   	ret    

00006cd5 <_update_time_slice_before_swap>:
{
    6cd5:	55                   	push   %ebp
	_time_slice_elapsed = 0;
    6cd6:	c7 05 ec 55 40 00 00 	movl   $0x0,0x4055ec
    6cdd:	00 00 00 
{
    6ce0:	89 e5                	mov    %esp,%ebp
}
    6ce2:	5d                   	pop    %ebp
    6ce3:	c3                   	ret    

00006ce4 <_ready_thread>:
	thread->base.thread_state &= ~_THREAD_PRESTART;
    6ce4:	8a 50 09             	mov    0x9(%eax),%dl
    6ce7:	88 d1                	mov    %dl,%cl
    6ce9:	83 e1 fb             	and    $0xfffffffb,%ecx
	return !(_is_thread_prevented_from_running(thread) ||
    6cec:	80 e2 1b             	and    $0x1b,%dl
	thread->base.thread_state &= ~_THREAD_PRESTART;
    6cef:	88 48 09             	mov    %cl,0x9(%eax)
	return !(_is_thread_prevented_from_running(thread) ||
    6cf2:	75 11                	jne    6d05 <_ready_thread+0x21>
    6cf4:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
    6cf8:	75 0b                	jne    6d05 <_ready_thread+0x21>
{
    6cfa:	55                   	push   %ebp
    6cfb:	89 e5                	mov    %esp,%ebp
		_add_thread_to_ready_q(thread);
    6cfd:	50                   	push   %eax
    6cfe:	e8 2c fc ff ff       	call   692f <_add_thread_to_ready_q>
    6d03:	58                   	pop    %eax
}
    6d04:	c9                   	leave  
    6d05:	c3                   	ret    

00006d06 <_unpend_first_thread>:
{
    6d06:	55                   	push   %ebp
	if (_handling_timeouts) {
    6d07:	8b 15 e8 55 40 00    	mov    0x4055e8,%edx
{
    6d0d:	89 e5                	mov    %esp,%ebp
	if (_handling_timeouts) {
    6d0f:	85 d2                	test   %edx,%edx
    6d11:	8b 08                	mov    (%eax),%ecx
    6d13:	74 1f                	je     6d34 <_unpend_first_thread+0x2e>
	return list->head == list;
    6d15:	89 ca                	mov    %ecx,%edx
	return sys_dlist_is_empty(list) ? NULL : list->head;
    6d17:	39 c8                	cmp    %ecx,%eax
    6d19:	75 11                	jne    6d2c <_unpend_first_thread+0x26>
    6d1b:	31 d2                	xor    %edx,%edx
    6d1d:	eb 0d                	jmp    6d2c <_unpend_first_thread+0x26>
			if (_is_thread_timeout_expired(thread)) {
    6d1f:	83 7a 20 fe          	cmpl   $0xfffffffe,0x20(%edx)
    6d23:	75 1b                	jne    6d40 <_unpend_first_thread+0x3a>
	return (node == list->tail) ? NULL : node->next;
    6d25:	3b 50 04             	cmp    0x4(%eax),%edx
    6d28:	74 06                	je     6d30 <_unpend_first_thread+0x2a>
    6d2a:	8b 12                	mov    (%edx),%edx
		SYS_DLIST_ITERATE_FROM_NODE(q, cur) {
    6d2c:	85 d2                	test   %edx,%edx
    6d2e:	75 ef                	jne    6d1f <_unpend_first_thread+0x19>
    6d30:	31 d2                	xor    %edx,%edx
    6d32:	eb 1c                	jmp    6d50 <_unpend_first_thread+0x4a>
	return sys_dlist_is_empty(list) ? NULL : list->head;
    6d34:	31 d2                	xor    %edx,%edx
    6d36:	39 c8                	cmp    %ecx,%eax
    6d38:	74 16                	je     6d50 <_unpend_first_thread+0x4a>
	if (thread) {
    6d3a:	85 c9                	test   %ecx,%ecx
    6d3c:	74 12                	je     6d50 <_unpend_first_thread+0x4a>
    6d3e:	89 ca                	mov    %ecx,%edx
	node->prev->next = node->next;
    6d40:	8b 42 04             	mov    0x4(%edx),%eax
    6d43:	8b 0a                	mov    (%edx),%ecx
    6d45:	89 08                	mov    %ecx,(%eax)
	node->next->prev = node->prev;
    6d47:	8b 0a                	mov    (%edx),%ecx
    6d49:	89 41 04             	mov    %eax,0x4(%ecx)
	thread->base.thread_state &= ~_THREAD_PENDING;
    6d4c:	80 62 09 fd          	andb   $0xfd,0x9(%edx)
		_unpend_thread(thread);
	}

	return thread;
}
    6d50:	89 d0                	mov    %edx,%eax
    6d52:	5d                   	pop    %ebp
    6d53:	c3                   	ret    

00006d54 <_abort_timeout>:
{
    6d54:	55                   	push   %ebp
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
    6d55:	8b 48 10             	mov    0x10(%eax),%ecx
{
    6d58:	89 e5                	mov    %esp,%ebp
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
    6d5a:	83 f9 ff             	cmp    $0xffffffff,%ecx
    6d5d:	74 24                	je     6d83 <_abort_timeout+0x2f>
	if (!sys_dlist_is_tail(&_timeout_q, &timeout->node)) {
    6d5f:	3b 05 d0 54 40 00    	cmp    0x4054d0,%eax
    6d65:	74 05                	je     6d6c <_abort_timeout+0x18>
	return (node == list->tail) ? NULL : node->next;
    6d67:	8b 10                	mov    (%eax),%edx
		next->delta_ticks_from_prev += timeout->delta_ticks_from_prev;
    6d69:	01 4a 10             	add    %ecx,0x10(%edx)
	node->prev->next = node->next;
    6d6c:	8b 50 04             	mov    0x4(%eax),%edx
    6d6f:	8b 08                	mov    (%eax),%ecx
    6d71:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
    6d73:	8b 08                	mov    (%eax),%ecx
    6d75:	89 51 04             	mov    %edx,0x4(%ecx)
	timeout->delta_ticks_from_prev = _INACTIVE;
    6d78:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)
	return 0;
    6d7f:	31 c0                	xor    %eax,%eax
    6d81:	eb 03                	jmp    6d86 <_abort_timeout+0x32>
		return _INACTIVE;
    6d83:	83 c8 ff             	or     $0xffffffff,%eax
}
    6d86:	5d                   	pop    %ebp
    6d87:	c3                   	ret    

00006d88 <k_sem_init>:

#endif /* CONFIG_OBJECT_TRACING */

void k_sem_init(struct k_sem *sem, unsigned int initial_count,
		unsigned int limit)
{
    6d88:	55                   	push   %ebp
    6d89:	89 e5                	mov    %esp,%ebp
    6d8b:	8b 45 08             	mov    0x8(%ebp),%eax
	__ASSERT(limit != 0, "limit cannot be zero");

	sem->count = initial_count;
    6d8e:	8b 55 0c             	mov    0xc(%ebp),%edx
    6d91:	89 50 08             	mov    %edx,0x8(%eax)
	sem->limit = limit;
    6d94:	8b 55 10             	mov    0x10(%ebp),%edx
    6d97:	89 50 0c             	mov    %edx,0xc(%eax)
	sys_dlist_init(&sem->wait_q);
#if defined(CONFIG_POLL)
	sys_dlist_init(&sem->poll_events);
    6d9a:	8d 50 10             	lea    0x10(%eax),%edx
	list->head = (sys_dnode_t *)list;
    6d9d:	89 00                	mov    %eax,(%eax)
	list->tail = (sys_dnode_t *)list;
    6d9f:	89 40 04             	mov    %eax,0x4(%eax)
	list->head = (sys_dnode_t *)list;
    6da2:	89 50 10             	mov    %edx,0x10(%eax)
	list->tail = (sys_dnode_t *)list;
    6da5:	89 50 14             	mov    %edx,0x14(%eax)
#endif

	SYS_TRACING_OBJ_INIT(k_sem, sem);
}
    6da8:	5d                   	pop    %ebp
    6da9:	c3                   	ret    

00006daa <k_sem_give>:
	_ready_thread(thread);
	_set_thread_return_value(thread, 0);
}

void k_sem_give(struct k_sem *sem)
{
    6daa:	55                   	push   %ebp
    6dab:	89 e5                	mov    %esp,%ebp
    6dad:	57                   	push   %edi
    6dae:	56                   	push   %esi
    6daf:	53                   	push   %ebx
    6db0:	8b 5d 08             	mov    0x8(%ebp),%ebx
	__asm__ volatile (
    6db3:	9c                   	pushf  
    6db4:	fa                   	cli    
    6db5:	5e                   	pop    %esi
	struct k_thread *thread = _unpend_first_thread(&sem->wait_q);
    6db6:	89 d8                	mov    %ebx,%eax
    6db8:	e8 49 ff ff ff       	call   6d06 <_unpend_first_thread>
	if (!thread) {
    6dbd:	85 c0                	test   %eax,%eax
    6dbf:	75 1f                	jne    6de0 <k_sem_give+0x36>
	sem->count += (sem->count != sem->limit);
    6dc1:	8b 53 08             	mov    0x8(%ebx),%edx
    6dc4:	31 c0                	xor    %eax,%eax
    6dc6:	39 53 0c             	cmp    %edx,0xc(%ebx)
    6dc9:	0f 95 c0             	setne  %al
    6dcc:	01 d0                	add    %edx,%eax
	return _handle_obj_poll_events(&sem->poll_events, state);
    6dce:	83 c3 10             	add    $0x10,%ebx
	sem->count += (sem->count != sem->limit);
    6dd1:	89 43 f8             	mov    %eax,-0x8(%ebx)
	return _handle_obj_poll_events(&sem->poll_events, state);
    6dd4:	6a 02                	push   $0x2
    6dd6:	53                   	push   %ebx
    6dd7:	e8 b6 f9 ff ff       	call   6792 <_handle_obj_poll_events>
    6ddc:	5a                   	pop    %edx
    6ddd:	59                   	pop    %ecx
    6dde:	eb 3c                	jmp    6e1c <k_sem_give+0x72>
    6de0:	89 c7                	mov    %eax,%edi
	return _abort_timeout(&thread->base.timeout);
    6de2:	8d 40 10             	lea    0x10(%eax),%eax
    6de5:	e8 6a ff ff ff       	call   6d54 <_abort_timeout>
	_ready_thread(thread);
    6dea:	89 f8                	mov    %edi,%eax
    6dec:	e8 f3 fe ff ff       	call   6ce4 <_ready_thread>
    6df1:	8b 47 28             	mov    0x28(%edi),%eax
    6df4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return !_is_in_isr() && _must_switch_threads();
    6dfa:	83 3d c0 54 40 00 00 	cmpl   $0x0,0x4054c0
    6e01:	75 31                	jne    6e34 <k_sem_give+0x8a>
	return _is_preempt(_current) && __must_switch_threads();
    6e03:	a1 c8 54 40 00       	mov    0x4054c8,%eax
    6e08:	66 83 78 0a 7f       	cmpw   $0x7f,0xa(%eax)
    6e0d:	77 25                	ja     6e34 <k_sem_give+0x8a>
    6e0f:	e8 6f fd ff ff       	call   6b83 <__must_switch_threads>
    6e14:	85 c0                	test   %eax,%eax
    6e16:	0f 95 c0             	setne  %al
    6e19:	0f b6 c0             	movzbl %al,%eax
	unsigned int key;

	key = irq_lock();

	if (do_sem_give(sem)) {
    6e1c:	85 c0                	test   %eax,%eax
    6e1e:	74 14                	je     6e34 <k_sem_give+0x8a>
	_update_time_slice_before_swap();
    6e20:	e8 b0 fe ff ff       	call   6cd5 <_update_time_slice_before_swap>
	return __swap(key);
    6e25:	89 75 08             	mov    %esi,0x8(%ebp)
		_Swap(key);
	} else {
		irq_unlock(key);
	}
}
    6e28:	8d 65 f4             	lea    -0xc(%ebp),%esp
    6e2b:	5b                   	pop    %ebx
    6e2c:	5e                   	pop    %esi
    6e2d:	5f                   	pop    %edi
    6e2e:	5d                   	pop    %ebp
    6e2f:	e9 3d ed ff ff       	jmp    5b71 <__swap>
    6e34:	0f ba e6 09          	bt     $0x9,%esi
    6e38:	73 01                	jae    6e3b <k_sem_give+0x91>
	__asm__ volatile (
    6e3a:	fb                   	sti    
    6e3b:	8d 65 f4             	lea    -0xc(%ebp),%esp
    6e3e:	5b                   	pop    %ebx
    6e3f:	5e                   	pop    %esi
    6e40:	5f                   	pop    %edi
    6e41:	5d                   	pop    %ebp
    6e42:	c3                   	ret    

00006e43 <k_sem_take>:

int k_sem_take(struct k_sem *sem, s32_t timeout)
{
    6e43:	55                   	push   %ebp
    6e44:	89 e5                	mov    %esp,%ebp
    6e46:	53                   	push   %ebx
    6e47:	8b 55 08             	mov    0x8(%ebp),%edx
    6e4a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	__asm__ volatile (
    6e4d:	9c                   	pushf  
    6e4e:	fa                   	cli    
    6e4f:	5b                   	pop    %ebx
	__ASSERT(!_is_in_isr() || timeout == K_NO_WAIT, "");

	unsigned int key = irq_lock();

	if (likely(sem->count > 0)) {
    6e50:	8b 42 08             	mov    0x8(%edx),%eax
    6e53:	85 c0                	test   %eax,%eax
    6e55:	74 08                	je     6e5f <k_sem_take+0x1c>
		sem->count--;
    6e57:	48                   	dec    %eax
    6e58:	89 42 08             	mov    %eax,0x8(%edx)
		irq_unlock(key);
		return 0;
    6e5b:	31 c0                	xor    %eax,%eax
    6e5d:	eb 09                	jmp    6e68 <k_sem_take+0x25>
	}

	if (timeout == K_NO_WAIT) {
    6e5f:	85 c9                	test   %ecx,%ecx
    6e61:	75 0e                	jne    6e71 <k_sem_take+0x2e>
		irq_unlock(key);
		return -EBUSY;
    6e63:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    6e68:	0f ba e3 09          	bt     $0x9,%ebx
    6e6c:	73 1d                	jae    6e8b <k_sem_take+0x48>
	__asm__ volatile (
    6e6e:	fb                   	sti    
    6e6f:	eb 1a                	jmp    6e8b <k_sem_take+0x48>
	}

	_pend_current_thread(&sem->wait_q, timeout);
    6e71:	51                   	push   %ecx
    6e72:	52                   	push   %edx
    6e73:	e8 e6 fc ff ff       	call   6b5e <_pend_current_thread>
    6e78:	58                   	pop    %eax
    6e79:	5a                   	pop    %edx
	_update_time_slice_before_swap();
    6e7a:	e8 56 fe ff ff       	call   6cd5 <_update_time_slice_before_swap>
	return __swap(key);
    6e7f:	89 5d 08             	mov    %ebx,0x8(%ebp)

	return _Swap(key);
}
    6e82:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6e85:	c9                   	leave  
    6e86:	e9 e6 ec ff ff       	jmp    5b71 <__swap>
    6e8b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6e8e:	c9                   	leave  
    6e8f:	c3                   	ret    

00006e90 <_nano_sys_clock_tick_announce>:
 * timers that have expired and wake up the threads pending on them.
 *
 * @return N/A
 */
void _nano_sys_clock_tick_announce(s32_t ticks)
{
    6e90:	55                   	push   %ebp
    6e91:	89 e5                	mov    %esp,%ebp
    6e93:	57                   	push   %edi
    6e94:	56                   	push   %esi
    6e95:	53                   	push   %ebx
    6e96:	83 ec 08             	sub    $0x8,%esp
    6e99:	8b 75 08             	mov    0x8(%ebp),%esi
	__asm__ volatile (
    6e9c:	9c                   	pushf  
    6e9d:	fa                   	cli    
    6e9e:	5f                   	pop    %edi

	K_DEBUG("ticks: %d\n", ticks);

	/* 64-bit value, ensure atomic access with irq lock */
	key = irq_lock();
	_sys_clock_tick_count += ticks;
    6e9f:	8b 0d f0 55 40 00    	mov    0x4055f0,%ecx
    6ea5:	89 f0                	mov    %esi,%eax
    6ea7:	8b 1d f4 55 40 00    	mov    0x4055f4,%ebx
    6ead:	99                   	cltd   
    6eae:	01 c8                	add    %ecx,%eax
    6eb0:	11 da                	adc    %ebx,%edx
    6eb2:	a3 f0 55 40 00       	mov    %eax,0x4055f0
    6eb7:	0f ba e7 09          	bt     $0x9,%edi
    6ebb:	89 15 f4 55 40 00    	mov    %edx,0x4055f4
    6ec1:	73 01                	jae    6ec4 <_nano_sys_clock_tick_announce+0x34>
	__asm__ volatile (
    6ec3:	fb                   	sti    
	list->head = (sys_dnode_t *)list;
    6ec4:	8d 4d ec             	lea    -0x14(%ebp),%ecx
    6ec7:	89 4d ec             	mov    %ecx,-0x14(%ebp)
	list->tail = (sys_dnode_t *)list;
    6eca:	89 4d f0             	mov    %ecx,-0x10(%ebp)
	__asm__ volatile (
    6ecd:	9c                   	pushf  
    6ece:	fa                   	cli    
    6ecf:	5b                   	pop    %ebx
	return list->head == list;
    6ed0:	a1 cc 54 40 00       	mov    0x4054cc,%eax
    6ed5:	89 da                	mov    %ebx,%edx
	if (!head) {
    6ed7:	85 c0                	test   %eax,%eax
    6ed9:	74 07                	je     6ee2 <_nano_sys_clock_tick_announce+0x52>
    6edb:	3d cc 54 40 00       	cmp    $0x4054cc,%eax
    6ee0:	75 09                	jne    6eeb <_nano_sys_clock_tick_announce+0x5b>
    6ee2:	0f ba e3 09          	bt     $0x9,%ebx
    6ee6:	73 70                	jae    6f58 <_nano_sys_clock_tick_announce+0xc8>
	__asm__ volatile (
    6ee8:	fb                   	sti    
    6ee9:	eb 6d                	jmp    6f58 <_nano_sys_clock_tick_announce+0xc8>
	head->delta_ticks_from_prev -= ticks;
    6eeb:	29 70 10             	sub    %esi,0x10(%eax)
	_handling_timeouts = 1;
    6eee:	c7 05 e8 55 40 00 01 	movl   $0x1,0x4055e8
    6ef5:	00 00 00 
	while (timeout && timeout->delta_ticks_from_prev == 0) {
    6ef8:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
    6efc:	75 3e                	jne    6f3c <_nano_sys_clock_tick_announce+0xac>
	node->prev->next = node->next;
    6efe:	8b 58 04             	mov    0x4(%eax),%ebx
    6f01:	8b 38                	mov    (%eax),%edi
    6f03:	0f ba e2 09          	bt     $0x9,%edx
    6f07:	89 3b                	mov    %edi,(%ebx)
	node->next->prev = node->prev;
    6f09:	8b 38                	mov    (%eax),%edi
    6f0b:	89 5f 04             	mov    %ebx,0x4(%edi)
	node->next = list->head;
    6f0e:	8b 5d ec             	mov    -0x14(%ebp),%ebx
    6f11:	89 18                	mov    %ebx,(%eax)
	node->prev = list;
    6f13:	89 48 04             	mov    %ecx,0x4(%eax)
	list->head->prev = node;
    6f16:	8b 5d ec             	mov    -0x14(%ebp),%ebx
	list->head = node;
    6f19:	89 45 ec             	mov    %eax,-0x14(%ebp)
	list->head->prev = node;
    6f1c:	89 43 04             	mov    %eax,0x4(%ebx)
		timeout->delta_ticks_from_prev = _EXPIRED;
    6f1f:	c7 40 10 fe ff ff ff 	movl   $0xfffffffe,0x10(%eax)
    6f26:	73 01                	jae    6f29 <_nano_sys_clock_tick_announce+0x99>
    6f28:	fb                   	sti    
	__asm__ volatile (
    6f29:	9c                   	pushf  
    6f2a:	fa                   	cli    
    6f2b:	5a                   	pop    %edx
	return list->head == list;
    6f2c:	a1 cc 54 40 00       	mov    0x4054cc,%eax
	return sys_dlist_is_empty(list) ? NULL : list->head;
    6f31:	3d cc 54 40 00       	cmp    $0x4054cc,%eax
    6f36:	74 04                	je     6f3c <_nano_sys_clock_tick_announce+0xac>
	while (timeout && timeout->delta_ticks_from_prev == 0) {
    6f38:	85 c0                	test   %eax,%eax
    6f3a:	75 bc                	jne    6ef8 <_nano_sys_clock_tick_announce+0x68>
    6f3c:	0f ba e2 09          	bt     $0x9,%edx
    6f40:	73 01                	jae    6f43 <_nano_sys_clock_tick_announce+0xb3>
	__asm__ volatile (
    6f42:	fb                   	sti    
	return list->head == list;
    6f43:	8b 45 ec             	mov    -0x14(%ebp),%eax
	SYS_DLIST_FOR_EACH_CONTAINER_SAFE(expired, timeout, next, node) {
    6f46:	39 c8                	cmp    %ecx,%eax
    6f48:	74 04                	je     6f4e <_nano_sys_clock_tick_announce+0xbe>
    6f4a:	85 c0                	test   %eax,%eax
    6f4c:	75 62                	jne    6fb0 <_nano_sys_clock_tick_announce+0x120>
	_handling_timeouts = 0;
    6f4e:	c7 05 e8 55 40 00 00 	movl   $0x0,0x4055e8
    6f55:	00 00 00 
	if (!_is_thread_time_slicing(_current)) {
    6f58:	ff 35 c8 54 40 00    	pushl  0x4054c8
    6f5e:	e8 37 fd ff ff       	call   6c9a <_is_thread_time_slicing>
    6f63:	59                   	pop    %ecx
    6f64:	85 c0                	test   %eax,%eax
    6f66:	0f 84 e3 00 00 00    	je     704f <_nano_sys_clock_tick_announce+0x1bf>
#ifdef CONFIG_SYS_CLOCK_EXISTS

#ifdef _NON_OPTIMIZED_TICKS_PER_SEC
	return (MSEC_PER_SEC * (u64_t)ticks) / sys_clock_ticks_per_sec;
#else
	return (u64_t)ticks * _ms_per_tick;
    6f6c:	6b f6 0a             	imul   $0xa,%esi,%esi
	_time_slice_elapsed += __ticks_to_ms(ticks);
    6f6f:	03 35 ec 55 40 00    	add    0x4055ec,%esi
    6f75:	89 35 ec 55 40 00    	mov    %esi,0x4055ec
	if (_time_slice_elapsed >= _time_slice_duration) {
    6f7b:	3b 35 e0 55 40 00    	cmp    0x4055e0,%esi
    6f81:	0f 8c c8 00 00 00    	jl     704f <_nano_sys_clock_tick_announce+0x1bf>
		_time_slice_elapsed = 0;
    6f87:	c7 05 ec 55 40 00 00 	movl   $0x0,0x4055ec
    6f8e:	00 00 00 
	__asm__ volatile (
    6f91:	9c                   	pushf  
    6f92:	fa                   	cli    
    6f93:	5b                   	pop    %ebx
		_move_thread_to_end_of_prio_q(_current);
    6f94:	ff 35 c8 54 40 00    	pushl  0x4054c8
    6f9a:	e8 4f fc ff ff       	call   6bee <_move_thread_to_end_of_prio_q>
    6f9f:	5a                   	pop    %edx
    6fa0:	0f ba e3 09          	bt     $0x9,%ebx
    6fa4:	0f 83 a5 00 00 00    	jae    704f <_nano_sys_clock_tick_announce+0x1bf>
	__asm__ volatile (
    6faa:	fb                   	sti    
	if ((!remaining && next_to) || (next_to < remaining)) {
		/* Clears current program if next_to = 0 and remaining > 0 */
		_set_time(next_to);
	}
#endif
}
    6fab:	e9 9f 00 00 00       	jmp    704f <_nano_sys_clock_tick_announce+0x1bf>
    6fb0:	31 db                	xor    %ebx,%ebx
	return (node == list->tail) ? NULL : node->next;
    6fb2:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    6fb5:	74 54                	je     700b <_nano_sys_clock_tick_announce+0x17b>
    6fb7:	8b 18                	mov    (%eax),%ebx
    6fb9:	eb 50                	jmp    700b <_nano_sys_clock_tick_announce+0x17b>
	if (timeout_obj->wait_q) {
    6fbb:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
    6fbf:	74 17                	je     6fd8 <_nano_sys_clock_tick_announce+0x148>
	node->prev->next = node->next;
    6fc1:	8b 42 04             	mov    0x4(%edx),%eax
    6fc4:	8b 0a                	mov    (%edx),%ecx
    6fc6:	89 08                	mov    %ecx,(%eax)
	node->next->prev = node->prev;
    6fc8:	8b 0a                	mov    (%edx),%ecx
    6fca:	89 41 04             	mov    %eax,0x4(%ecx)
		thread->base.timeout.wait_q = NULL;
    6fcd:	c7 42 1c 00 00 00 00 	movl   $0x0,0x1c(%edx)
	thread->base.thread_state &= ~_THREAD_PENDING;
    6fd4:	80 62 09 fd          	andb   $0xfd,0x9(%edx)
	thread->base.thread_state &= ~_THREAD_PRESTART;
    6fd8:	8a 42 09             	mov    0x9(%edx),%al
    6fdb:	88 c1                	mov    %al,%cl
    6fdd:	83 e1 fb             	and    $0xfffffffb,%ecx
	return !(_is_thread_prevented_from_running(thread) ||
    6fe0:	a8 1b                	test   $0x1b,%al
	thread->base.thread_state &= ~_THREAD_PRESTART;
    6fe2:	88 4a 09             	mov    %cl,0x9(%edx)
	return !(_is_thread_prevented_from_running(thread) ||
    6fe5:	74 43                	je     702a <_nano_sys_clock_tick_announce+0x19a>
    6fe7:	0f ba e7 09          	bt     $0x9,%edi
    6feb:	73 01                	jae    6fee <_nano_sys_clock_tick_announce+0x15e>
    6fed:	fb                   	sti    
	SYS_DLIST_FOR_EACH_CONTAINER_SAFE(expired, timeout, next, node) {
    6fee:	85 db                	test   %ebx,%ebx
    6ff0:	0f 84 58 ff ff ff    	je     6f4e <_nano_sys_clock_tick_announce+0xbe>
    6ff6:	31 d2                	xor    %edx,%edx
	return (node == list->tail) ? NULL : node->next;
    6ff8:	39 5d f0             	cmp    %ebx,-0x10(%ebp)
    6ffb:	74 02                	je     6fff <_nano_sys_clock_tick_announce+0x16f>
    6ffd:	8b 13                	mov    (%ebx),%edx
    6fff:	85 db                	test   %ebx,%ebx
    7001:	0f 84 47 ff ff ff    	je     6f4e <_nano_sys_clock_tick_announce+0xbe>
    7007:	89 d8                	mov    %ebx,%eax
    7009:	89 d3                	mov    %edx,%ebx
	node->prev->next = node->next;
    700b:	8b 50 04             	mov    0x4(%eax),%edx
    700e:	8b 08                	mov    (%eax),%ecx
    7010:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
    7012:	8b 08                	mov    (%eax),%ecx
    7014:	89 51 04             	mov    %edx,0x4(%ecx)
	struct k_thread *thread = timeout->thread;
    7017:	8b 50 08             	mov    0x8(%eax),%edx
	__asm__ volatile (
    701a:	9c                   	pushf  
    701b:	fa                   	cli    
    701c:	5f                   	pop    %edi
	timeout->delta_ticks_from_prev = _INACTIVE;
    701d:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)
	if (thread) {
    7024:	85 d2                	test   %edx,%edx
    7026:	75 93                	jne    6fbb <_nano_sys_clock_tick_announce+0x12b>
    7028:	eb 08                	jmp    7032 <_nano_sys_clock_tick_announce+0x1a2>
    702a:	83 7a 20 ff          	cmpl   $0xffffffff,0x20(%edx)
    702e:	75 b7                	jne    6fe7 <_nano_sys_clock_tick_announce+0x157>
    7030:	eb 14                	jmp    7046 <_nano_sys_clock_tick_announce+0x1b6>
    7032:	0f ba e7 09          	bt     $0x9,%edi
    7036:	73 01                	jae    7039 <_nano_sys_clock_tick_announce+0x1a9>
	__asm__ volatile (
    7038:	fb                   	sti    
		if (timeout->func) {
    7039:	8b 50 14             	mov    0x14(%eax),%edx
    703c:	85 d2                	test   %edx,%edx
    703e:	74 ae                	je     6fee <_nano_sys_clock_tick_announce+0x15e>
			timeout->func(timeout);
    7040:	50                   	push   %eax
    7041:	ff d2                	call   *%edx
    7043:	5f                   	pop    %edi
    7044:	eb a8                	jmp    6fee <_nano_sys_clock_tick_announce+0x15e>
		_add_thread_to_ready_q(thread);
    7046:	52                   	push   %edx
    7047:	e8 e3 f8 ff ff       	call   692f <_add_thread_to_ready_q>
    704c:	58                   	pop    %eax
    704d:	eb 98                	jmp    6fe7 <_nano_sys_clock_tick_announce+0x157>
    704f:	8d 65 f4             	lea    -0xc(%ebp),%esp
    7052:	5b                   	pop    %ebx
    7053:	5e                   	pop    %esi
    7054:	5f                   	pop    %edi
    7055:	5d                   	pop    %ebp
    7056:	c3                   	ret    

00007057 <_is_thread_ready>:
{
    7057:	55                   	push   %ebp
    7058:	89 e5                	mov    %esp,%ebp
	return !(_is_thread_prevented_from_running(thread) ||
    705a:	f6 40 09 1f          	testb  $0x1f,0x9(%eax)
    705e:	75 09                	jne    7069 <_is_thread_ready+0x12>
    7060:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
    7064:	0f 94 c0             	sete   %al
    7067:	eb 02                	jmp    706b <_is_thread_ready+0x14>
    7069:	31 c0                	xor    %eax,%eax
    706b:	0f b6 c0             	movzbl %al,%eax
}
    706e:	5d                   	pop    %ebp
    706f:	c3                   	ret    

00007070 <_abort_timeout>:
{
    7070:	55                   	push   %ebp
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
    7071:	8b 48 10             	mov    0x10(%eax),%ecx
{
    7074:	89 e5                	mov    %esp,%ebp
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
    7076:	83 f9 ff             	cmp    $0xffffffff,%ecx
    7079:	74 24                	je     709f <_abort_timeout+0x2f>
	if (!sys_dlist_is_tail(&_timeout_q, &timeout->node)) {
    707b:	3b 05 d0 54 40 00    	cmp    0x4054d0,%eax
    7081:	74 05                	je     7088 <_abort_timeout+0x18>
	return (node == list->tail) ? NULL : node->next;
    7083:	8b 10                	mov    (%eax),%edx
		next->delta_ticks_from_prev += timeout->delta_ticks_from_prev;
    7085:	01 4a 10             	add    %ecx,0x10(%edx)
	node->prev->next = node->next;
    7088:	8b 50 04             	mov    0x4(%eax),%edx
    708b:	8b 08                	mov    (%eax),%ecx
    708d:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
    708f:	8b 08                	mov    (%eax),%ecx
    7091:	89 51 04             	mov    %edx,0x4(%ecx)
	timeout->delta_ticks_from_prev = _INACTIVE;
    7094:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)
	return 0;
    709b:	31 c0                	xor    %eax,%eax
    709d:	eb 03                	jmp    70a2 <_abort_timeout+0x32>
		return _INACTIVE;
    709f:	83 c8 ff             	or     $0xffffffff,%eax
}
    70a2:	5d                   	pop    %ebp
    70a3:	c3                   	ret    

000070a4 <k_is_in_isr>:
	     thread_data < _static_thread_data_list_end; \
	     thread_data++)


int k_is_in_isr(void)
{
    70a4:	55                   	push   %ebp
	return _is_in_isr();
    70a5:	31 c0                	xor    %eax,%eax
{
    70a7:	89 e5                	mov    %esp,%ebp
}
    70a9:	5d                   	pop    %ebp
	return _is_in_isr();
    70aa:	83 3d c0 54 40 00 00 	cmpl   $0x0,0x4054c0
    70b1:	0f 95 c0             	setne  %al
}
    70b4:	c3                   	ret    

000070b5 <_is_thread_essential>:
 *
 * Returns non-zero if current thread is essential, zero if it is not.
 */
int _is_thread_essential(void)
{
	return _current->base.user_options & K_ESSENTIAL;
    70b5:	a1 c8 54 40 00       	mov    0x4054c8,%eax
{
    70ba:	55                   	push   %ebp
    70bb:	89 e5                	mov    %esp,%ebp
}
    70bd:	5d                   	pop    %ebp
	return _current->base.user_options & K_ESSENTIAL;
    70be:	8a 40 08             	mov    0x8(%eax),%al
    70c1:	83 e0 01             	and    $0x1,%eax
}
    70c4:	c3                   	ret    

000070c5 <_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void _thread_entry(void (*entry)(void *, void *, void *),
				 void *p1, void *p2, void *p3)
{
    70c5:	55                   	push   %ebp
    70c6:	89 e5                	mov    %esp,%ebp
	entry(p1, p2, p3);
    70c8:	ff 75 14             	pushl  0x14(%ebp)
    70cb:	ff 75 10             	pushl  0x10(%ebp)
    70ce:	ff 75 0c             	pushl  0xc(%ebp)
    70d1:	ff 55 08             	call   *0x8(%ebp)
    70d4:	83 c4 0c             	add    $0xc,%esp

#ifdef CONFIG_STACK_SENTINEL
	_check_stack_sentinel();
#endif
#ifdef CONFIG_MULTITHREADING
	if (_is_thread_essential()) {
    70d7:	e8 d9 ff ff ff       	call   70b5 <_is_thread_essential>
    70dc:	85 c0                	test   %eax,%eax
    70de:	74 04                	je     70e4 <_thread_entry+0x1f>
		_k_except_reason(_NANO_ERR_INVALID_TASK_EXIT);
    70e0:	6a 03                	push   $0x3
    70e2:	cd 21                	int    $0x21
	}

	k_thread_abort(_current);
    70e4:	ff 35 c8 54 40 00    	pushl  0x4054c8
    70ea:	e8 28 02 00 00       	call   7317 <k_thread_abort>
    70ef:	58                   	pop    %eax

000070f0 <schedule_new_thread>:
}
#endif

#ifdef CONFIG_MULTITHREADING
static void schedule_new_thread(struct k_thread *thread, s32_t delay)
{
    70f0:	55                   	push   %ebp
#ifdef CONFIG_SYS_CLOCK_EXISTS
	if (delay == 0) {
    70f1:	85 d2                	test   %edx,%edx
{
    70f3:	89 e5                	mov    %esp,%ebp
    70f5:	57                   	push   %edi
    70f6:	56                   	push   %esi
    70f7:	53                   	push   %ebx
    70f8:	51                   	push   %ecx
    70f9:	89 c1                	mov    %eax,%ecx
	if (delay == 0) {
    70fb:	75 46                	jne    7143 <schedule_new_thread+0x53>
	__asm__ volatile (
    70fd:	9c                   	pushf  
    70fe:	fa                   	cli    
    70ff:	5b                   	pop    %ebx
	thread->base.thread_state &= ~_THREAD_PRESTART;
    7100:	80 60 09 fb          	andb   $0xfb,0x9(%eax)
	if (_is_thread_ready(thread)) {
    7104:	e8 4e ff ff ff       	call   7057 <_is_thread_ready>
    7109:	85 c0                	test   %eax,%eax
    710b:	75 09                	jne    7116 <schedule_new_thread+0x26>
    710d:	0f ba e3 09          	bt     $0x9,%ebx
    7111:	e9 b6 00 00 00       	jmp    71cc <schedule_new_thread+0xdc>
		_add_thread_to_ready_q(thread);
    7116:	51                   	push   %ecx
    7117:	e8 13 f8 ff ff       	call   692f <_add_thread_to_ready_q>
	return _is_preempt(_current) && __must_switch_threads();
    711c:	a1 c8 54 40 00       	mov    0x4054c8,%eax
    7121:	5a                   	pop    %edx
    7122:	66 83 78 0a 7f       	cmpw   $0x7f,0xa(%eax)
    7127:	77 e4                	ja     710d <schedule_new_thread+0x1d>
    7129:	e8 55 fa ff ff       	call   6b83 <__must_switch_threads>
    712e:	85 c0                	test   %eax,%eax
    7130:	74 db                	je     710d <schedule_new_thread+0x1d>
	_update_time_slice_before_swap();
    7132:	e8 9e fb ff ff       	call   6cd5 <_update_time_slice_before_swap>
	return __swap(key);
    7137:	53                   	push   %ebx
    7138:	e8 34 ea ff ff       	call   5b71 <__swap>
    713d:	58                   	pop    %eax
    713e:	e9 8c 00 00 00       	jmp    71cf <schedule_new_thread+0xdf>
    7143:	9c                   	pushf  
    7144:	fa                   	cli    
    7145:	8f 45 f0             	popl   -0x10(%ebp)
	return (s32_t)ceiling_fraction((u32_t)ms, _ms_per_tick);
    7148:	be 0a 00 00 00       	mov    $0xa,%esi
	_add_timeout(thread, &thread->base.timeout, wait_q, timeout_in_ticks);
    714d:	8d 58 10             	lea    0x10(%eax),%ebx
    7150:	8d 42 09             	lea    0x9(%edx),%eax
    7153:	31 d2                	xor    %edx,%edx
    7155:	f7 f6                	div    %esi
		start_thread(thread);
	} else {
		s32_t ticks = _TICK_ALIGN + _ms_to_ticks(delay);
    7157:	40                   	inc    %eax
	timeout->thread = thread;
    7158:	89 49 18             	mov    %ecx,0x18(%ecx)
    715b:	89 41 20             	mov    %eax,0x20(%ecx)
	return list->head == list;
    715e:	a1 cc 54 40 00       	mov    0x4054cc,%eax
	timeout->wait_q = (sys_dlist_t *)wait_q;
    7163:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
    716a:	85 c0                	test   %eax,%eax
    716c:	74 0d                	je     717b <schedule_new_thread+0x8b>
    716e:	8b 3d d0 54 40 00    	mov    0x4054d0,%edi
    7174:	3d cc 54 40 00       	cmp    $0x4054cc,%eax
    7179:	75 19                	jne    7194 <schedule_new_thread+0xa4>
	node->next = list;
    717b:	c7 41 10 cc 54 40 00 	movl   $0x4054cc,0x10(%ecx)
	node->prev = list->tail;
    7182:	a1 d0 54 40 00       	mov    0x4054d0,%eax
    7187:	89 41 14             	mov    %eax,0x14(%ecx)
	list->tail->next = node;
    718a:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
    718c:	89 1d d0 54 40 00    	mov    %ebx,0x4054d0
    7192:	eb 31                	jmp    71c5 <schedule_new_thread+0xd5>
		if (*delta <= in_q->delta_ticks_from_prev) {
    7194:	8b 51 20             	mov    0x20(%ecx),%edx
    7197:	8b 70 10             	mov    0x10(%eax),%esi
    719a:	39 f2                	cmp    %esi,%edx
    719c:	7f 18                	jg     71b6 <schedule_new_thread+0xc6>
			in_q->delta_ticks_from_prev -= *delta;
    719e:	29 d6                	sub    %edx,%esi
		node->prev = insert_point->prev;
    71a0:	8b 50 04             	mov    0x4(%eax),%edx
    71a3:	89 70 10             	mov    %esi,0x10(%eax)
    71a6:	89 51 14             	mov    %edx,0x14(%ecx)
		node->next = insert_point;
    71a9:	89 41 10             	mov    %eax,0x10(%ecx)
		insert_point->prev->next = node;
    71ac:	8b 50 04             	mov    0x4(%eax),%edx
    71af:	89 1a                	mov    %ebx,(%edx)
		insert_point->prev = node;
    71b1:	89 58 04             	mov    %ebx,0x4(%eax)
    71b4:	eb 0f                	jmp    71c5 <schedule_new_thread+0xd5>
		*delta -= in_q->delta_ticks_from_prev;
    71b6:	29 f2                	sub    %esi,%edx
	return (node == list->tail) ? NULL : node->next;
    71b8:	39 f8                	cmp    %edi,%eax
    71ba:	89 51 20             	mov    %edx,0x20(%ecx)
    71bd:	74 bc                	je     717b <schedule_new_thread+0x8b>
    71bf:	8b 00                	mov    (%eax),%eax
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
    71c1:	85 c0                	test   %eax,%eax
    71c3:	eb b4                	jmp    7179 <schedule_new_thread+0x89>
    71c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    71c8:	0f ba e0 09          	bt     $0x9,%eax
    71cc:	73 01                	jae    71cf <schedule_new_thread+0xdf>
	__asm__ volatile (
    71ce:	fb                   	sti    
	}
#else
	ARG_UNUSED(delay);
	start_thread(thread);
#endif
}
    71cf:	8d 65 f4             	lea    -0xc(%ebp),%esp
    71d2:	5b                   	pop    %ebx
    71d3:	5e                   	pop    %esi
    71d4:	5f                   	pop    %edi
    71d5:	5d                   	pop    %ebp
    71d6:	c3                   	ret    

000071d7 <k_thread_create>:
k_tid_t k_thread_create(struct k_thread *new_thread,
			k_thread_stack_t stack,
			size_t stack_size, void (*entry)(void *, void *, void*),
			void *p1, void *p2, void *p3,
			int prio, u32_t options, s32_t delay)
{
    71d7:	55                   	push   %ebp
    71d8:	89 e5                	mov    %esp,%ebp
    71da:	53                   	push   %ebx
	__ASSERT(!_is_in_isr(), "Threads may not be created in ISRs");
	_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    71db:	ff 75 28             	pushl  0x28(%ebp)
    71de:	ff 75 24             	pushl  0x24(%ebp)
    71e1:	ff 75 20             	pushl  0x20(%ebp)
    71e4:	ff 75 1c             	pushl  0x1c(%ebp)
    71e7:	ff 75 18             	pushl  0x18(%ebp)
    71ea:	ff 75 14             	pushl  0x14(%ebp)
    71ed:	ff 75 10             	pushl  0x10(%ebp)
    71f0:	ff 75 0c             	pushl  0xc(%ebp)
{
    71f3:	8b 5d 08             	mov    0x8(%ebp),%ebx
	_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    71f6:	53                   	push   %ebx
    71f7:	e8 9e e9 ff ff       	call   5b9a <_new_thread>
		    prio, options);

	schedule_new_thread(new_thread, delay);
    71fc:	89 d8                	mov    %ebx,%eax
	_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    71fe:	83 c4 24             	add    $0x24,%esp
	schedule_new_thread(new_thread, delay);
    7201:	8b 55 2c             	mov    0x2c(%ebp),%edx
    7204:	e8 e7 fe ff ff       	call   70f0 <schedule_new_thread>
	return new_thread;
}
    7209:	89 d8                	mov    %ebx,%eax
    720b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    720e:	c9                   	leave  
    720f:	c3                   	ret    

00007210 <_k_thread_single_abort>:

	_reschedule_threads(key);
}

void _k_thread_single_abort(struct k_thread *thread)
{
    7210:	55                   	push   %ebp
    7211:	89 e5                	mov    %esp,%ebp
    7213:	53                   	push   %ebx
    7214:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (thread->fn_abort != NULL) {
    7217:	8b 43 30             	mov    0x30(%ebx),%eax
    721a:	85 c0                	test   %eax,%eax
    721c:	74 02                	je     7220 <_k_thread_single_abort+0x10>
		thread->fn_abort();
    721e:	ff d0                	call   *%eax
	}

	if (_is_thread_ready(thread)) {
    7220:	89 d8                	mov    %ebx,%eax
    7222:	e8 30 fe ff ff       	call   7057 <_is_thread_ready>
    7227:	85 c0                	test   %eax,%eax
    7229:	74 09                	je     7234 <_k_thread_single_abort+0x24>
		_remove_thread_from_ready_q(thread);
    722b:	53                   	push   %ebx
    722c:	e8 47 f8 ff ff       	call   6a78 <_remove_thread_from_ready_q>
    7231:	58                   	pop    %eax
    7232:	eb 24                	jmp    7258 <_k_thread_single_abort+0x48>
	} else {
		if (_is_thread_pending(thread)) {
    7234:	f6 43 09 02          	testb  $0x2,0x9(%ebx)
    7238:	74 10                	je     724a <_k_thread_single_abort+0x3a>
	node->prev->next = node->next;
    723a:	8b 43 04             	mov    0x4(%ebx),%eax
    723d:	8b 13                	mov    (%ebx),%edx
    723f:	89 10                	mov    %edx,(%eax)
	node->next->prev = node->prev;
    7241:	8b 13                	mov    (%ebx),%edx
    7243:	89 42 04             	mov    %eax,0x4(%edx)
	thread->base.thread_state &= ~_THREAD_PENDING;
    7246:	80 63 09 fd          	andb   $0xfd,0x9(%ebx)
			_unpend_thread(thread);
		}
		if (_is_thread_timeout_active(thread)) {
    724a:	83 7b 20 ff          	cmpl   $0xffffffff,0x20(%ebx)
    724e:	74 08                	je     7258 <_k_thread_single_abort+0x48>
	return _abort_timeout(&thread->base.timeout);
    7250:	8d 43 10             	lea    0x10(%ebx),%eax
    7253:	e8 18 fe ff ff       	call   7070 <_abort_timeout>
	thread->base.thread_state |= _THREAD_DEAD;
    7258:	80 4b 09 08          	orb    $0x8,0x9(%ebx)
			_abort_thread_timeout(thread);
		}
	}
	_mark_thread_as_dead(thread);
}
    725c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    725f:	c9                   	leave  
    7260:	c3                   	ret    

00007261 <_init_static_threads>:

#ifdef CONFIG_MULTITHREADING
void _init_static_threads(void)
{
    7261:	55                   	push   %ebp
    7262:	89 e5                	mov    %esp,%ebp
    7264:	56                   	push   %esi
    7265:	53                   	push   %ebx
	unsigned int  key;

	_FOREACH_STATIC_THREAD(thread_data) {
    7266:	bb 9c 50 40 00       	mov    $0x40509c,%ebx
    726b:	81 fb 9c 50 40 00    	cmp    $0x40509c,%ebx
    7271:	73 2c                	jae    729f <_init_static_threads+0x3e>
		_new_thread(
    7273:	ff 73 20             	pushl  0x20(%ebx)
    7276:	ff 73 1c             	pushl  0x1c(%ebx)
    7279:	ff 73 18             	pushl  0x18(%ebx)
    727c:	ff 73 14             	pushl  0x14(%ebx)
    727f:	ff 73 10             	pushl  0x10(%ebx)
    7282:	ff 73 0c             	pushl  0xc(%ebx)
    7285:	ff 73 08             	pushl  0x8(%ebx)
    7288:	ff 73 04             	pushl  0x4(%ebx)
    728b:	ff 33                	pushl  (%ebx)
    728d:	e8 08 e9 ff ff       	call   5b9a <_new_thread>
			thread_data->init_p2,
			thread_data->init_p3,
			thread_data->init_prio,
			thread_data->init_options);

		thread_data->init_thread->init_data = thread_data;
    7292:	8b 03                	mov    (%ebx),%eax
		_new_thread(
    7294:	83 c4 24             	add    $0x24,%esp
		thread_data->init_thread->init_data = thread_data;
    7297:	89 58 2c             	mov    %ebx,0x2c(%eax)
	_FOREACH_STATIC_THREAD(thread_data) {
    729a:	83 c3 30             	add    $0x30,%ebx
    729d:	eb cc                	jmp    726b <_init_static_threads+0xa>
	--_current->base.sched_locked;
    729f:	a1 c8 54 40 00       	mov    0x4054c8,%eax
    72a4:	fe 48 0b             	decb   0xb(%eax)
	__asm__ volatile (
    72a7:	9c                   	pushf  
    72a8:	fa                   	cli    
    72a9:	5e                   	pop    %esi
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	key = irq_lock();
	_FOREACH_STATIC_THREAD(thread_data) {
    72aa:	bb 9c 50 40 00       	mov    $0x40509c,%ebx
    72af:	81 fb 9c 50 40 00    	cmp    $0x40509c,%ebx
    72b5:	73 14                	jae    72cb <_init_static_threads+0x6a>
		if (thread_data->init_delay != K_FOREVER) {
    72b7:	8b 53 24             	mov    0x24(%ebx),%edx
    72ba:	83 fa ff             	cmp    $0xffffffff,%edx
    72bd:	74 07                	je     72c6 <_init_static_threads+0x65>
			schedule_new_thread(thread_data->init_thread,
    72bf:	8b 03                	mov    (%ebx),%eax
    72c1:	e8 2a fe ff ff       	call   70f0 <schedule_new_thread>
	_FOREACH_STATIC_THREAD(thread_data) {
    72c6:	83 c3 30             	add    $0x30,%ebx
    72c9:	eb e4                	jmp    72af <_init_static_threads+0x4e>
    72cb:	0f ba e6 09          	bt     $0x9,%esi
    72cf:	73 01                	jae    72d2 <_init_static_threads+0x71>
	__asm__ volatile (
    72d1:	fb                   	sti    
					    thread_data->init_delay);
		}
	}
	irq_unlock(key);
	k_sched_unlock();
}
    72d2:	8d 65 f8             	lea    -0x8(%ebp),%esp
    72d5:	5b                   	pop    %ebx
    72d6:	5e                   	pop    %esi
    72d7:	5d                   	pop    %ebp
	k_sched_unlock();
    72d8:	e9 fa f8 ff ff       	jmp    6bd7 <k_sched_unlock>

000072dd <_init_thread_base>:
#endif

void _init_thread_base(struct _thread_base *thread_base, int priority,
		       u32_t initial_state, unsigned int options)
{
    72dd:	55                   	push   %ebp
    72de:	89 e5                	mov    %esp,%ebp
    72e0:	8b 45 08             	mov    0x8(%ebp),%eax
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (u8_t)options;
    72e3:	8b 55 14             	mov    0x14(%ebp),%edx
    72e6:	88 50 08             	mov    %dl,0x8(%eax)
	thread_base->thread_state = (u8_t)initial_state;
    72e9:	8b 55 10             	mov    0x10(%ebp),%edx
    72ec:	88 50 09             	mov    %dl,0x9(%eax)

	thread_base->prio = priority;
    72ef:	8b 55 0c             	mov    0xc(%ebp),%edx
    72f2:	88 50 0a             	mov    %dl,0xa(%eax)

	thread_base->sched_locked = 0;
    72f5:	c6 40 0b 00          	movb   $0x0,0xb(%eax)
	t->delta_ticks_from_prev = _INACTIVE;
    72f9:	c7 40 20 ff ff ff ff 	movl   $0xffffffff,0x20(%eax)
	t->wait_q = NULL;
    7300:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
	t->thread = NULL;
    7307:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	t->func = func;
    730e:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)

	/* swap_data does not need to be initialized */

	_init_thread_timeout(thread_base);
}
    7315:	5d                   	pop    %ebp
    7316:	c3                   	ret    

00007317 <k_thread_abort>:

extern void _k_thread_single_abort(struct k_thread *thread);

#if !defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void k_thread_abort(k_tid_t thread)
{
    7317:	55                   	push   %ebp
    7318:	89 e5                	mov    %esp,%ebp
    731a:	56                   	push   %esi
    731b:	53                   	push   %ebx
    731c:	8b 75 08             	mov    0x8(%ebp),%esi
	__asm__ volatile (
    731f:	9c                   	pushf  
    7320:	fa                   	cli    
    7321:	5b                   	pop    %ebx
	unsigned int key;

	key = irq_lock();

	_k_thread_single_abort(thread);
    7322:	56                   	push   %esi
    7323:	e8 e8 fe ff ff       	call   7210 <_k_thread_single_abort>
    7328:	5a                   	pop    %edx
	_thread_monitor_exit(thread);

	if (_current == thread) {
    7329:	3b 35 c8 54 40 00    	cmp    0x4054c8,%esi
    732f:	75 0c                	jne    733d <k_thread_abort+0x26>
	_update_time_slice_before_swap();
    7331:	e8 9f f9 ff ff       	call   6cd5 <_update_time_slice_before_swap>
	return __swap(key);
    7336:	53                   	push   %ebx
    7337:	e8 35 e8 ff ff       	call   5b71 <__swap>
    733c:	58                   	pop    %eax
		_Swap(key);
		CODE_UNREACHABLE;
	}

	/* The abort handler might have altered the ready queue. */
	_reschedule_threads(key);
    733d:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
    7340:	8d 65 f8             	lea    -0x8(%ebp),%esp
    7343:	5b                   	pop    %ebx
    7344:	5e                   	pop    %esi
    7345:	5d                   	pop    %ebp
	_reschedule_threads(key);
    7346:	e9 53 f8 ff ff       	jmp    6b9e <_reschedule_threads>

0000734b <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while ((0))
#endif

void idle(void *unused1, void *unused2, void *unused3)
{
    734b:	55                   	push   %ebp
    734c:	89 e5                	mov    %esp,%ebp
    734e:	9c                   	pushf  
    734f:	fa                   	cli    
    7350:	58                   	pop    %eax
	k_cpu_idle();
    7351:	e8 d5 e6 ff ff       	call   5a2b <k_cpu_idle>
    7356:	eb f6                	jmp    734e <idle+0x3>

00007358 <_OffsetAbsSyms>:
/*
 * The final link step uses the symbol _OffsetAbsSyms to force the linkage of
 * offsets.o into the ELF image.
 */

GEN_ABS_SYM_BEGIN(_OffsetAbsSyms)
    7358:	55                   	push   %ebp
    7359:	89 e5                	mov    %esp,%ebp

GEN_ABSOLUTE_SYM(__ISR_LIST_SIZEOF, sizeof(ISR_LIST));
GEN_ABSOLUTE_SYM(__MMU_REGION_SIZEOF, sizeof(struct mmu_region));


GEN_ABS_SYM_END
    735b:	5d                   	pop    %ebp
    735c:	c3                   	ret    

0000735d <_handle_exc_0_vector_0_stub>:
    735d:	6a 00                	push   $0x0
    735f:	68 59 5f 00 00       	push   $0x5f59
    7364:	e9 5a e7 ff ff       	jmp    5ac3 <_exception_enter>

00007369 <_handle_exc_2_vector_2_stub>:
    7369:	6a 00                	push   $0x0
    736b:	68 66 5f 00 00       	push   $0x5f66
    7370:	e9 4e e7 ff ff       	jmp    5ac3 <_exception_enter>

00007375 <_handle_exc_4_vector_4_stub>:
    7375:	6a 00                	push   $0x0
    7377:	68 76 5f 00 00       	push   $0x5f76
    737c:	e9 42 e7 ff ff       	jmp    5ac3 <_exception_enter>

00007381 <_handle_exc_5_vector_5_stub>:
    7381:	6a 00                	push   $0x0
    7383:	68 86 5f 00 00       	push   $0x5f86
    7388:	e9 36 e7 ff ff       	jmp    5ac3 <_exception_enter>

0000738d <_handle_exc_6_vector_6_stub>:
    738d:	6a 00                	push   $0x0
    738f:	68 96 5f 00 00       	push   $0x5f96
    7394:	e9 2a e7 ff ff       	jmp    5ac3 <_exception_enter>

00007399 <_handle_exc_7_vector_7_stub>:
    7399:	6a 00                	push   $0x0
    739b:	68 a6 5f 00 00       	push   $0x5fa6
    73a0:	e9 1e e7 ff ff       	jmp    5ac3 <_exception_enter>

000073a5 <_handle_exc_10_vector_10_stub>:
    73a5:	68 b6 5f 00 00       	push   $0x5fb6
    73aa:	e9 14 e7 ff ff       	jmp    5ac3 <_exception_enter>

000073af <_handle_exc_11_vector_11_stub>:
    73af:	68 c6 5f 00 00       	push   $0x5fc6
    73b4:	e9 0a e7 ff ff       	jmp    5ac3 <_exception_enter>

000073b9 <_handle_exc_12_vector_12_stub>:
    73b9:	68 d6 5f 00 00       	push   $0x5fd6
    73be:	e9 00 e7 ff ff       	jmp    5ac3 <_exception_enter>

000073c3 <_handle_exc_13_vector_13_stub>:
    73c3:	68 e6 5f 00 00       	push   $0x5fe6
    73c8:	e9 f6 e6 ff ff       	jmp    5ac3 <_exception_enter>

000073cd <_handle_exc_16_vector_16_stub>:
    73cd:	6a 00                	push   $0x0
    73cf:	68 f6 5f 00 00       	push   $0x5ff6
    73d4:	e9 ea e6 ff ff       	jmp    5ac3 <_exception_enter>

000073d9 <_handle_exc_17_vector_17_stub>:
    73d9:	68 06 60 00 00       	push   $0x6006
    73de:	e9 e0 e6 ff ff       	jmp    5ac3 <_exception_enter>

000073e3 <_handle_exc_18_vector_18_stub>:
    73e3:	6a 00                	push   $0x0
    73e5:	68 16 60 00 00       	push   $0x6016
    73ea:	e9 d4 e6 ff ff       	jmp    5ac3 <_exception_enter>

000073ef <_page_fault_handler_vector_14_stub>:
    73ef:	68 26 60 00 00       	push   $0x6026
    73f4:	e9 ca e6 ff ff       	jmp    5ac3 <_exception_enter>
